PROGRAM SAPMSM21
                 MESSAGE-ID SL
*                 LINE-SIZE  132
                 NO STANDARD PAGE HEADING.
************************************************************************
*
* (c) SAP Aktiengesellschaft
*     Systeme, Anwendungen und Produkte in der Datenverarbeitung
*
* Autoren: Mittelstein(mit)(SAP)            Auswertungen, Wartung,
*          Garbe(CAS-Nord), Roth(CAS-Nord)  Dialog-Teil
*          Lattrell(hjl) SAP                Wartung und Pflege
*
* @(#)sapmsm21.ab       4.0C+   SAP     98/02/04
************************************************************************
*     Dies ist der grosse Modulpool fuer die Transaktion SM21.
*     Er handhabt die Dynpros dieser Transaktion und enthaelt auch das
*     Coding fuer die Auswertung. Jenes Coding wird von den Reports
*     RSLG0000 und RSLG0001 mitbenutzt.
************************************************************************

**** open problems:
* Watch FIRSTTIME: Wird nicht mehr auf '2' gesetzt.

*-HISTORY---------------------------------------------------------------
* 05.06.2008 sol  gleiche Instanz bei 'kein aktives RFC-Ziel' Text-613
* 17.09.2007 sol  again - selection with date - 14.06.2007
* 14.06.2007 sol  Korrektur vom 09.03.2006 wurde nicht transportiert
* 26.02.2007 sol  fehlerhafte Anzeige bei Datumsformat DD/MMY/YYYY
*                 und alten und neuem Monat
* 27.12.2006 sol  Button Kurzdump fehlt nach Detailanzeige und Wahl
*                 nächster Eintrag oder vorheriger Eintrag
* 26.10.2006 sol  reset default line size to 255...es gibt
*                 Abhängigkeiten
*                 SAPLOCALHOST für Überschrift
* 09.10.2006 sol  kein Langtext wenn Nachrichtenklasse > 2 Stellen
*                 berücksichtigen unterschiedliches Datumsformat
*                 bei top_of_outline
*                 Korrektur für Druckoutput - Datum
* 04.10.2006 sol  set default linesize to 700 (double byte characters)
* 31.08.2006 sol  Buttons - nächster/voriger Eintrag fehlen bei Details
*                 Format des Datum im Inhaltsverzeichnis nicht korrekt
* 09.03.2006 sol  fehlerhafte Anzeige der Sätze wenn Daten aus dem
*                 Vormonat, Datumsfeld als CHAR vorhanden, durch SORT
*                 wird umgereiht, Sort ist erforderlich wegen
*                 Gruppen(=Datum)wechsel
* 24.02.2006 sol  nicht alle Parametersätze werden gelistet und daher
*                 die Variablen in der Folgezeile nicht ersetzt
* 20.01.2006 sol  Eventuell nicht gewollter Zeilenumbrauch bei Anzeige
* 19.12.2005 sol  Kurzdumpanzeige aus der Detailzeile
* 26.09.2005 sol  Ausgabe zentraler Syslog - Reihenfolge und Statistik
*                 Default Sort nach Datum und Instanz
* 02.09.2005 sol  gleicher Fehler auch im zentralen Syslog 26.02.2004
* 22.08.2005 sol  different unicode format for central syslog
* 11.07.2005 sol  new FORM for external usage ( get syslog tables)
* 15.06.2005 sol  ASSIGN_LENGTH_NEGATIVE bei DEST_LEN - prüfen
* 10.05.2005 sol  Anzeigen Statistikdaten jetzt o.k.
* 06.05.2005 sol  Einige Bereiche sind nicht sauber gelöscht
* 15.02.2005 sol  Menuleiste und Funktionstasten und Texte
*                 in Überschriften
* 25.11.2004 sol  Print button und layout
* 24.11.2004 sol  Ikone für Kurzdumpauswahl fehlt
* 30.09.2004 sol  unsaubere Anzeige bei RSLG0000 und RSLG0001
* 16.04.2004 sol  Parametersätze richtig selektieren
* 15.04.2004 sol  SAP-Prozess auf 3 Stellen auf auch Dynpro 2020
* 26.02.2004 sol  Feld für externen Modus darf nur von 0-9 enthalten
*                 da als Char definiert und in numerisch gewandlet wird
* 07.01.2004 sol  T100 Message bringen bei Detail-Anzeige mit Var.
* 28.04.2003 sol  SAP-Prozess auf 3 Stellen erweitert = RSLGSELTYP
*                 neues Feld RSLGSELNUM für die Proezss-Nummer
*
* 25.10.2002 sol  SY-VLINE at end of each line doesn't appear
*                 solve download problem as HTML
* 17.07.2002 sol  TSL1T: read with SY-LANGU = 'EN' when NO ENTRY is
*                 found with the login language
*
* 09.12.1998 hjl  Instanz anzeigen korrigiert (1st time Anzeige)
*
* 30.11.1998 hjl  Enjoy SM21: Bewertung wird farblich angezeigt
*
* 29.10.1998 hjl  Datum und Instanzwechsel liefern neue Headerzeile
*                 damit Datum in Überschrift korrekt gesetzt wird.
*
* 29.07.1998 hjl  collect_host und I_Am_Host auf 32 Zeichen erweitert
*
* 29.05.1998 hjl   refresh all_dests fehlte in find_all_dests
*
* 02.03.1998 hjl   neuer call SUSR_SHOW_USER_DETAILS fuer USR03 Zugriff
*
* 05.02.1998 hjl   neue Ausgabe von SAP Tasktyp (wie in SM50)
*                  3Zeichen Typ 2 Zeichen Wp Nummer
* 04.02.1998 hjl   Taskart Ux ist V1 Verbucher, Vx ist V2 Verbucher
*
* 04.02.1998 hjl   Zeile 4066 und 5864 weitere Parameter fuer docu_call
*                  eingefuegt Problem 403490/1995
* 19.09.1997 hjl      Feldlaenge für Arbgeb angepasst in Line 7681 ff
*                     f4 hilfe fuer instanzen (3030) refresh eingefuegt
* 11.12.1996 mit      Size of variable part increase from 32 to 64.
* 09.12.1996 mit      Size of development-class icreased from 4 to 30.
*-
* 12.11.1996 mit      Don't switch colors for lines with '>' as text
*                     start. (Handle as continuation lines.)
* 30.10.1996 mit      Switch many type P variables to type I.
*                     Add progress indicator.
*-3.10
* 30.10.1996 mit      Correct details for R/3 4.0  .
*                     18.09.1996 Init time parameters near midnight.
*                     18.09.1996 Switch for surpressing popups.
*                     13.05.1996 Use FORMAT HOTSPOT when
*                                offering special <F2>.
* 30.10.1996 mit      Correct details for R/3 3.1G .
*                     Disable ALL paths, when not authorizised.
* 30.10.1996 mit      Correct details for R/3 3.0F .
*-3.9
* 18.10.1995 mit      Write date in header (again)
*                     Write client and message-id columns by default.
*                     Write right hand frame line.
*                     Correct color for wraped texts.
*                     Correct columns when swichting between screen
*                       and spool output.
*                     Clear snap_stat between processings.
*-3.7
* 21.09.1995 mit      Remove <ZH>, </> and so on from docu texts.
*      .1995 mit      Message statistics only when statistics
*                     are asked for.
*-3.6
* 11.11.1994 mit      Make some more texts translatable.
*-3.5
* 09.09.1994 mit      color not the whole text field (too bloody) but
*                     only the problem class column.
* 07.09.1994 mit      Put length fields on WRITE statements, because
*                     the translators remove trailing elipses ("...")
* 06.09.1994 mit      New tables TSLE1,..4.
*                     And T100 key and errno moved into ENTRIESTAB.
*-3.4
*   .07.1994 mit      Correct a length field for new ABAP/4
*-
* 18.02.1994 mit      Adapt to new list coloring sheme.
* 17.02.1994 mit      Can switch on and off even more columns.
* 16.02.1994 mit      F1 and F4 for instance names.
* 16.02.1994 mit      Auxiliary FORM for RSLG0000/0001.
* 14.02.1994 mit      Program name is new selection criteria.
* 11.02.1994 mit      Checking and F4-support for generic fields.
* 13.01.1994 mit      Remove Dynpro 0100
*                     Merge PF status 'SNAP' into 'INFO'.
* 12.01.1994 mit      Inserted several COMMIT WORK, to tell the ABAP/4-
*                     processor, that I am still alive and dont want to
*                     be killed.
* 11.01.1994 mit      Transaction code as new selection criteria.
* 10.01.1994 mit      Screen 2020 split into 2020 and 2030.
*                     Both with F11 and F3.
* 06.01.1994 mit      All handling of SYSLOGTAB (the tables cache) and
*                     its FORMs like FILL_INTERN_TAB moved into new
*                     function pool 'SLO3'.
* 04.01.1994 mit      Repair message statistics.
* 16.12.1993 mit      Allow to collect remote local SysLogs from all
*                     active application servers.
* 15.12.1993 mit      Make listings colorful.
* 26.11.1993 mit      Renaming: RSLG0012 --> SAPMSM21
*                               RSLG0100 --> MSM21T02
*                               RSLG0104 --> MSM21T03
*                               RSLG0305 --> MSM21F35
*                               RSLG0306 --> MSM21F36
* 25.11.1993 mit      All FORMs for reading SysLog files converted into
*                     one Funktionsbaustein RSLG_READ_FILE.
* **.11.1993 mit      All FORM SEL_ST..., LAYOUT_ST... converted into
*                     Funktionsbausteine RSLG_SEL_..., RSLG_LAYOUT_...
* 08.11.1993 mit      Corr.: statistics are shown, whenever not empty.
* 05.11.1993 mit      Transaction was started with Dynpro 0100. Now it
*                     may be started on Dynpro 0200. Any warning, which
*                     would have been visible on Dynpro 0100 are shown
*                     via popup.
* 05.11.1993 mit      When the central SysLog file cannot be read, the
*                     menu item "switch to central" is disabled.
*-
* 02.11.1993 mit      Some 40 ABAP include files, which defined data,
*                     replaced by proper data dictionary definitions.
* 01.11.1993 mit      'slgtabe' replaced by AREA & SUBID in
*                     interface to USE_TABE_AND_DATA, FILL_INTERN_TAB,
*                     internal tables ENTRIESTAB, SYSLOGTAB,
*                     some hide variables, some auxiliary variables.
* 01.11.1993 mit      Some 30 ABAP-include files replaced by INTTAB
*                     table definitions in SAP-DD.
*---2.1a
* 29.10.1993 mit      Corr: Count also when several messages with same
*                     ID follow one by one.
*-
* 26.10.1993 mit      Circumvent ABAP error 25503
*-1.14 ---------------2.1a
* 12.07.1993 mit      Emergence correction: SNAP in central syslog must
*                     get only cpu id part of the instance name.
* 06.07.1993 mit      After [F2] the focus can be shifted up and down.
* 06.07.1993 mit      Correction when TSL1T entry no found.
* 06.07.1993 mit      Problem message's texts are intensified.
* 05.07.1993 mit      Nice documentation reader.
* 05.07.1993 mit      New environment functions:
*                     show SAPPARAM, permission rules, clocks.
*   .07.1993 mit      Many screen fields moved to DD (and documented.)
*   .07.1993 mit      Screen 0200 split into 0200 and 2020.
* 16.06.1993 mit      Wrap very long lines.
* 16.06.1993 mit      Simplified handling in 'non-expert mode'.
*-1.11
* 12.05.1993 mit      Can recognize central SysLog files with old
*                     format and outputs explanation.
*-1.10
* 04.05.1993 mit      Central syslog change: cpu id was replcaed by
*                     instance id.
*-1.9
* 27.04.1993 mit      Rearange all detail list layouts to avoid two
*                     column output.
* 27.04.1993 mit      Move many constants 100 and 140 to RECORD_L_SIZE,
*                     RECORD_C_SIZE and SYSLOG_FILE-RECORDSIZE .
* 27.04.1993 mit      No longer Output of "*" on DYNPRO 2000
*-1.8
* 27.04.1993 mit      Divide F8=Auswerten into F8=SysLog_lesen and
*                     F9=Neu_aufbereiten. So the popup "Shall I read the
*                     file again" will not pop that often.
* 27.04.1993 mit      Use parameter entries, even when they are neither
*                     selected nor printed.
* 27.04.1993 mit      Allow an open time range (no end time given).
*  ?    ?    kw ?     Replace 0 by SY-LINCT in NEW-PAGE LINE-COUNT
*-1.7
* 23.10.1992 mit      F5 (=GTPO) can setup selection criteria for
*                     reading the latest record only.
* 22.10.1992 mit      New selection critieria: start and stop point in
*                     files given als file locations. (By using random
*                     access, file reading can become much faster.)
* 20.10.1992 mit      Correction for some cases of selected central
*                     lists.
* 20.10.1992 mit      OK =DEBUG can rise a DEBUG_LEVEL.
*-1.4
* 28.09.1992 mit      Adapt to modification B11K005946 of Chr.Hoelters
* 16.09.1992 mit      All processing moved from RSLG0400 into RSLG0012.
* 15.09.1992 mit      Allow for sorting of entries.
* 14.09.1992 mit      Switch back from line buffers
*                       to WRITE and POSITION.
* 10.09.1992 mit      Major code rearrangement:
*                     All processing moved from RSLG0000 and RSLG0001 to
*                       RSLG0303 include file.
*                     Then moved from RSLG0303 include file to RSLG0012.
*                     Now RSLG0000 and RSLG0001 only contain some
*                       external perfroms.
*-
* 17.08.1992 mit      Some more internal outputs only, when W_SELF = 'X'
* 17.08.1992 mit      Correction agains SY-FDPOS reusage.
* 12.08.1992 mit      Handle parameter entries, which may preceed other
*                       entries in SysLog.
*-1.3
* 31.07.1992 mit      Output a warning, if not on collecting host
*                     Output a warning, if central SysLog not available
*-
* 31.07.1992 mit      Correct handling of timestamp in case of
*                     ABAP minidump (RABAX).
* 20.05.1992 mit      Decide wether RSLG0000 or RSLG0001 is running
*                       and handle CPU names.
* 19.05.1992 mit      Handling of ABAP/4 mini dump 'SNAP' added.
* 13.05.1992 mit      Hostname for ABAP/4-SNAP and for title page.
*-1.2
* 22.04.1992 mit      cpu id has now length 8 and
*                     no longer 6 plus 2 filler blanks.
*-
* 22.04.1992 mit      Title line after <F2> shall be only one line long.
* 22.04.1992 mit      Prepage vor variable LINES_ON_PAGE.
* 22.04.1992 mit      <F2> shows up to three timestamps, if they differ.
* 21.04.1992 mit      Statistics, which are longer than one page
*                     can be seen after <F2>.
* 21.04.1992 mit      New statistics: about message numbers.
* 21.04.1992 mit      Interface of FILL_INTERN_TAB enhanced.
*   .03.1992 Roth     Added: SET PF-STATUS
*   .03.1992 Roth     TASK has length 2
* 03.03.1992 Roth     Now, you can see the developementclasses and
*                     the classes of problems
* 03.03.1992 Roth     aux.varaibles to access TSL1T.
*            Roth     cache for TSL1T, TADIR, TSL1D.
*-1.1
* 26.02.1992 Roth     Now you can search by the developementclasses
*                     and by the classes of problems
*-
* 22.02.1992 Roth     If it exists you can read the documentation
*                     while pressing the F2-key.
*-1.1 (pre)
* 12.02.1992 Garbe    1st implementation of modul pool for transaction
*                     SM21 (CAS-Nord)
* 22.01.1992 mit      The decission wether to read two halfs of one
*                     file or two files is no longer be based on
*                     CALL 'C_SAPGPARAM' ... 'rslg/local/old_file'...
*                          = 'NOOLDSYSLOG'
*                     but on CALL 'C_GET_SYSLOG_POS' ID 'NOFI'...
* 17.01.1992 mit      Catch empty TSL01-entries.
*   .12.1991 mit      Must use local field-pointers when pointing to
*                       parameters or local fields.
* 17.01.1992 mit      Title lines only 79 columns.
*                     page limit number > 99 possible
*                     Adapt to new SY-DATUM format.
*                     Task name and CPU name are tested case-less
*                     allow for stop date for selection.
* 17.01.1992 mit      Task-Id and terminal name as selection criteria
*                       is no longer case sensitive.
* 17.01.1992 mit      New selection criteria: end date
* 15.11.1991 mit      New parameter W_SELF to surpress SysLog internal
*                       entries.
*   .11.1991 ?        Nicer parameters screen.
* 22.08.1991 mit      Store it again; because of transport problems
*                     all modifications of 20.08.1991 did not show
*                     up in the file.
* 20.08.1991 mit      unified approach to SHOW_..DETAILS.
* 01.08.1991 Prestel  $-substitution rewritten for speed.
* 17.05.1991 mit      Added: Special structure for data dictionary
*                     errors.
* 16.05.1991 mit      variables for the interface to DOKU.
* 16.05.1991 mit      I will read the first entry of the actual file
*                       first. In most case that entry is already to old
*                       for my selection criterias. Then I will continue
*                       within that file. If that entry is not too old,
*                       I close that file again and start searching at
*                       the begin of the old SysLog file. Only in that
*                       case both files are scaned.
* 16.05.1991 mit      Condensed code by using new FORM USE_THIS_ENTRY.
*                     All comment remainding to READ DATASET removed.
*                     CONDENSE all those blanks at end of filenames.
* 16.05.1991 mit      Many more different structures for SysLog entries.
*                     Output details for each of them.
* 24.04.1991 mit      Start up paramters modified.
* 22.03.1991 mit      a) Date with new ABAP data type D
*                     b) You can switch of the statistics to speed up
*                        the report.
* 12.02.1991 mit      can read wrap around SysLog files too.
*                     ( There is still an error in reading the first
*                       half of the file...)
* 12.02.1991 mit      new variables for MVS/IMS-DC
* 12.02.1991 mit      No SY_LINxx any more
* 20.11.1990 mit      File names no longer in "sapfile.h", but in
*                      SAPPARAM.
* 19.08.1990 mit      TABLE T100S renamed to TSL01.
* 01.06.1990 mit      client enlongate to three chars (0..255)
*                     You can choose for RSLG0000 and RSLG0001 the
*                       max. no. of pages for output of single entries.
*                       After that limit is reached, the rest of the
*                       file(s) is still read and processed for
*                       statistics.
*                     Enhanced counter field for record counters.
*                     Corrections on Table of Contents.
* 01.06.1990 mit      Default the date PARAMETER to 'today'. Otherwise
*                       the program meight run several minutes.
* 01.06.1990 mit      For each kind of RSLGTY_.../used structure show
*                       more detailed information at PF02.
*                     ABAP entries come in pairs. Store from 1st to 2nd
*                       in ABAP_INFO, Show both data, when PF02 on 2nd
*                       entry.
*                     Look into T100, when I got a key (at PF02).
*                     To do all that, some FORMs cracked to several
*                       samer ones.
* 16.05.1990 mit      Normal header written by ABAP list processor is
*                       enough for first page.
* 11.05.1990 mit      All TEXT-123 replaced by 'Some text here'(123) .
* 29.03.1990 mit      A CALLable function was renamed.
* 15.03.1990 mit      a) PARAMETERS can be used now.
*                     b) CALL can be used now to get filename.
*                     c) filenames can be full pathnames now.
*                     d) READ DATASET  EOF handling had been corrected.
*                     e) TABLE access to R/2 tables had been imlemented
*                        now.
*                     b) DETAIL and SUMMARY had been implemented in ABAP
*                        now.
*                     c) Last byte of record is used too.
* 16.01.1990 mit      a) After porting to OS/2.
*                     b) After porting to ANSI-C (OS/2's IBM C/2)
*                     c) Preparation for MVS: No line longer than
*                        80 bytes.
*                     d) Preparation for MVS: External names uniq within
*                        first 8 chars
*                     e) Preparation for BS2000: External names uniq
*                        within first 7 chars
*                     f) Modules renamed like procedures according
*                        to (e).
*                     g) Several data type names changed to capital
*                        letters.
* 02.01.1990 mit      Adaption to recent changes in SysLog entry format:
*                     a) transaction code and report name are stored
*                        both.
*                     b) data field was enlongated from 23 to 31
*                        characters.
*                     Modifications could NOT be TESTED in Hamburg, as
*                       we dont have any ABAP since march 1989.
* 07.09.1989 mit      ABAP source lines may no longer be longer than 72
*                       columns.
* 23.05.1989 mit      Comments added, which explain TEXT-123 variables.
* 22.05.1989 mit      WRITEs rebuild from column addressing to usage of
*                       line buffers.
* 18.05.1989 mit      I can use SY-LINCT and SY-LINSZ and SY-PAGNO now.
* 18.05.1989 mit      Handling of titles for special page and for line
*                       selection reprorts redesigned.
* 05.04.1989 mit      HIDE and AT LINE SELECTION aktivated, but not
*                       tested.
* 30.01.1989 mit      Lots of coding reused by rslg0001:
*                     rslg0303,rslg0304 : common includes for rslg0000
*                                         and rslg0001
*                     rslg0400 : FORM-pool for rslg0000 and rslg0001
* 24.01.1989 mit      Better start, when old SysLog is missing.
* 13.01.1989 mit
*            First release.
*
* History: This report bases on the report "RSSLOG00" from the world of
*          mainframes. It also does all those things on its own, which
*          the logical data base "TC" has done in the world of
*          mainframes.
*-END-HISTORY--------------------*/

************************************************************************
* Change history of ALV Development
* Program description: SAPMSM21
* Author: G Vijay Bhaskarudu(C5056148)
* Date :  08/06/2004
* Short description of the program: System Log Analysis
*---------------------------------------------------------------------*



TABLES: RSLGTYPE
      , T100               " messages
      , TADIR              " directory of development objects
      , TRDIR              " directory of ABAP/4 programs
      , TDEVC              " develoment classes
      , USR01, USR03       " users
      , TSTC, TSTCT        " transaction codes
      , TSL1D , *TSL1D
      , TSL1T
      , TSL2T
      , TSL3T
      , RSLGUPDATA
      , RSLGDODATA
      , RSLGABDATA
      , RSLGAXDATA
      , RSLGPRDATA
      , RSLGEPDATA
      , RSLGELDATA
      , RSLGEDDATA
      , RSLGERDATA
      , RSLGSQLDAT
      , RSLGDBIDAT
      , RSLGIBDATA
      , RSLGEXDATA
      , RSLGDDDATA
      , RSLGADDATA
      , RSLGCFDATA
      "
      , RSLGFILINF
      , RSLGSEL
      , RSLGLAYOUT
      .

CONSTANTS: VAR_PART_LG TYPE I VALUE 64 " Length of all rslg??data.
         .

DATA: MAY_WORK(1)    VALUE ' '
    , EXPERT_MODE(1) VALUE ' '
*   , rslginstid(20)          " As type definition for LIKE instructions
    , PROBLEM_INDICATOR(1)
    , SURPRESS_POPUPS(1)
    , NARROW_WINDOW_WARN(1) VALUE '?'      " ? Dont know
                                           "   ALl o.k.
                                           " X Must warn
    , CENTRAL_FILE_MISSING(1) VALUE '?'    " . Have warned
    , TSLE4_WRITTEN(1)        VALUE '?'
    , NO_TASKTNO(1)           VALUE ' '
    .

* Get the data type declarations for SysLog files.
*
INCLUDE MSM21TO2. "rslgentr.h"
INCLUDE MSM21TO3. "rslgcent.h"

*EJECT
**** begin of the dialog fraction: DATAs.

DATA: BEGIN OF EXPERT_FUNCTIONS OCCURS 40
    ,   FUNC(4)
    , END  OF  EXPERT_FUNCTIONS
    , BEGIN OF NORMALONLY_FUNCTIONS OCCURS 10
    ,   FUNC(4)
    , END  OF  NORMALONLY_FUNCTIONS
    , BEGIN OF LOCKED_FUNCTIONS OCCURS 10
    ,   FUNC(4)
    , END  OF  LOCKED_FUNCTIONS
    , BEGIN OF DISABLED_FUNCTIONS OCCURS 40
    ,   FUNC(4)
    , END  OF  DISABLED_FUNCTIONS
    .

**** Dynpro 200 ********************************************************

*     For pre-checks, which meight popup:
DATA: COLLECT_HOST(32)                               "hjl
    , I_AM_HOST(32)           " not shown             hjl
    , ACTFILENAME(79)
    , A_DUMMY_C_ENTRY(152)        " not shown
    .

DATA:
      DY_START_DATE TYPE D,
      DY_START_TIME TYPE T,
      DY_END_DATE TYPE D,
      DY_END_TIME TYPE T,
      DY_TASK_EXPLAIN(40),               " Also on Dy 2020
      DY_INST(20),
      DY_RFCDEST LIKE RSLGSEL-RFCDEST,   " unvisible, uses DY_INST
      "RSLGLAYOUT-MAXPAG
      DY_STATISTICS(1),
      DY_INTERNRECS(1),          " Also on DY 2020
      DY_PRINT(1),
      DY_TASK_SEL_TYP(3),
      DY_TASK_SEL_NUM(3),
      DY_OUT_MORE_SELS(42),
      DY_OUT_DEST(16).
*     RSLGTYPE-ENTREAD
*     RSLGTYPE-USER
*     RSLGTYPE-TCODE
*     RSLGTYPE-TASK               " Also on Dy 2020
*     RSLGTYPE-PRONLY
*     RSLGTYPE-PROWAR
*     RSLGTYPE-ALLMSG

DATA: ENTER_MODULPOOL_1ST_TIME VALUE 'X'
    .
* end dynpro 200

**** Dynpro 0321 *******************************************************
DATA: REASON1(49)
    , REASON2(49)
    , REASON3(49)
    , REUSE(1)
    , READAGAIN(1)
    .

DATA BEFORE_0321_PF_STATUS LIKE SY-PFKEY.

* end dynpro 0321

**** Dynpro 2000 *******************************************************

DATA: DY_2000_OLD_POS(8)    " use SYSLOG_FILE-POS
    , DY_2000_OLD_POS_N10(10) TYPE N   " for conversions
    , DY_2000_OLD_WC(8)     " use SYSLOG_FILE-WRAPCOUNT
    , DY_2000_OLD_WC_N6(6) TYPE N " for conversions
    , DY_2000_CUR_POS(8)    " use FC-POS
    , DY_2000_CUR_WC(8)     " use FC-WRAPCOUNT
    , DY_2000_ENTRIES(8)    " use FC-ENTRIES
    .
DATA: BEFORE_2000_PF_STATUS LIKE SY-PFKEY
    .

* end dynpro 2000

**** Dynpro 2010 *******************************************************

DATA: DY_COL_TABE
    , DY_COL_BEW
    , DY_COL_DEVCLASS
    , DY_COL_POSI
    , DY_LIN_PARAREC
    , DY_COL_MAND
    , DY_COL_DATE
    , DY_COL_PROG
    , DY_COL_TERM
    , DY_SCREEN
    , DY_PR80
    , DY_PR120
    , DY_PR132
    .
DATA: ENTER_DY2010_1ST_TIME VALUE 'X'
    , BEFORE_2010_PF_STATUS LIKE SY-PFKEY
    .

* end dynpro 2010

**** Dynpro 2020 *******************************************************

" RSLGTYPE-REPNA
DATA: REPNA_EXPLAIN(32)
    " RSLGTYPE-TASK
    "   DY_TASK_EXPLAIN
    , DY_CLASID1(1)
    , DY_CLASID2(1)
    , DY_CLASID3(1)
    , DY_CLASID4(1)
    , DY_CLASID5(1)
    , DY_CLASID6(1)
    "   TSL2T-CLASSNAME
    , DY_START_FILE(6)
    , DY_START_FILE_N6(6) TYPE N "for conversions
    , DY_START_POS(12)
    , DY_START_POS_N10(10) TYPE N "for conversions
    , DY_STOP_FILE(6)
    , DY_STOP_FILE_N6(6) TYPE N "for conversions
    , DY_STOP_POS(12)
    , DY_STOP_POS_N10(10) TYPE N "for conversions
    " TSL3T-SLTYPE
    , DY_TYPE(1)             " for intern handling of TSL3T-SLTYPE
    "   TSL3T-TXT
    " RSLGTYPE-TERMINAL
    " TADIR-DEVCLASS
    , DY_DEVCLASS LIKE TADIR-DEVCLASS
                             " for intern handling of TADIR-DEVCLASS
    "   TDEVC-CTEXT
    " DY_INTERNRECS
    .

DATA: WITHIN_2020_PROCESSING VALUE ' '
    , BEFORE_2020_PF_STATUS       LIKE SY-PFKEY
    , BEFORE_2020_TASK            LIKE RSLGTYPE-TASK
    , BEFORE_2020_CLASID1         LIKE DY_CLASID1
    , BEFORE_2020_CLASID2         LIKE DY_CLASID2
    , BEFORE_2020_CLASID3         LIKE DY_CLASID3
    , BEFORE_2020_CLASID4         LIKE DY_CLASID4
    , BEFORE_2020_CLASID5         LIKE DY_CLASID5
    , BEFORE_2020_CLASID6         LIKE DY_CLASID6
    , BEFORE_2020_START_FILE      LIKE DY_START_FILE
    , BEFORE_2020_START_FILE_N6   LIKE DY_START_FILE_N6
    , BEFORE_2020_START_POS       LIKE DY_START_POS
    , BEFORE_2020_START_POS_N10   LIKE DY_START_POS_N10
    , BEFORE_2020_STOP_FILE       LIKE DY_STOP_FILE
    , BEFORE_2020_DY_STOP_FILE_N6 LIKE DY_STOP_FILE_N6
    , BEFORE_2020_DY_STOP_POS     LIKE DY_STOP_POS
    , BEFORE_2020_DY_STOP_POS_N10 LIKE DY_STOP_POS_N10
    , BEFORE_2020_SLTYPE          LIKE TSL3T-SLTYPE
    , BEFORE_2020_TYPE            LIKE DY_TYPE
    , BEFORE_2020_TERMINAL        LIKE RSLGTYPE-TERMINAL
    , BEFORE_2020_DEVCLASS        LIKE TADIR-DEVCLASS
    , BEFORE_2020_INTERNRECS      LIKE DY_INTERNRECS
    .

* end dynpro 2020

**** Dynpro 2030 *******************************************************

DATA: BEGIN OF IGNORE_IDS OCCURS 20
    ,   AREA    LIKE TSL1D-AREA
    ,   SUBID   LIKE TSL1D-SUBID
    ,   DELETED
    ,   FRESH
    ,   TXT     LIKE TSL1T-TXT
    , END  OF  IGNORE_IDS
    " RSLGSEL-MSGINC
    , MSGINC_OFF           " as opposite field for radio box
    , IGNORE_IDS_CNT TYPE I
    , IGNORE_IDS_INC LIKE RSLGSEL-MSGINC
    , IGNORE_IDS_LST LIKE RSLGSEL-MSGLST
    , IGNORE_IDS_LST_LG TYPE I VALUE 20 " CONSTANT! no.of ids.
    .

DATA: WITHIN_2030_PROCESSING VALUE ' '
    , BEFORE_2030_PF_STATUS LIKE SY-PFKEY
    , BEFORE_2030_MSGINC    LIKE RSLGSEL-MSGINC
    , BEFORE_2030_MSGLST    LIKE RSLGSEL-MSGLST
    .

* end dynpro 2030

**** Dynpro 2040 *******************************************************

DATA: D2040_SEND_MSG(64)
    , D2040_SEND_DATE(10)
    , D2040_SEND_TIME(8)
    , D2040_COLL_MSG(64)
    , D2040_COLL_DATE(10)
    , D2040_COLL_TIME(8)
    .

* end dynpro 2040

**** Dynpro 30X0 *******************************************************
**** Dynpro 3000 *******************************************************

DATA: PATTERN_3000 LIKE RSLGTYPE-USER
    , DB_PATT_3000 LIKE RSLGTYPE-USER
    , COL_30X0     LIKE SY-CUCOL
    , ECOL_30X0    LIKE SY-CUCOL
    , ROW_30X0     LIKE SY-CUROW
    , EROW_30X0    LIKE SY-CUROW
    , FLD_30X0(20) "field name
    , BEGIN OF USR_3000 OCCURS 200.
        INCLUDE STRUCTURE USR01.
DATA: END  OF  USR_3000
    .

* end dynpro 3000

**** Dynpro 3010 *******************************************************

DATA: PATTERN_3010 LIKE RSLGTYPE-TCODE
    , DB_PATT_3010 LIKE RSLGTYPE-TCODE
    .

* end dynpro 3010

**** Dynpro 3020 *******************************************************

DATA: PATTERN_3020 LIKE RSLGTYPE-REPNA
    , DB_PATT_3020 LIKE RSLGTYPE-REPNA
    .

* end dynpro 3020

**** Dynpro 3030 *******************************************************

DATA: PATTERN_3030 LIKE RSLGSEL-RFCDEST
    .

* end dynpro 3030

* end dynpro 30X0

**** Allgemein *********************************************************
DATA: FCODE(4)
    , DEBUG_LEVEL(1) VALUE '0'
    , CURSOR_FIELD_NAME(30)
    .

**** end of the dialog fraction: DATAs.
*EJECT
**** begin of report fraction: DATAs.

DATA: SAP_A_BOOL(1),        " boolean values, as in all user interfaces
      SAP_YES(1) VALUE 'X', " Save tests should be   = SAP_NO
      SAP_NO(1)  VALUE ' '. " or                    NE SAP_NO
" Just to decide correctly, when
" somebody happened to use a small 'x'.

*         Constants for TA-WHICHLOG:
CONSTANTS: REP_ON_LOCAL(1)   VALUE 'L'
         , REP_ON_CENTRAL(1) VALUE 'C'
         , REP_ON_REMOTEL(1) VALUE 'R'
         , REP_ON_REMOTEA(1) VALUE 'A'
         .
DATA:     TA___WHICHLOG(1)
    .

CONSTANTS: NO_HOST(8)           VALUE 'NONE' " constant
    .

* Input data selection information
*
DATA: BEGIN OF TA.
        INCLUDE STRUCTURE RSLGSEL.
DATA: END OF TA
    .

* Copy of input data selection information used during file reading.
*
DATA:   LAST_TA_WHICHLOG(1)            " 'L' or 'C'
    , BEGIN OF LAST_TA.
        INCLUDE STRUCTURE RSLGSEL.
DATA: END OF LAST_TA
    .

*         Constants for NEED_SORT:
CONSTANTS: SORT_INST(4)     VALUE 'SOCP' "Instanz (former CPU)
         , SORT_DEVCLASS(4) VALUE 'SODC' "Entwicklungsklasse
         , SORT_FILE(4)     VALUE 'SOFI' "Schreibfolge
         , SORT_TABE(4)     VALUE 'SOID' "Meldungskennung
         , SORT_CLASID(4)   VALUE 'SOPC' "Problemklasse
         , SORT_TIME(4)     VALUE 'SOTI' "Uhrzeit
         , SORT_FTYP(4)     VALUE 'SOTY' "Meldungstyp
         , SORT_TTYP(4)     VALUE 'SOTA' "Tasktyp
         .

DATA: BEGIN OF LAYOUT.
        INCLUDE STRUCTURE RSLGLAYOUT.
DATA: END OF LAYOUT
    .

DATA: BEGIN OF SYSLOG_FILE.
        INCLUDE STRUCTURE RSLGFINFO.
DATA: END   OF SYSLOG_FILE
*   , record_l_size     type I value 100 " constant
    , RECORD_C_SIZE     TYPE I VALUE 152 " constant
    .

DATA: BEGIN OF FC
    ,   POS          TYPE I
    ,   POS_N10(10)  TYPE N " for conversions
    ,   WRAPCOUNT    TYPE I
    ,   WRAPCOUNT_N6(6) TYPE N " for conversions
    ,   ENTRIES      TYPE I
    ,   ENTRIES_N10(10)   TYPE N " for conversions
    ,   MAXSIZE      TYPE I
    , END   OF FC
    .

*         Constants for SEL_CHECK:
CONSTANTS: SEL_DURING_READING(1) VALUE 'R' " constant
         , SEL_DURING_RESCAN(1)  VALUE 'S' " constant
         .
*EJECT
* internal table ENTRIESTAB
*----------------==========
* When the local or the central SysLog file is read, some
* records are ignored and all the others are stored into this
* internal table 'ENTRIESTAB'. At any time this table
* contains either only entries from the local SysLog or from
* the central SysLog. Nevertheless there is only one DATA
* declaration. In case of local SysLog this is not the best
* way to store the data, but we get the advantage of having
* all the selecting and reporting code only once.
*
* To allow sorting, some of the fields, which are packed deeply in
* 'centdata' are copied out to 1st level fields.
*
* The fields of the title entry of this internal record are used
* heavyly during data collection and during data reporting.

DATA: BEGIN OF ENTRIESTAB OCCURS 2000.
        INCLUDE STRUCTURE RSLGETAB.
*    ,   FILE_NO LIKE TA-FILE_NO
*    ,   POS     LIKE TA-POS          " from SYSLOGTAB
**                                    * I made the first two fields
**                                    * of TYPE C, because I think
**                                    * that the sorting will be
**                                    * faster (no sign handling)
*    ,   sender_id      LIKE RSLGINSTID
*    ,   RECEVIVE_T     LIKE rslgtime " date and time from local
**                                    * clock.
**                                    * Format: yyyymmddhhmmss00
*    ,   POS_CREATT     LIKE rslgtime " date and time calculated
**                                    * for local clock.
**                                    * Format: yyyymmddhhmmss00
*    ,   centdata(100)  TYPE C          " 100 = sizeof(rslgentr)
**       * overlap by: rslgentr         " local SysLog entry
**       * overlap by: t_sender_info    " info about a sender daemon
**       * overlap by: t_file_info      " info about the SysLog file
**
**            duplicated fields to allow sorting:
*    ,   slgftyp LIKE rslgetype       " system log type
*    ,   AREA + SUBID(3) TYPE C       " system log table entry
*    ,   slgttyp LIKE RSLGTYPE-TASK   " task type
*    ,   CLASID                       " from TSL1D
*    ,   DEVCLASS(4)                  " from TADIR
DATA: END OF ENTRIESTAB
    , ENTRIESTAB_IX  LIKE SY-TABIX   " current entry

    , BEGIN OF ENTRIESTAB_2 OCCURS 500.
        INCLUDE STRUCTURE RSLGETAB.
DATA: END OF ENTRIESTAB_2
    .
DATA: OLD_SENDER_ID LIKE ENTRIESTAB-SENDER_ID.                     "xxx

DATA: H_ENTRY_PARA_REC LIKE RSLGETAB value ' '.
DATA: ACT_TAB_IND  like  SY-TABIX value 0.

DATA: BEGIN OF LOCAL_DESTS OCCURS 50.
        INCLUDE STRUCTURE RFCHOSTS.
DATA: END  OF  LOCAL_DESTS
    , BEGIN OF ALL_DESTS OCCURS 100.
        INCLUDE STRUCTURE RFCHOSTS.
DATA:   ACCESS TYPE I " 0=active, 4=not active
    , END  OF  ALL_DESTS
    , BEGIN OF I_SPFID OCCURS 50.
        INCLUDE STRUCTURE SPFID.
DATA: END  OF  I_SPFID
    , LAST_RFC_MESS(100)
    , NUMBER_OF_DESTS TYPE I
    , DESTS_DONE      TYPE I
    .

DATA CUR_SORT LIKE LAYOUT-NEED_SORT.
*
* How to sort:
*
*   SOCP: sender_id               "Rechner
*   SODC: DEVCLASS                "Entwicklungsklasse
*   SOFI: FILE_NO,POS             "Schreibfolge
*   SOID: AREA&SUBID              "Meldungskennung
*   SOPC: CLASID                  "Problemklasse
*   SOTI: POS_CREATT              "Uhrzeit
*   SOTY: slgftyp                 "Meldungstyp
*   SOTA: slgttyp                 "Tasktyp

*     -------------------------------------
*       Input buffer for one SysLog entry
*
DATA: AN_ENTRY_FILLED VALUE ' '
    .

DATA: BEGIN OF AN_ENTRY. " LIKE RSLGENTR.
        INCLUDE STRUCTURE RSLGENTR.
DATA: END OF AN_ENTRY.

* Auxilliary buffers to unpack nested structures
*
DATA: BEGIN OF AUX_slgtype. " LIKE rslgetyp
        INCLUDE STRUCTURE RSLGETYP.
DATA  END OF AUX_slgtype.

DATA: BEGIN OF AUX_slgproc. " LIKE rslgpid
        INCLUDE STRUCTURE RSLGPID.
DATA  END OF AUX_slgproc.

*EJECT
*       Input buffer for one entry from central SysLog
*
DATA: BEGIN OF AN_C_ENTRY. " LIKE rslgcent.
        INCLUDE STRUCTURE RSLGCENT.
DATA: END OF AN_C_ENTRY.


*       Convertion buffer for one entry from central SysLog
*       in case of unicode and different codepages
*       area for the above entry
*
DATA: BEGIN OF CONVERT_ONE_C_ENTRY. " LIKE rslgcent.
        INCLUDE STRUCTURE RSLGCENT.
DATA: END   OF CONVERT_ONE_C_ENTRY.


* Used for central SysLog only
DATA: BEGIN OF sender_info. " LIKE t_sender_info.
        INCLUDE STRUCTURE RSLGSNDINF.
DATA: END OF   sender_info.

* Used for central SysLog only:
DATA  DATE_OF_PAGE LIKE RSLGTYPE-TIME. " the date of the entries on this
" page.
" Note: Whene there are larger
"       disordering, there may be
"       older entries mixed into
"       this page.

*EJECT
* other working storage
*

DATA  SEL(1).            " Handshake between main and SELCHECK

DATA  PAGE_TYPE       TYPE C VALUE 'D'."' '= any other (without title)
"'-'= internal: "unset"
" D = DYNPRO header page
" N = normal (local SysLog)
" Z = normal (central SysLog)
" S = instance stat
" M = client stat
" T = transaction stat
" R = report stat
" B = user stat
" I = message stat
" J = message stat mesg.line
" E = ABAP SNAP entry
" A = ABAP SNAP stat
" L = list of counters
" C = table of contents
" OWNCLOCK VALUE 'c',
" OWNINFO  VALUE 'i',
" OWNUP    VALUE 'u',
" OWNDOWN  VALUE 'd',
" OWNFILE  VALUE 'f'.

DATA  PRINT_EACH_LINE LIKE SAP_A_BOOL VALUE 'X'. " = SAP_YES

DATA  INIT_TABS_CNT    TYPE I VALUE 0.

DATA  ABOUT_OLD_DATA          VALUE 'X'." 'N' : drop old data and read
"       with new selection
"       criterias
" 'A' : read with new selection
"       criterias and add to old
"       data
" 'R' : (re)use old data
" '?' : I dont know

DATA  END_REASON(1)    TYPE C VALUE '-'."Reason of end of report:
" '-' : no reason yet
" 'F' : file not found
" 'E' : end of file reached
" 'P' : page limit reached
" 'S' : stop position reached
" 'C' : file format error or
"       other error
DATA  END_INFO(79)                     .

DATA  FIRSTTIME        VALUE '1'.      " '1' on start of first main loop
" '2' on start of 2nd main loop
" 'N' else.


DATA  IN_MAIN_REPORT   VALUE 'Y'.      " 'Y' during wrinting of main
"     report.
" 'N' during line-selection.

DATA  LAST_TIME_STAMP  LIKE RSLGTYPE-TIME. " last valid time stamp of an
" SysLog entry.

DATA  TAB_LINES        TYPE I.         " Messure length of tables.

DATA: BEGIN OF RECORDCNT.
        INCLUDE STRUCTURE RSLGRECCNT.
DATA: END   OF RECORDCNT.

DATA: BEGIN OF REC_CNTS OCCURS 100
    ,   KIND(1)         " Read, Print
    ,   ERRRC TYPE I    " 0 or SY-SUBRC of RFC
    ,   ERRMESS(60).    " of RFC
        INCLUDE STRUCTURE RSLGSEL.
        INCLUDE STRUCTURE RSLGRECCNT.
DATA: END  OF  REC_CNTS
    .

*         table of contents
*
DATA:     BEGIN OF CONTENTS OCCURS 18,
            NAME(20)       TYPE C,
            START_PAGE     TYPE I,
            END_PAGE       TYPE I,
            START_TIME(16) TYPE C,
            END_TIME(16)   TYPE C,
          END OF CONTENTS.

DATA      CONTENTS_DATA_NAME(20).
DATA      CONTENTS_CHAPTER_EMPTY LIKE SAP_A_BOOL VALUE 'X'. "Yes
DATA      CONTENTS_NEXT_START_PAGE TYPE I.

DATA  CPU_ID     LIKE RSLGTYPE-CPUID.
DATA  RAW_CPU_ID LIKE RSLGTYPE-CPUID.

DATA  HIDE_LINE_TYPE LIKE PAGE_TYPE.   " At line-selection time I need
*                                      " to know the page type suitable
*                                      " for this line.

TYPES: MSGTEXT_T(700)   " For finally assembled message text.
     .

DATA: BEGIN OF HIDE_BUFFER
    ,   ENTRIESTAB_IX LIKE SY-TABIX    " after last sorting.
    ,   slgproc LIKE rslgpid           " identification of process
    ,   slgltrm LIKE RSLGTYPE-TERMINAL " name of terminal
    ,   slguser LIKE RSLGTYPE-USER     " user name
    ,   slgtc   LIKE RSLGTYPE-TCODE    " SAP transaction code
    ,   slgrepna LIKE RSLGTYPE-REPNA   " SAP report name
    ,   SLGMAND(3) TYPE C              " Mandant (client)
    ,   slgmode LIKE RSLGTYPE-SAPMODE  " "Arbeitsmodus"
    ,   slgdata LIKE RSLGENTR-SLGDATA
*   *   slgdata LIKE rslg_any_data     "
    ,   slgdattim LIKE RSLGTYPE-TIME   " date and time from local clock
    , END OF HIDE_BUFFER

    , HIDE_TEXT    TYPE MSGTEXT_T        " Long.
    , HIDE_TEXT_LG TYPE I

    , BEGIN OF HIDE_C_BUFFER           " Filled only in RSLG0001 !
    ,   native_s_id(47) TYPE C         " 47 = NATIDLG
                                       " LIKE t_sender_info-native_s_id,
    , END OF HIDE_C_BUFFER
      " Field 'computer_id' is filled once in rslg0000.

    , BEGIN OF HIDE_ABAP_INFO.
        INCLUDE STRUCTURE RSLGABDATA.  " Must be 1st in this BEGIN..END
DATA:   first_AREA     LIKE TSL1D-AREA
    ,   first_SUBID    LIKE TSL1D-SUBID
    , END   OF HIDE_ABAP_INFO

    , HIDE_PARAMS      LIKE RSLGTYPE-PARAMARRAY             " C(620)
*                      = 10 times C(62)
*                        10 = count(a,b,c,..j)

    , HIDE_AREA        LIKE TSL1D-AREA
    , HIDE_SUBID       LIKE TSL1D-SUBID
    .

DATA: BEGIN OF INST_STAT OCCURS 30,    " Statistics about cpus.
        INST(20) TYPE C,
        CNT     TYPE I,
      END OF INST_STAT.

DATA: BEGIN OF MAND_STAT OCCURS 30,    " Statistics about clients.
        MAND(3) TYPE C,
        CNT     TYPE I,
      END OF MAND_STAT.

DATA: BEGIN OF REPO_STAT OCCURS 60,    " Statistics about reports.
        REPO    LIKE RSLGTYPE-REPNA,
        CNT     TYPE I,
      END OF REPO_STAT.

DATA: BEGIN OF TCOD_STAT OCCURS 60,    " Statistics about transactions.
        TCOD    LIKE RSLGTYPE-TCODE,
        CNT     TYPE I,
      END OF TCOD_STAT.

DATA: BEGIN OF BENU_STAT OCCURS 60,    " Statistics about users.
        BENU    LIKE RSLGTYPE-USER,
        CNT     TYPE I,
      END OF BENU_STAT.

DATA: ACCU TYPE I                      " For this and that.
    .
*EJECT
* Format of output lines:
* =======================

DATA: BEGIN OF GEN_OUTLINE          "generic
    ,   FILE_NO(6)
    ,   POS(12)
    ,   DATE(10)
    ,   TIME(8)
    ,   INSTID(20)
    ,   TASK(2)         "old variant
    ,   TSKNA(3)        "new taskname
    ,   TSKNU(3)        "tasknumber
    ,   MAND(3)
    ,   USER(12)
    ,   TRANSCODE(4)
    ,   REPNA(8)
    ,   TERMINAL LIKE RSLGTYPE-TERMINAL
    ,   DEVCLASS(4)
    ,   AREA(2)
    ,   SUBID(1)
    ,   CLASID(1)
    ,   BEWERTUNG(9)
    ,   KATEGORIE(32)
    ,   TEXT          TYPE MSGTEXT_T    " Long!
    ,   TEXT_LG       TYPE I
    ,   IS_TITLE(1)
    ,   MONBEW LIKE TSL1D-MONBEW
    ,   MONKAT LIKE TSL1D-MONBEW
    ,   DATE_INT(8)
    , END   OF GEN_OUTLINE
    , ODDLINE        LIKE SY-LINNO
    , LAST_TASK      LIKE GEN_OUTLINE-TASK " for distinction of
                                           " continuation lines.
    .

*                           data for print function (top of page)
DATA: BEGIN OF HH_INT_USE_OUTLINE
    ,   DATE(10)   TYPE C
    ,   TIME(8)    TYPE C
    ,   USER(12)   TYPE C
    ,   NUMBER     TYPE I
    , END OF HH_INT_USE_OUTLINE
    .


DATA: BEGIN OF INT_USE_OUTLINE occurs 2000
    ,   DATE(10)   TYPE C
    ,   TIME(8)    TYPE C
    ,   USER(12)   TYPE C
    ,   NUMBER     TYPE I
    , END OF INT_USE_OUTLINE
    .

DATA: BEGIN OF OLD_INT_USE_OUTLINE occurs 2000
    ,   DATE(10)   TYPE C
    ,   TIME(8)    TYPE C
    ,   USER(12)   TYPE C
    ,   NUMBER     TYPE I
    , END OF OLD_INT_USE_OUTLINE
    .

*                            date for top of page on screen
DATA: BEGIN of INT_USE_DATE   occurs 0,
        DATE(10)    TYPE  C,
      END OF INT_USE_DATE.
*                            data after simualte top of page
DATA: BEGIN OF INT_USE_SIM_TOP occurs 0
    ,   DATE(10)   TYPE C
    ,   TIME(8)    TYPE C
    ,   USER(12)   TYPE C
    ,   NUMBER     TYPE I
    , END OF INT_USE_SIM_TOP
    .

*                            for data lines from central SysLog.
DATA: CUR_LINE_DATA(134)                                    " 134?
    , CUR_SPECIAL
    , USE_DATA         VALUE '-' " constant for CUR_SPECIAL
    , USE_GEN          VALUE ' ' " constant for CUR_SPECIAL
    , NO_OV_DATE       VALUE ' ' " constant for WRITE_DATA_LINE
    .

*                           explanations about new central SysLog file
DATA: BEGIN OF OWNFILE_REST,
        FI_FILENUM(5),
        FILLER01(1) VALUE ' ',
        TEXT(110),
      END   OF OWNFILE_REST.

*                            explanations about records
*                            generated by the collecting daemon itself.
DATA: BEGIN OF OWNCLOCK_REST,
        TIMEDIFF(16),
        FILLER02(1) VALUE ' ',
        TEXT(99),
      END   OF OWNCLOCK_REST.

*                            explanations about records
*                            generated by the collecting daemon itself.
DATA: BEGIN OF OWNINFO_REST,
        INFOTYPE(5),
        FILLER02(1) VALUE ' ',
        TIMEDIFF(12),
        FILLER03(1) VALUE ' ',
        SENDERSTATE(8),
        FILLER04(1) VALUE ' ',
        LASTRECIVE(16),
        FILLER05(1) VALUE ' ',
        LASTSEND(16),
        FILLER07(55),
      END   OF OWNINFO_REST.

*                              explanations about records
*                              generated by the collecting daemon
*                              itself.
DATA: BEGIN OF OWNUPDOWN_REST,
        TEXT(116),
      END   OF OWNUPDOWN_REST.




* data: begin of pathname,
*         dir(60),
*         slash(1),
*         file(14),
*       end   of pathname,
*       a_slash(1) value '/'.

DATA: BEGIN OF ABAP_INFO OCCURS 10,
        " key :
        slgltrm LIKE RSLGTYPE-TERMINAL," name of terminal
        slgmode LIKE RSLGTYPE-SAPMODE. " "Arbeitsmodus", "Kamera",
" data :
        INCLUDE STRUCTURE RSLGABDATA.
DATA:   first_AREA    LIKE TSL1D-AREA
    ,   first_SUBID   LIKE TSL1D-SUBID
    , END   OF ABAP_INFO.

DATA: ERRORNAME(16)  "LIKE TSLE2-ERRORNAME
    , ERRORTEXT(78)  "LIKE TSLE2-ERRORTEXT
    .

* Tabellen und Variablen-Definitionen
* zum Verwalten einer internen Tabelle als Cach-Speicher
* TABLES: TSL1T, TSL1D, TSL2T, TADIR, TDEVC.

* * For form FILL_INTERN_TAB;
*

DATA: BEGIN OF CUR_SYSLOGTAB.          " struct, not table ! !
        INCLUDE STRUCTURE RSLGTCACHE.
DATA: END OF CUR_SYSLOGTAB
    , CUR_SYSLOGTAB_FILLED VALUE ' '
    .

DATA: BEGIN OF CLASSTAB  OCCURS 10. " Zwischenspeicher für
        INCLUDE STRUCTURE TSL2T.    " Problemklassennamen
DATA: END OF CLASSTAB.

DATA: OBJECT LIKE DOKHL-OBJECT, IDENTITY LIKE DOKHL-ID.
DATA: BEGIN OF LINE OCCURS 50.        " Anzeigetabelle für
        INCLUDE STRUCTURE TLINE.      " Doku-Baustein
DATA: END OF LINE.

DATA: HEADER_LINE(132)
    , HEADER_LEN1 TYPE I
    , HEADER_LEN2 TYPE I
    , LINES_ON_PAGE TYPE I
    .

* Data for [F2]-handling:
*
DATA: INFO_ENTRIESTAB_IX LIKE SY-TABIX
    , INFO_CURSOR_MOVED                 VALUE ' '
    , INFO_IND TYPE I
    , INFO_PAG TYPE I
    , INFO_LNO TYPE I
    .

DATA: LIST_OR_DYNPRO(5) VALUE 'D0200'  " +0(1) : 'L', 'D'
    "                                  " +1(4) : Dynpro number
    "                                  " +1(4) : PFSTATUS of List
    , LIST_TOP(2)                      " for top-of-page
    .


* This report never updates the database.
* But, as the ABAP/4 processor kills every program, which runs
* for a long time and does no COMMIT WORKs, I will have to do
* some once and again.
*
DATA: COMMIT_CNT TYPE I.


* For progress indicator:
DATA: PERCENTAGE_DONE TYPE I VALUE 0
    .
TYPE-POOLS: SLIS , ICON.
INCLUDE <COLOR>.
*INCLUDE <ICON>.

* Constants for ALV Purpose
CONSTANTS : GC_ENDOFLIST TYPE SLIS_ALV_EVENT-FORM VALUE
                                   'END_OF_LIST',
            GC_FORMNAME_TOP_OF_PAGE  TYPE  SLIS_FORMNAME VALUE
                                   'TOP_OF_PAGE',
            GC_TOP_OF_PAGE  TYPE  SLIS_FORMNAME VALUE
                                   'TOP_OF_OUTLINE'.
* Declarations for icons
CONSTANTS
      : gc_grn_lght    LIKE icon-id VALUE '@5B@',
        gc_red_lght    LIKE icon-id VALUE '@5C@',
        gc_yellow_lght LIKE icon-id VALUE '@5D@',
        gc_dummy_lght  LIKE icon-id VALUE '@EB@'.

                                   .

DATA: GV_REPID LIKE SY-REPID.                  "ALV Report Id
DATA: GV_DATE  TYPE D.

DATA: GT_FIELDCAT  TYPE SLIS_T_FIELDCAT_ALV,   "ALV Field Catalog Table
      GT_FIELDCAT1 TYPE SLIS_T_FIELDCAT_ALV,   "ALV Field Catalog Table
      GS_FIELDCAT  TYPE SLIS_FIELDCAT_ALV,     "ALV Field Catalog Table
      GS_LAYOUT    TYPE SLIS_LAYOUT_ALV,       "ALV Layout Structure
      GT_SORT      TYPE SLIS_T_SORTINFO_ALV,
      GT_EVENTS    TYPE SLIS_T_EVENT,          "ALV Event Table
      GT_PRINT     TYPE SLIS_PRINT_ALV,        "ALV generic list type
      GT_COLOR     TYPE LVC_T_SCOL,
      GS_COLOR     TYPE LVC_S_SCOL.
* SOLO
DATA: UNICODE_SYS           TYPE I VALUE 0.
DATA: INT_FROM_PAGE         LIKE  TCP00-CPCODEPAGE.
DATA: INT_TO_PAGE           LIKE  TCP00-CPCODEPAGE.
DATA: CONV_PAGE_REQU        TYPE I VALUE 0.
DATA: LV_H_IND   TYPE I.
DATA: SLASH_SIGN(1)         TYPE C VALUE '/'.
DATA: GV_HIGH_LIST_COUNTER  TYPE I VALUE 0.
DATA: GV_H_LIST_COUNTER     TYPE I VALUE 0.
DATA: GV_DEFAULT_LINESIZE   LIKE SY-LINSZ VALUE 255.
DATA: GV_SLGFTYP LIKE RSLGETAB-SLGFTYP.
DATA: GV_LIST_COUNTER TYPE I.
DATA: GV_LIST_COUNTER1 TYPE I.
DATA: GC_X TYPE C VALUE 'X'.
DATA: GV_TABINDEX LIKE SY-INDEX.
DATA: SOFI_COUNT            TYPE I VALUE 0,
      SOTI_COUNT            TYPE I VALUE 0,
      SOPC_COUNT            TYPE I VALUE 5,
      SOCP_COUNT            TYPE I VALUE 5,
      SOTA_COUNT            TYPE I VALUE 5,
      SODC_COUNT            TYPE I VALUE 5,
      SOID_COUNT            TYPE I VALUE 5,
      SOTY_COUNT            TYPE I VALUE 5.
DATA: SORT_TO_PC            TYPE I VALUE 0.
DATA: ZERO                  TYPE I VALUE 0.


* output on terminal activ
DATA: GV_OUTPUT_TERM(1)          TYPE C  VALUE 'X'.
DATA: GV_INTERNAL_DATE(10)       TYPE C  VALUE SPACE.
DATA: GV_INTERNAL_NUMBER         TYPE I  VALUE 1.
DATA: GV_INDEX                   TYPE I  VALUE 0.
DATA: GV_IND                     TYPE I  VALUE 0.
DATA: GV_IND1                    TYPE I  VALUE 0.
DATA: GV_IND2                    TYPE I  VALUE 0.
DATA: SAVE_GS_OUTLINE_DATE(10)   TYPE C  VALUE ' '.
DATA: SAVE_GS_OUTLINE_INSTID(20) TYPE C  VALUE ' '.
DATA: SAVE_GS_OUTLINE_TIME(10)   TYPE C  VALUE ' '.

DATA: GV_LINE LIKE KERNELSTAT-LINE,
      GV_PAGE LIKE SY-PAGNO.

* ALL THESE TABLES ARE RELATED TO FIRST LIST
DATA: GV_F4 TYPE C .

DATA: GT_AUTH TYPE STANDARD TABLE OF IBD_RSTS001003_ALV,
      GS_AUTH TYPE IBD_RSTS001003_ALV.

data: GR_PERMISSIONS type ref to cl_salv_table.

DATA: GT_CLOCK TYPE STANDARD TABLE OF KERNELSTAT,
      GS_CLOCK TYPE KERNELSTAT.

data: GR_CLOCK type ref to cl_salv_table.

DATA: GT_AUTH_TOP TYPE STANDARD TABLE OF KERNELSTAT,
      GS_AUTH_TOP TYPE KERNELSTAT.

constants: gc_true  type sap_bool value 'X'.

data: gr_content type ref to cl_salv_form_element.

* reference to a functions object
data: gr_functions type ref to cl_salv_functions_list.

TYPES: BEGIN OF GTYPE_OUTLINE.
        INCLUDE STRUCTURE IBD_SAPMSM2101_ALV.
TYPES:    COLOR  TYPE  LVC_T_SCOL,
*          ICON   TYPE  CHAR25,
       END OF GTYPE_OUTLINE.

DATA: GT_GEN_OUTLINE TYPE STANDARD TABLE OF GTYPE_OUTLINE.
DATA: GS_GEN_OUTLINE TYPE GTYPE_OUTLINE.

TYPES: BEGIN OF YT_TOP.
          INCLUDE STRUCTURE KERNELSTAT.
TYPES:    COLOR  TYPE  LVC_T_SCOL,
       END OF YT_TOP.

DATA: GT_TOP TYPE STANDARD TABLE OF YT_TOP,
      GT_TEMP TYPE STANDARD TABLE OF KERNELSTAT,
      GS_TEMP TYPE KERNELSTAT,
      GS_TOP TYPE YT_TOP,
      GT_END TYPE STANDARD TABLE OF KERNELSTAT,
      GS_END TYPE KERNELSTAT.

DATA: GT_COMMON TYPE STANDARD TABLE OF IBD_SAPMSM2102_ALV,
      GS_COMMON TYPE IBD_SAPMSM2102_ALV.

DATA: GT_INST TYPE STANDARD TABLE OF IBD_SAPMSM2102_ALV,
      GS_INST TYPE IBD_SAPMSM2102_ALV.

DATA: GT_MAND TYPE STANDARD TABLE OF IBD_SAPMSM2102_ALV,
      GS_MAND TYPE IBD_SAPMSM2102_ALV.

DATA: GT_REPO TYPE STANDARD TABLE OF IBD_SAPMSM2102_ALV,
      GS_REPO TYPE IBD_SAPMSM2102_ALV.

DATA: GT_TCOD TYPE STANDARD TABLE OF IBD_SAPMSM2102_ALV,
      GS_TCOD TYPE IBD_SAPMSM2102_ALV.

DATA: GT_BENU TYPE STANDARD TABLE OF IBD_SAPMSM2102_ALV,
      GS_BENU TYPE IBD_SAPMSM2102_ALV.

DATA: GT_RSLGTCACHE TYPE STANDARD TABLE OF RSLGTCACHE,
      GS_RSLGTCACHE TYPE RSLGTCACHE.

DATA: GT_MSG TYPE STANDARD TABLE OF IBD_SAPMSM2102_ALV,
      GS_MSG TYPE IBD_SAPMSM2102_ALV.

DATA: GT_SNAP TYPE STANDARD TABLE OF IBD_SAPMSM2102_ALV.
DATA: GS_SNAP TYPE IBD_SAPMSM2102_ALV.

DATA: GT_CONTENTS TYPE STANDARD TABLE OF IBD_SAPMSM2103_ALV,
      GT_CONTENTS1 TYPE STANDARD TABLE OF IBD_SAPMSM2103_ALV,
      GS_CONTENTS TYPE IBD_SAPMSM2103_ALV.

* ALL THESE DECLRATIONS RELATED TO DETAIL LIST.

DATA: GT_GEN_OUTLINE1 TYPE STANDARD TABLE OF IBD_SAPMSM2101_ALV,
      GS_GEN_OUTLINE1 TYPE IBD_SAPMSM2101_ALV.

DATA: GT_DETAILS TYPE STANDARD TABLE OF IBD_SAPMSM2104_ALV.

TYPES: BEGIN OF GTYPE_HIDE_BUFFER
    ,   ENTRIESTAB_IX LIKE SY-TABIX    " after last sorting.
    ,   slgproc LIKE rslgpid           " identification of process
    ,   slgltrm LIKE RSLGTYPE-TERMINAL " name of terminal
    ,   slguser LIKE RSLGTYPE-USER     " user name
    ,   slgtc   LIKE RSLGTYPE-TCODE    " SAP transaction code
    ,   slgrepna LIKE RSLGTYPE-REPNA   " SAP report name
    ,   SLGMAND(3) TYPE C              " Mandant (client)
    ,   slgmode LIKE RSLGTYPE-SAPMODE  " "Arbeitsmodus"
    ,   slgdata LIKE RSLGENTR-SLGDATA
    ,   slgdattim LIKE RSLGTYPE-TIME   " date and time from local clock
    ,   native_s_id(47) TYPE C      " - HIDE_C_BUFFER
    ,   HIDE_TEXT    TYPE MSGTEXT_T        " Long.
    ,   HIDE_TEXT_LG TYPE I
    ,   MODULNAME LIKE RSLGABDATA-MODULNAME
    ,   LOCATION  LIKE RSLGABDATA-LOCATION
    ,   PROGRAM   LIKE RSLGABDATA-PROGRAM
    ,   GEN_OR_RUN LIKE RSLGABDATA-GEN_OR_RUN
    ,   PARAMETERS LIKE RSLGABDATA-PARAMETERS
    ,   first_AREA     LIKE TSL1D-AREA
    ,   first_SUBID    LIKE TSL1D-SUBID
    ,   HIDE_PARAMS      LIKE RSLGTYPE-PARAMARRAY           " C(620)
    ,   HIDE_AREA        LIKE TSL1D-AREA
    ,   HIDE_SUBID       LIKE TSL1D-SUBID
    ,   HIDE_LINE_TYPE LIKE PAGE_TYPE
    ,  END OF GTYPE_HIDE_BUFFER.

DATA: GT_HIDE_BUFFER TYPE STANDARD TABLE OF GTYPE_HIDE_BUFFER,
      GS_HIDE_BUFFER TYPE GTYPE_HIDE_BUFFER.

DATA: GS_DETAILS TYPE IBD_SAPMSM2104_ALV.

DATA: GT_DETAIL_TOP TYPE STANDARD TABLE OF KERNELSTAT,
      GS_DETAIL_TOP TYPE KERNELSTAT.

DATA: GT_TECHNICAL TYPE STANDARD TABLE OF IBD_SAPMSM2105_ALV.

DATA: GS_TECHNICAL TYPE IBD_SAPMSM2105_ALV.

DATA: GT_PARAM TYPE STANDARD TABLE OF KERNELSTAT,
      GT_PARAM_TOP TYPE STANDARD TABLE OF KERNELSTAT,
      GS_PARAM_TOP TYPE KERNELSTAT.

DATA: GT_TECH_TOP TYPE STANDARD TABLE OF KERNELSTAT,
      GS_TECH_TOP TYPE KERNELSTAT.

DATA: GT_CF TYPE STANDARD TABLE OF RSLGCFDATA,
      GS_CF TYPE RSLGCFDATA.

DATA: GT_UP TYPE STANDARD TABLE OF RSLGUPDATA,
      GS_UP TYPE RSLGUPDATA.

DATA: GT_DO TYPE STANDARD TABLE OF RSLGDODATA,
      GS_DO TYPE RSLGDODATA.

DATA: GT_PR TYPE STANDARD TABLE OF RSLGPRDATA,
      GS_PR TYPE RSLGPRDATA.

DATA: GT_EP TYPE STANDARD TABLE OF RSLGEPDATA,
      GS_EP TYPE RSLGEPDATA.

DATA: GT_EL TYPE STANDARD TABLE OF RSLGELDATA,
      GS_EL TYPE RSLGELDATA.

DATA: GT_ED TYPE STANDARD TABLE OF RSLGEDDATA,
      GS_ED TYPE RSLGEDDATA.

DATA: GT_ER TYPE STANDARD TABLE OF RSLGERDATA,
      GS_ER TYPE RSLGERDATA.

DATA: GT_EX TYPE STANDARD TABLE OF RSLGEXDATA,
      GS_EX TYPE RSLGEXDATA.

DATA: GT_SQL TYPE STANDARD TABLE OF RSLGSQLDAT,
      GS_SQL TYPE RSLGSQLDAT.

DATA: GT_DBI TYPE STANDARD TABLE OF RSLGDBIDAT,
      GS_DBI TYPE RSLGDBIDAT.

DATA: GT_DD TYPE STANDARD TABLE OF RSLGDDDATA,
      GS_DD TYPE RSLGDDDATA.

DATA: GT_AB TYPE STANDARD TABLE OF RSLGABDATA,
      GS_AB TYPE RSLGABDATA.

DATA: GT_AX TYPE STANDARD TABLE OF RSLGAXDATA,
      GS_AX TYPE RSLGAXDATA.

DATA: GT_AD TYPE STANDARD TABLE OF RSLGADDATA,
      GS_AD TYPE RSLGADDATA.

DATA: GT_IB TYPE STANDARD TABLE OF RSLGIBDATA,
      GS_IB TYPE RSLGIBDATA.

TYPES: BEGIN OF GTYPE_DOC.
        INCLUDE STRUCTURE KERNELSTAT.
TYPES:    COLOR TYPE  LVC_T_SCOL,
       END OF GTYPE_DOC.

DATA: GT_DOC   TYPE STANDARD TABLE OF GTYPE_DOC,
      GS_DOC   TYPE GTYPE_DOC.

DATA: GT_D_TOP TYPE STANDARD TABLE OF KERNELSTAT,
      GS_D_TOP TYPE KERNELSTAT.

DATA: GT_D_END TYPE KERNELSTAT OCCURS 0,
      GS_D_END TYPE KERNELSTAT.

* ABAP/4 SNAP processing:
* -----------------------
*
INCLUDE MSM21F35.

**** end of report fraction: DATAs.
*EJECT
**** begin of the dialog--report switching fraction.

FORM DYNPRO_TO_LIST_ALV USING A_PF_STATUS.
  IF A_PF_STATUS = SPACE.
    SET PF-STATUS 'LIST'.          "#EC * )
    LIST_OR_DYNPRO = 'LLIST'.
  ELSE.
    SET PF-STATUS A_PF_STATUS.
    LIST_OR_DYNPRO(1) = 'L'.
    LIST_OR_DYNPRO+1  =   A_PF_STATUS.
  ENDIF.
*  LEAVE TO LIST-PROCESSING.
*
*  SET BLANK LINES ON.
  LIST_TOP = '  '. " unknown.

* NEW-PAGE NO-TITLE.
ENDFORM.                    "DYNPRO_TO_LIST_ALV


FORM START_OVERWRITE_MAIN_LIST.
  " Nothing to do now.
ENDFORM. " START_OVERWRITE_MAIN_LIST.

*&--------------------------------------------------------------------*
*&      Form  FINISH_OVERWRITE_MAIN_LIST
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM FINISH_OVERWRITE_MAIN_LIST.
  " I cannot explain, but ABAP/4 works best,
  " when list-index is modified after writing
  " the list.
  SUBTRACT 1 FROM SY-LSIND.
ENDFORM. " FINISH_OVERWRITE_MAIN_LIST.

**** end of dialog--report switching fraction.
*EJECT
**** begin of the dialog fraction: MODULEs and their FORMs.

FORM INIT_MODULE_POOL.

*   All the rest allowed to this user?
  AUTHORITY-CHECK OBJECT 'S_ADMI_FCD'
                  ID     'S_ADMI_FCD'
                  FIELD  'SM21'.
  IF SY-SUBRC = 0.
    MAY_WORK = 'X'.
  ELSE.
*     Keine Berechtigung zur SysLog-Analyse.
    PERFORM SHOW_PERMISSIONS.
    PERFORM LOCK_FUNCTION USING 'DOIT'.
    PERFORM LOCK_FUNCTION USING 'LOSL'.
    PERFORM LOCK_FUNCTION USING 'RESL'.
    PERFORM LOCK_FUNCTION USING 'ARSL'.
    PERFORM LOCK_FUNCTION USING 'CESL'.
    PERFORM LOCK_FUNCTION USING 'TEXP'.
    PERFORM LOCK_FUNCTION USING 'LAYO'.
    PERFORM LOCK_FUNCTION USING 'SMSG'.
    PERFORM LOCK_FUNCTION USING 'SPAR'.
    SUPPRESS DIALOG.
    SET SCREEN 0.
    LEAVE.
*     STOP.
  ENDIF.

*   Preset fields of Dynpro 0200
  IF SY-UZEIT >= 3600.
    DY_START_DATE    = SY-DATUM.
    DY_START_TIME    = SY-UZEIT - 3600.
  ELSE. " between 00:00:00 and 00:59:59
    DY_START_DATE    = SY-DATUM - 1.
    DY_START_TIME    = '230000'.
  ENDIF.
  DY_START_TIME+2(4) = '0000'.
  DY_END_DATE      = '        '.         " no longer SY-DATUM.
  DY_END_TIME      = '      '.           " no longer '235959'.
  RSLGTYPE-TASK    = '  '.
  RSLGTYPE-USER    = '            '.
  RSLGTYPE-TCODE   = '    '.
  RSLGTYPE-REPNA   = '        '.
  RSLGLAYOUT-MAXPAG  = 150.
  DY_STATISTICS(1) = ' '.
  DY_TASK_SEL_TYP  = '   '.
  DY_TASK_SEL_NUM  = '   '.

  PERFORM SET_RADIO3 USING 3 RSLGTYPE-PRONLY
                             RSLGTYPE-PROWAR RSLGTYPE-ALLMSG.

*   Preset fields of Dynpro 2020
  DY_START_FILE    = SPACE.
  DY_START_POS     = SPACE.
  DY_STOP_FILE     = SPACE.
  DY_STOP_POS      = SPACE.
  DY_TYPE          = ' '.
  RSLGTYPE-TERMINAL = '        '.
  DY_DEVCLASS      = '    '.
  " RSLGTYPE-TASK
  DY_CLASID1       = ' '.
  DY_CLASID2       = ' '.
  DY_CLASID3       = ' '.
  DY_CLASID4       = ' '.
  DY_CLASID5       = ' '.
  DY_CLASID6       = ' '.
  TSL3T-SLTYPE     = SPACE.
  DY_TYPE          = TSL3T-SLTYPE.
  TSL3T-TXT        = SPACE.
  TADIR-DEVCLASS   = SPACE.
  DY_DEVCLASS      = TADIR-DEVCLASS.
  DY_INTERNRECS    = ' '.

*   Preset fields of Dynpro 2030
  REFRESH IGNORE_IDS.
  RSLGSEL-MSGINC   = ' '.
  MSGINC_OFF       = 'X'.    " as opposite field for radio box
  IGNORE_IDS_INC   = RSLGSEL-MSGINC.
  IGNORE_IDS_CNT   = 0.
  IGNORE_IDS_LST   = SPACE.

  ENTER_MODULPOOL_1ST_TIME    = ' '.


*   Finde den Namen des eigenen Rechners.
  CALL 'C_SAPGPARAM' ID 'NAME'  FIELD 'SAPLOCALHOST'
                     ID 'VALUE' FIELD I_AM_HOST
                     .
  IF I_AM_HOST = ' '.
     CALL 'C_GET_CPU_ID' ID 'CPUID' FIELD I_AM_HOST.
  ENDIF.

*   Finde den Namen des Rechners, auf dem 'rslgcoll' laufen soll.
  CALL 'C_SAPGPARAM' ID 'NAME' FIELD 'rslg/collect_daemon/host'
                     ID 'VALUE' FIELD COLLECT_HOST
                     .

*   List, which functions shall be available to experts only.
  REFRESH EXPERT_FUNCTIONS.
  EXPERT_FUNCTIONS-FUNC       = 'TNEX'. " --> nomal mode
  APPEND EXPERT_FUNCTIONS.
  EXPERT_FUNCTIONS-FUNC       = 'IGNO'. " Ignoriere Meldung
  APPEND EXPERT_FUNCTIONS.
  EXPERT_FUNCTIONS-FUNC       = 'EXPL'. " Uebernehme Selektion
  APPEND EXPERT_FUNCTIONS.
  EXPERT_FUNCTIONS-FUNC       = 'GTPO'. " aktuelle Position
  APPEND EXPERT_FUNCTIONS.
  EXPERT_FUNCTIONS-FUNC       = 'MOSE'. " weitere Eingrenzungen
  APPEND EXPERT_FUNCTIONS.
  EXPERT_FUNCTIONS-FUNC       = 'MOS2'. " weitere Eingrenzungen
  APPEND EXPERT_FUNCTIONS.
  EXPERT_FUNCTIONS-FUNC       = 'SODC'. " Sort.Entw.Klasse
  APPEND EXPERT_FUNCTIONS.
  EXPERT_FUNCTIONS-FUNC       = 'SOID'. " Sort.Meld.kennung
  APPEND EXPERT_FUNCTIONS.
  EXPERT_FUNCTIONS-FUNC       = 'SOTY'. " Sort.Meld.typ
  APPEND EXPERT_FUNCTIONS.
  EXPERT_FUNCTIONS-FUNC       = 'DOC2'. " 2nd Doku (never)
  APPEND EXPERT_FUNCTIONS.
*   and non-experts only.
  REFRESH NORMALONLY_FUNCTIONS.
  NORMALONLY_FUNCTIONS-FUNC   = 'TEXP'. " --> expert mode
  APPEND NORMALONLY_FUNCTIONS.
  NORMALONLY_FUNCTIONS-FUNC   = 'DOC2'. " 2nd Doku (never)
  APPEND NORMALONLY_FUNCTIONS.

  PROBLEM_INDICATOR = '?'.
  CALL 'C_GET_SYSLOG_POS' ID 'PROB' FIELD PROBLEM_INDICATOR.
  IF PROBLEM_INDICATOR = ' ' OR PROBLEM_INDICATOR = '?'.
    " fine.
  ELSE.
    " Achtung: Dieser Workprozess kann kein SysLog schreiben
    MESSAGE S168.
  ENDIF.

  IF COLLECT_HOST = NO_HOST.
    " Do not mention it.
    LOCKED_FUNCTIONS-FUNC = 'CESL'.
    APPEND LOCKED_FUNCTIONS.

  ELSE.
* Try to look into central SysLog file
    CALL 'C_SAPGPARAM' ID 'NAME' FIELD 'rslg/central/file'
                       ID 'VALUE' FIELD ACTFILENAME.
    CALL 'C_RSTRB_READ_BUFFERED'
                  ID 'BUFF' FIELD A_DUMMY_C_ENTRY
                  ID 'NAME' FIELD ACTFILENAME
                  ID 'SIZE' FIELD RECORD_C_SIZE
                  ID 'POSI' FIELD   0
                  .
    IF SY-SUBRC = 0.
      " fine. Dont need warning.
      CENTRAL_FILE_MISSING = ' '.
*       Unicode information
      if cl_abap_char_utilities=>charsize = 1.
         UNICODE_SYS  = 0.
      else.
        UNICODE_SYS   = 1.   " UNICODE = YES
*   get the own code-page
        call function 'SYSTEM_CODEPAGE'
           importing
            CURRENT_DYNAMIC_CODEPAGE = INT_FROM_PAGE.
        if INT_FROM_PAGE = 4102.
           move 4102   to INT_TO_PAGE.
           move 4103   to INT_FROM_PAGE.
        else.
           move 4102   to INT_FROM_PAGE.
           move 4103   to INT_TO_PAGE.
       endif.

*      check for unicode system and set flag for convertion
       if A_DUMMY_C_ENTRY+1(5) = 'selff'.
           CONV_PAGE_REQU       = 0.
         else.
           CONV_PAGE_REQU       = 1.  " convertion codepage is required
         endif.
      endif.
   ELSE.
      CENTRAL_FILE_MISSING = 'X'.
      LOCKED_FUNCTIONS-FUNC = 'CESL'.
      APPEND LOCKED_FUNCTIONS.
    ENDIF.
    " Close that file again.
    CALL 'C_RSTRB_READ_BUFFERED'
                  ID 'BUFF' FIELD A_DUMMY_C_ENTRY " Dummy
                  ID 'CLOS' FIELD 'X'
                  .
  ENDIF.

  IF SY-SCOLS > 0 AND SY-SCOLS <= 80.
    NARROW_WINDOW_WARN = 'X'.
  ELSE.
    NARROW_WINDOW_WARN = '.'.
  ENDIF.
  CALL FUNCTION 'RSLG_LAYOUT_INIT_ALV'.
  CALL FUNCTION 'RSLG_LAYOUT_ST_DEFAULT_ALV'.
  CALL FUNCTION 'RSLG_SEL_INIT_ALV'.
* Is my operating system stored in TSLE4 ?
  CALL FUNCTION 'RSLG_STORE_OPSYS'
    IMPORTING
      TSLE4_WRITTEN = TSLE4_WRITTEN.

ENDFORM. " INIT_MODULE_POOL.

*EJECT
*                          Dynpro 0200
*----------------------------------------------------------------------+
* Zeitliche Eingrenzung ---------------------------------------------- !
* von Datum / Uhrzeit..................... ---------- / --:--:--       !
* bis Datum / Uhrzeit..................... ---------- / --:--:--       !
*                                                                      !
* Andere Eingrenzungen ----------------------------------------------- !
* Benutzer................................ ____________                !
* Transaktionscode........................ ____                        !
* SAP-Prozess............................. __                          !
* Problemklassen.......................... _ nur Probleme              !
*                                          _ Probleme und Warnungen    !
*                                          _ alle Arten von Meldungen  !
* weitere Eingrenzungen                    ___________________________ !
*                                                                      !
* Aufbereitung ------------------------------------------------------- !
* Anz. Seiten f. Einzeleintraege.......... ___                         !
* mit statistisher Auswertung............. _                           !
* Ausgabe auf............................. _____________               !
*                                                                      !
*----------------------------------------------------------------------+

MODULE INIT_200 OUTPUT.
*------========--------
* Initialisierung des Dynpros 200.
*

  IF ENTER_MODULPOOL_1ST_TIME = 'X'.
    PERFORM INIT_MODULE_POOL.

    CALL FUNCTION 'RSLG_SEL_ST_WHICHLOG_ALV'
      EXPORTING
        FILE = REP_ON_LOCAL.
  ENDIF.

  IF CENTRAL_FILE_MISSING = 'X'.
*       Achtung: zentraler SysLog kann nicht gelesen werden:
*       ....
*                (nicht aktiviert oder Datei nicht von hier erreichbar?)
*    MESSAGE I169 WITH ACTFILENAME.
    IF SURPRESS_POPUPS = ' '.
      CALL FUNCTION 'POPUP_WITH_WARNING'
        EXPORTING
        TEXTLINE1 = 'zentraler SysLog kann nicht gelesen werden'(644)
        TEXTLINE2 = ACTFILENAME
        .
    ELSE.
      FORMAT COLOR COL_NEGATIVE.
      WRITE: /1(60) SY-ULINE
           , /1     SY-VLINE
           ,        'zentraler SysLog kann nicht gelesen werden'(644)
           , 60     SY-VLINE
           , /1     SY-VLINE
           ,        ACTFILENAME
           , 60     SY-VLINE
           , /1(60) SY-ULINE .
      FORMAT COLOR COL_NORMAL.
    ENDIF.
    CENTRAL_FILE_MISSING = '.'.
  ENDIF.

  IF NARROW_WINDOW_WARN = 'X'.
    "Zur Anzeige empfiehlt sich ein Fenster breiter als &
*   MESSAGE I167 WITH SY-SCOLS.
    IF SURPRESS_POPUPS = ' '.
      CALL FUNCTION 'POPUP_WITH_WARNING'
        EXPORTING
       TEXTLINE1 = 'Zur Anzeige empfiehlt sich ein breites Fenster'(642)
        .
      NARROW_WINDOW_WARN = '.'.
    ENDIF.
  ENDIF.

  IF TSLE4_WRITTEN = 'X'.
    IF SURPRESS_POPUPS = ' '.
      CALL FUNCTION 'POPUP_WITH_WARNING'
        EXPORTING
          TEXTLINE1 = 'Diese Instanz wurde in TSLE4 eingetragen.'(650).
    ELSE.
      FORMAT COLOR COL_TOTAL.
      WRITE: /1(60) SY-ULINE
           , /1     SY-VLINE
           ,        'Diese Instanz wurde in TSLE4 eingetragen.'(650)
           , 60     SY-VLINE
           , /1(60) SY-ULINE .
      FORMAT COLOR COL_NORMAL.
    ENDIF.
    TSLE4_WRITTEN = '.'.
  ENDIF.

  PERFORM ACTIVATE_EXPERT_FIELDS_N_FUNCS.

  DESCRIBE TABLE ENTRIESTAB LINES RSLGTYPE-ENTREAD.
  IF RSLGTYPE-ENTREAD < 1.
    DISABLED_FUNCTIONS-FUNC = 'DOAG'.
    APPEND DISABLED_FUNCTIONS.
    DISABLED_FUNCTIONS-FUNC = 'DOAP'.
    APPEND DISABLED_FUNCTIONS.
  ENDIF.

  IF MAY_WORK = 'X'.
    SET PF-STATUS '0200' EXCLUDING DISABLED_FUNCTIONS.
  ELSE.
    SET PF-STATUS 'BACK' EXCLUDING DISABLED_FUNCTIONS.
  ENDIF.
  CLEAR: FCODE.

  CALL FUNCTION 'RSLG_SEL_GET_WHICHLOG_ALV'
    IMPORTING
      FILE = TA___WHICHLOG.
  IF TA___WHICHLOG = REP_ON_LOCAL.
    SET TITLEBAR '202' WITH I_AM_HOST.
    LOOP AT SCREEN.
      IF SCREEN-GROUP1 = 'XXX'.
        SCREEN-ACTIVE    = '0'.
        MODIFY SCREEN.
      ENDIF.
    ENDLOOP.
  ELSEIF TA___WHICHLOG = REP_ON_REMOTEL.
    IF DY_RFCDEST IS INITIAL.                               "09.12.1998
      DY_RFCDEST = DY_INST.
    ENDIF.
    SET TITLEBAR '203' WITH DY_RFCDEST.
    "But DY_RFCDEST is perhaps empty.
  ELSEIF TA___WHICHLOG = REP_ON_REMOTEA.
    SET TITLEBAR '204'.
    LOOP AT SCREEN.
      IF SCREEN-GROUP1 = 'XXX'.
        SCREEN-ACTIVE    = '0'.
        MODIFY SCREEN.
      ENDIF.
    ENDLOOP.
  ELSE.
    SET TITLEBAR '201'.
  ENDIF.

  IF RSLGTYPE-TCODE >< SPACE.
    IF RSLGTYPE-TCODE CA '*+'.
      TSTCT-TTEXT = '<generisch>'(570).
    ELSE.
      SELECT SINGLE * FROM TSTCT WHERE SPRSL = SY-LANGU
                                 AND   TCODE = RSLGTYPE-TCODE.
      IF SY-SUBRC >< 0.
        TSTCT-TTEXT = '<unbekannt>'(571).
      ENDIF.
    ENDIF.
  ELSE.
    CLEAR TSTCT-TTEXT.
  ENDIF.
  AUX_SLGPROC-TASKTNO = '     '. NO_TASKTNO = 'X'.
  PERFORM EXPLAIN_NEW_TASK_TYPE USING DY_TASK_SEL_TYP DY_TASK_EXPLAIN.



  PERFORM TEXT_ABOUT_MORE_SELS USING DY_OUT_MORE_SELS.
  CALL FUNCTION 'RSLG_LAYOUT_GET_PRINT_ALV'
    IMPORTING
      TO_PRINTER = DY_PRINT
      LAYOUT     = DY_OUT_DEST.
  SET CURSOR FIELD 'DY_START_TIME'.

ENDMODULE. " INIT_200 OUTPUT


*EJECT
MODULE CHECK_FCODE_FOR_EXIT.

  IF FCODE = 'BACK'  OR
     FCODE = '%EX'   OR
     FCODE = 'RW'.
    SET SCREEN 0.
    LEAVE SCREEN.
  ENDIF.

ENDMODULE.      " RETURN ODER ABBRUCH OR EXIT

*EJECT
MODULE CHECK_DATE_RANGE INPUT.
  IF  DY_START_DATE >< '        ' AND DY_START_DATE >< '00000000'
  AND DY_START_TIME >< '      '   AND DY_START_TIME >< '000000'
  AND DY_END_DATE   >< '        ' AND DY_END_DATE   >< '00000000'
  AND DY_END_TIME   >< '      '   AND DY_END_TIME   >< '000000'
  .
    "All four fields given.
    IF DY_START_DATE > DY_END_DATE.
      MESSAGE E170.
    ELSEIF DY_START_DATE = DY_END_DATE
    AND    DY_START_TIME > DY_END_TIME.
      MESSAGE E170.
    ENDIF.
  ELSEIF  DY_START_DATE >< '        ' AND DY_START_DATE >< '00000000'
  AND     DY_END_DATE   >< '        ' AND DY_END_DATE   >< '00000000'
  .
    "Two date fields given.
    IF DY_START_DATE > DY_END_DATE.
      MESSAGE E170.
    ENDIF.
  ENDIF.
ENDMODULE. "CHECK_DATE_RANGE

*EJECT
MODULE SHOW_USER OUTPUT.
  DATA: SU_CNT     TYPE I VALUE 0
      , SU_FIRST   LIKE USR03-NAME1 VALUE '<missing>'
      , SU_NONUNIQ        VALUE ' '
      , SU_NONAME         VALUE 'X'
      .

  IF RSLGTYPE-USER >< SPACE.
    IF RSLGTYPE-USER CA '*'.
      USR03-NAME1 = '<generisch>'(570).
    ELSE.
      SELECT * FROM USR01 CLIENT SPECIFIED
                          WHERE BNAME = RSLGTYPE-USER.
        ADD 1 TO SU_CNT.
*       SELECT SINGLE * FROM usr03 CLIENT SPECIFIED
*                                  WHERE bname = usr01-bname
*                                  AND   mandt = usr01-mandt.
        CALL FUNCTION 'SUSR_SHOW_USER_DETAILS'
             EXPORTING BNAME = USR01-BNAME
                       MANDT = USR01-MANDT
                       NO_DISPLAY = 'X'
*            importing okcode =
             CHANGING USER_USR03 = USR03.
        IF SY-SUBRC = 0.         "#EC *
          IF SU_NONAME = 'X'.
            SU_FIRST = USR03-NAME1.
            SU_NONAME = ' '.
          ELSEIF SU_FIRST = USR03-NAME1.
            " fine: same user in multiple clients.
          ELSE.
            SU_NONUNIQ = 'X'.
          ENDIF.
        ENDIF.
      ENDSELECT.
      IF SU_CNT < 1.
        USR03-NAME1 = '<unbekannt>'(571).
      ELSEIF SU_NONUNIQ = 'X'.
        USR03-NAME1 = '<unterschiedlich in Mandanten>'(572).
      ELSEIF SU_NONAME = 'X'.
        USR03-NAME1 = '<Name nicht gepflegt>'(573).
      ELSE.
        USR03-NAME1 = SU_FIRST.
      ENDIF.
    ENDIF.
  ENDIF.
ENDMODULE. "SHOW_USER

*EJECT
MODULE CHECK_USER INPUT.
  DATA: CU_LEN     TYPE I
      , CU_STARPOS TYPE I
      .

  IF RSLGTYPE-USER >< SPACE.
    CU_LEN       = STRLEN( RSLGTYPE-USER ) .
    IF RSLGTYPE-USER CA '*'.
      CU_STARPOS = SY-FDPOS + 1 .
    ELSE.
      CU_STARPOS = 0.
    ENDIF.

    IF CU_STARPOS = CU_LEN. "first and only star at end.
    ELSEIF CU_STARPOS = 0. "no star
      " Fine Allow everything here.
    ELSE. "more than one star
      CALL FUNCTION 'POPUP_WITH_WARNING'
        EXPORTING
          TEXTLINE1 = RSLGTYPE-USER
          TEXTLINE2 = 'Sterne wirken nur am Ende generisch'(575).
    ENDIF.
  ENDIF.
ENDMODULE. "CHECK_USER

*   check tasktype and number

MODULE CHECK_TASK_SEL.

  DATA:  NUM_CHECK(11) VALUE '0123456789 ',
         NUM3(3)       TYPE N.

  MOVE RSLGSEL-SELTYP TO DY_TASK_SEL_TYP.
  IF DY_TASK_SEL_TYP >< SPACE.
    IF DY_TASK_SEL_TYP = 'R  '. DY_TASK_SEL_TYP = 'RD '. ENDIF.
    IF DY_TASK_SEL_TYP = 'M  '. DY_TASK_SEL_TYP = 'MS '. ENDIF.
    IF DY_TASK_SEL_TYP = 'W  '. DY_TASK_SEL_TYP = 'WRK'. ENDIF.
    IF DY_TASK_SEL_TYP = 'WR '. DY_TASK_SEL_TYP = 'WRK'. ENDIF.
    IF DY_TASK_SEL_TYP = 'E  '. DY_TASK_SEL_TYP = 'ENQ'. ENDIF.
    IF DY_TASK_SEL_TYP = 'EN '. DY_TASK_SEL_TYP = 'ENQ'. ENDIF.
    IF DY_TASK_SEL_TYP = 'SP '. DY_TASK_SEL_TYP = 'SPO'. ENDIF.
    IF DY_TASK_SEL_TYP = 'DI '. DY_TASK_SEL_TYP = 'DIA'. ENDIF.
    IF DY_TASK_SEL_TYP = 'B  '. DY_TASK_SEL_TYP = 'BTC'. ENDIF.

    CASE DY_TASK_SEL_TYP.

      WHEN 'RD ' OR 'DP ' OR 'MS ' OR 'ENQ' OR 'WRK' OR 'TT ' OR
           'SPO' OR 'DIA' OR 'BTC' OR 'SA ' OR 'S-A' OR 'UP1' OR 'UP2'.

      WHEN OTHERS.
        MESSAGE E180.

    ENDCASE.
  ENDIF.
  RSLGSEL-SELTYP = DY_TASK_SEL_TYP.

  MOVE RSLGSEL-SELNUM TO DY_TASK_SEL_NUM.
  IF DY_TASK_SEL_NUM = SPACE.
    EXIT.
  ELSE.
    CASE DY_TASK_SEL_TYP.

      WHEN 'RD ' OR 'MS ' OR 'DP ' OR 'TT' OR 'ENQ' OR
           'UP1' OR 'UP2' OR 'WRK' OR 'S-A'.
        DY_TASK_SEL_NUM = SPACE.

      WHEN OTHERS.

    ENDCASE.

    IF DY_TASK_SEL_NUM CO NUM_CHECK.
      MOVE DY_TASK_SEL_NUM TO NUM3.
      MOVE NUM3 TO DY_TASK_SEL_NUM.
    ELSE.
      MESSAGE E181.
    ENDIF.
  ENDIF.
  IF DY_TASK_SEL_NUM = 0.
    RSLGSEL-SELNUM = DY_TASK_SEL_NUM.
  ENDIF.
ENDMODULE.                    "CHECK_TASK_SEL

*EJECT
MODULE VALUE_USER INPUT.
*
* implement F4
*
  GET CURSOR FIELD FLD_30X0 VALUE PATTERN_3000.
  COL_30X0 = SY-CUCOL .
  ROW_30X0 = SY-CUROW + 1 .
  ECOL_30X0 = COL_30X0 + 30 .
  EROW_30X0 = ROW_30X0 + 15 .
  CALL SCREEN 3000 STARTING AT COL_30X0  ROW_30X0
                   ENDING  AT ECOL_30X0 EROW_30X0.
ENDMODULE. "VALUE_USER

*---------------------------------------------------------------------*
*  MODULE PBO_STATUS OUTPUT
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
MODULE PBO_STATUS OUTPUT.
*
  DATA: STATUSP(3) TYPE P
      , STATUSC(4).
*
  STATUSP = SY-DYNNR.
  UNPACK STATUSP TO STATUSC.
  SET PF-STATUS STATUSC.
  SET TITLEBAR STATUSC(3).
  CLEAR FCODE.
ENDMODULE.                    "PBO_STATUS OUTPUT

*---------------------------------------------------------------------*
*  MODULE PBO_LIST OUTPUT
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
MODULE PBO_LIST OUTPUT.
* Dummy-Dynpro für Listausgabe
  SUPPRESS DIALOG.
ENDMODULE.                    "PBO_LIST OUTPUT

*---------------------------------------------------------------------*
*  MODULE PAI_3000 INPUT
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
MODULE PAI_3000 INPUT.
  LEAVE TO LIST-PROCESSING AND RETURN TO SCREEN 0.
  NEW-PAGE LINE-SIZE 30 NO-TITLE.
  FORMAT INTENSIFIED OFF.
  " too late... PATTERN_3000 = RSLGTYPE-USER.
  IF PATTERN_3000 CA '*'.
    WRITE: /(30) 'Generischer Selektionswert mit;;'(577).
    USR01-BNAME = PATTERN_3000. HIDE USR01-BNAME.
    WRITE:  (30) '"*" am Ende ist moeglich.     ;;'(578).
    HIDE USR01-BNAME.
    WRITE:  (30) '                              ;;'(579).
    HIDE USR01-BNAME.
    DB_PATT_3000 = PATTERN_3000.

    set extended check off.  " d023157
    TRANSLATE DB_PATT_3000 TO UPPER CASE. "#EC TRANSLANG
    set extended check on.

    REPLACE '*' WITH '%' INTO DB_PATT_3000.
    SELECT * FROM USR01 CLIENT SPECIFIED
                        INTO TABLE USR_3000
                        WHERE BNAME LIKE DB_PATT_3000 .
  ELSE.
    WRITE: /(30) 'Generischer Selektionswert mit;;'(577).
    USR01-BNAME = '*'. HIDE USR01-BNAME.
    WRITE:  (30) '"*" am Ende ist moeglich.     ;;'(578).
    HIDE USR01-BNAME.
    WRITE:  (30) '                              ;;'(579).
    HIDE USR01-BNAME.
    SELECT * FROM USR01 CLIENT SPECIFIED
                        INTO TABLE USR_3000.
  ENDIF.
  SORT USR_3000 BY BNAME MANDT.
  LOOP AT USR_3000.
    WRITE: / USR_3000-MANDT, USR_3000-BNAME INTENSIFIED.
    USR01-BNAME = USR_3000-BNAME. HIDE USR01-BNAME.
  ENDLOOP.
  FREE USR_3000.
  CLEAR USR01-BNAME.
  LEAVE SCREEN.
ENDMODULE.                    "PAI_3000 INPUT

*EJECT
MODULE CHECK_TCODE INPUT.
  DATA: CT_LEN     TYPE I
      , CT_STARPOS TYPE I
      .

  IF RSLGTYPE-TCODE >< SPACE.
    CT_LEN       = STRLEN( RSLGTYPE-TCODE ) .
    IF RSLGTYPE-TCODE CA '*'.
      CT_STARPOS = SY-FDPOS + 1 .
    ELSE.
      CT_STARPOS = 0.
    ENDIF.

    IF CT_STARPOS = CT_LEN. "first and only star at end.
    ELSEIF CT_STARPOS = 0. "no star
      " Fine: dont check here. Output "<generic>" at PBO
      " SELECT SINGLE * FROM TSTC WHERE TCODE = RSLGTYPE-TCODE.
      " IF SY-SUBRC >< 0.
      "   CALL FUNCTION 'POPUP_WITH_WARNING'
      "     EXPORTING
      "     TEXTLINE1 = RSLGTYPE-TCODE
      "     TEXTLINE2 = 'Unbekannter Transaktionscode'(777)
      "     .
      " ENDIF.
    ELSE. "more than one star
      CALL FUNCTION 'POPUP_WITH_WARNING'
        EXPORTING
          TEXTLINE1 = RSLGTYPE-TCODE
          TEXTLINE2 = 'Sterne wirken nur am Ende generisch'(575).
    ENDIF.
  ENDIF.
ENDMODULE. "CHECK_TCODE

*EJECT
MODULE VALUE_TCODE INPUT.
*
* implement F4
*
  GET CURSOR FIELD FLD_30X0 VALUE PATTERN_3010.
  COL_30X0 = SY-CUCOL .
  ROW_30X0 = SY-CUROW + 1 .
  ECOL_30X0 = COL_30X0 + 41 .
  EROW_30X0 = ROW_30X0 + 15 .
  CALL SCREEN 3010 STARTING AT COL_30X0 ROW_30X0
                   ENDING  AT ECOL_30X0 EROW_30X0 .
ENDMODULE. "VALUE_TCODE

*---------------------------------------------------------------------*
*  MODULE PAI_3010 INPUT
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
MODULE PAI_3010 INPUT.
  LEAVE TO LIST-PROCESSING AND RETURN TO SCREEN 0.
  NEW-PAGE LINE-SIZE 41 NO-TITLE.
  FORMAT INTENSIFIED OFF.
  " too late... PATTERN_3010 = RSLGTYPE-TCODE.
  IF PATTERN_3010 CA '*'.
    WRITE: /(30) 'Generischer Selektionswert mit;;'(577).
    TSTC-TCODE = PATTERN_3010. HIDE TSTC-TCODE.
    WRITE:  (30) '"*" am Ende ist moeglich.     ;;'(578).
    HIDE TSTC-TCODE.
    WRITE:  (30) '                              ;;'(579).
    HIDE TSTC-TCODE.
    DB_PATT_3010 = PATTERN_3010.

    set extended check off.
    TRANSLATE DB_PATT_3010 TO UPPER CASE.                "#EC TRANSLANG
    set extended check on.

    REPLACE '*' WITH '%' INTO DB_PATT_3010.
    SELECT * FROM TSTC WHERE TCODE LIKE DB_PATT_3010
                       ORDER BY TCODE.
      SELECT SINGLE * FROM TSTCT WHERE SPRSL = SY-LANGU
                                 AND   TCODE = TSTC-TCODE.
      IF SY-SUBRC >< 0.
        CLEAR TSTCT-TTEXT.
      ENDIF.
      WRITE: / TSTC-TCODE INTENSIFIED, TSTCT-TTEXT.
      HIDE     TSTC-TCODE.
    ENDSELECT.
  ELSE.
    WRITE: /(30) 'Generischer Selektionswert mit;;'(577).
    TSTC-TCODE = '*'. HIDE TSTC-TCODE.
    WRITE:  (30) '"*" am Ende ist moeglich.     ;;'(578).
    HIDE TSTC-TCODE.
    WRITE:  (30) '                              ;;'(579).
    HIDE TSTC-TCODE.
    SELECT * FROM TSTC
                       ORDER BY TCODE.
      SELECT SINGLE * FROM TSTCT WHERE SPRSL = SY-LANGU
                                 AND   TCODE = TSTC-TCODE.
      IF SY-SUBRC >< 0.
        CLEAR TSTCT-TTEXT.
      ENDIF.
      WRITE: / TSTC-TCODE INTENSIFIED, TSTCT-TTEXT.
      HIDE     TSTC-TCODE.
    ENDSELECT.
  ENDIF.
  CLEAR TSTC-TCODE.
  LEAVE SCREEN.
ENDMODULE.                    "PAI_3010 INPUT

*EJECT
MODULE SHOW_REPNA OUTPUT.

  IF RSLGTYPE-REPNA >< SPACE.
    IF RSLGTYPE-REPNA CA '*'.
      REPNA_EXPLAIN = '<generisch>'(570).
    ELSE.
      " The name of the program is in a 'R'-line of the
      " text elements. Here it is to expensive to fetch
      " that texts.
      " SELECT SINGLE * FROM ...
      " IF SY-SUBRC >< 0.
      "   REPNA_EXPLAIN = '<unbekannt>'(571).
      " ENDIF.
      REPNA_EXPLAIN = RSLGTYPE-REPNA.
      REPNA_EXPLAIN+12 = 'oder'(574).
      REPNA_EXPLAIN+20 = RSLGTYPE-REPNA.
      TRANSLATE REPNA_EXPLAIN+20 TO LOWER CASE.
      CONDENSE REPNA_EXPLAIN.
    ENDIF.
  ELSE.
    REPNA_EXPLAIN = SPACE.
  ENDIF.
ENDMODULE. "SHOW_REPNA

*EJECT
MODULE CHECK_REPNA INPUT.
  DATA: CR_LEN     TYPE I
      , CR_STARPOS TYPE I
      .

  IF RSLGTYPE-REPNA >< SPACE.
    CR_LEN       = STRLEN( RSLGTYPE-REPNA ) .
    IF RSLGTYPE-REPNA CA '*'.
      CR_STARPOS = SY-FDPOS + 1 .
    ELSE.
      CR_STARPOS = 0.
    ENDIF.

    IF CR_STARPOS = CR_LEN. "first and only star at end.
    ELSEIF CR_STARPOS = 0. "no star
      " Fine. Dont Check, allow all.
    ELSE. "more than one star
      CALL FUNCTION 'POPUP_WITH_WARNING'
        EXPORTING
          TEXTLINE1 = RSLGTYPE-REPNA
          TEXTLINE2 = 'Sterne wirken nur am Ende generisch'(575).
    ENDIF.
  ENDIF.
ENDMODULE. "CHECK_REPNA

*EJECT
MODULE VALUE_REPNA INPUT.
*
* implement F4
*
  GET CURSOR FIELD FLD_30X0 VALUE PATTERN_3020.
  COL_30X0 = SY-CUCOL .
  ROW_30X0 = SY-CUROW + 1 .
  ECOL_30X0 = COL_30X0 + 41 .
  EROW_30X0 = ROW_30X0 + 15 .
  CALL SCREEN 3020 STARTING AT COL_30X0 ROW_30X0
                   ENDING  AT ECOL_30X0 EROW_30X0 .
ENDMODULE. "VALUE_REPNA

*---------------------------------------------------------------------*
*  MODULE PAI_3020 INPUT
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
MODULE PAI_3020 INPUT.
  LEAVE TO LIST-PROCESSING AND RETURN TO SCREEN 0.
  NEW-PAGE LINE-SIZE 41 NO-TITLE.
  FORMAT INTENSIFIED OFF.
  " too late... PATTERN_3020 = RSLGTYPE-REPNA.
  IF PATTERN_3020 CA '*'.
    WRITE: /(30) 'Keine Hilfe fuer C-Programme! ;;'(581).
    TRDIR-NAME = PATTERN_3020. HIDE TRDIR-NAME.
    WRITE:  (30) '                              ;;'(582).
    HIDE TRDIR-NAME.
    WRITE:  (30) SY-ULINE.
    HIDE TRDIR-NAME.
    WRITE: /(30) 'Generischer Selektionswert mit;;'(577).
    HIDE TRDIR-NAME.
    WRITE:  (30) '"*" am Ende ist moeglich.     ;;'(578).
    HIDE TRDIR-NAME.
    WRITE:  (30) '                              ;;'(579).
    HIDE TRDIR-NAME.
    DB_PATT_3020 = PATTERN_3020.

    set extended check off.
    TRANSLATE DB_PATT_3020 TO UPPER CASE.                "#EC TRANSLANG
    set extended check on.

    REPLACE '*' WITH '%' INTO DB_PATT_3020.
    SELECT * FROM TRDIR WHERE NAME LIKE DB_PATT_3020
                        ORDER BY NAME.
      " The name of the program is in a 'R'-line of the
      " text elements. Here it is to expensive to fetch
      " that texts.
      " SELECT SINGLE * FROM ...
      " IF SY-SUBRC >< 0.
      "   CLEAR REPNA_EXPLAIN.
      " ENDIF.
      WRITE: / TRDIR-NAME INTENSIFIED "... , REPNA_EXPLAIN
           .
      HIDE     TRDIR-NAME.
    ENDSELECT.
  ELSE.
    WRITE: /(30) 'Keine Hilfe fuer C-Programme! ;;'(581).
    TRDIR-NAME = '*'. HIDE TRDIR-NAME.
    WRITE:  (30) '                              ;;'(582).
    HIDE TRDIR-NAME.
    WRITE:  (30) SY-ULINE.
    HIDE TRDIR-NAME.
    WRITE: /(30) 'Generischer Selektionswert mit;;'(577).
    HIDE TRDIR-NAME.
    WRITE:  (30) '"*" am Ende ist moeglich.     ;;'(578).
    HIDE TRDIR-NAME.
    WRITE:  (30) '                              ;;'(579).
    HIDE TRDIR-NAME.
    SELECT * FROM TRDIR
                       ORDER BY NAME.
      " SELECT SINGLE * FROM ...
      " IF SY-SUBRC >< 0.
      "   CLEAR REPNA_EXPLAIN.
      " ENDIF.
      WRITE: / TRDIR-NAME INTENSIFIED "... , REPNA_EXPLAIN
           .
      HIDE     TRDIR-NAME.
    ENDSELECT.
  ENDIF.
  CLEAR TRDIR-NAME.
  LEAVE SCREEN.
ENDMODULE.                    "PAI_3020 INPUT

*EJECT
MODULE HELP_INST INPUT.
*
* implement F1
*
  CALL SCREEN 4030.
ENDMODULE. "VALUE_REPNA

*EJECT
MODULE VALUE_INST INPUT.
*
* implement F4
*
  GET CURSOR FIELD FLD_30X0 VALUE PATTERN_3030.
  COL_30X0 = SY-CUCOL .
  ROW_30X0 = SY-CUROW + 1 .
  ECOL_30X0 = COL_30X0 + 41 .
  EROW_30X0 = ROW_30X0 + 15 .
  CALL SCREEN 3030 STARTING AT COL_30X0 ROW_30X0
                   ENDING  AT ECOL_30X0 EROW_30X0 .
  SET SCREEN 200.                                           "09.12.1998
  LEAVE SCREEN.                                             "09.12.1998
ENDMODULE. "VALUE_INST

*---------------------------------------------------------------------*
*  MODULE PAI_3030 INPUT
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
MODULE PAI_3030 INPUT.
  REFRESH ALL_DESTS.
  PERFORM FIND_ALL_DESTS.

  LEAVE TO LIST-PROCESSING AND RETURN TO SCREEN 0.
  NEW-PAGE LINE-SIZE 41 NO-TITLE.
  FORMAT INTENSIFIED OFF.
  " too late... PATTERN_3030 = RSLGTYPE-REPNA.
  IF PATTERN_3030 CA '*'.
    WRITE: /(30) 'Generischer Selektionswert mit;;'(577).
    RSLGSEL-RFCDEST = PATTERN_3030. HIDE RSLGSEL-RFCDEST.
    WRITE:  (30) '"*" am Ende ist moeglich.     ;;'(578).
    HIDE RSLGSEL-RFCDEST.
    WRITE:  (30) '                              ;;'(579).
    HIDE RSLGSEL-RFCDEST.
    LOOP AT ALL_DESTS.
      IF ALL_DESTS-RFCDEST CP PATTERN_3030.
        RSLGSEL-RFCDEST = ALL_DESTS-RFCDEST.
        IF ALL_DESTS-ACCESS = 0.
          WRITE: / RSLGSEL-RFCDEST INTENSIFIED "... , EXPLAIN
               .
        ELSE.
          WRITE: / RSLGSEL-RFCDEST             "... , EXPLAIN
               .
        ENDIF.
        HIDE       RSLGSEL-RFCDEST.
      ENDIF.
    ENDLOOP.
  ELSE.
    WRITE: /(30) 'Generischer Selektionswert mit;;'(577).
    RSLGSEL-RFCDEST = '*'. HIDE RSLGSEL-RFCDEST.
    WRITE:  (30) '"*" am Ende ist moeglich.     ;;'(578).
    HIDE RSLGSEL-RFCDEST.
    WRITE:  (30) '                              ;;'(579).
    HIDE RSLGSEL-RFCDEST.
    LOOP AT ALL_DESTS.
      RSLGSEL-RFCDEST = ALL_DESTS-RFCDEST.
      IF ALL_DESTS-ACCESS = 0.
        WRITE: / RSLGSEL-RFCDEST INTENSIFIED "... , EXPLAIN
             .
      ELSE.
        WRITE: / RSLGSEL-RFCDEST             "... , EXPLAIN
             .
      ENDIF.
      HIDE       RSLGSEL-RFCDEST.
    ENDLOOP.
  ENDIF.
  CLEAR RSLGSEL-RFCDEST.
  LEAVE SCREEN.
ENDMODULE.                    "PAI_3030 INPUT


*EJECT
MODULE RADIO_A_0200 INPUT.

  IF EXPERT_MODE = ' '.
    " non-experts shall use this radio-box.
    PERFORM CHECK_RADIO3 USING 1 'RSLGTYPE-PRONLY'
                                 RSLGTYPE-PRONLY RSLGTYPE-PROWAR
                                 RSLGTYPE-ALLMSG.
  ELSE.
    " experts may set switches one by one.
    PERFORM CHECK_RADIO3 USING 0 'RSLGTYPE-PRONLY'
                                 RSLGTYPE-PRONLY RSLGTYPE-PROWAR
                                 RSLGTYPE-ALLMSG.
  ENDIF.
  IF RSLGTYPE-PRONLY = 'X'.
    CLEAR: DY_CLASID1, DY_CLASID2, DY_CLASID3,
           DY_CLASID4, DY_CLASID5, DY_CLASID6.
    DY_CLASID1 = 'K'.
    DY_CLASID2 = 'T'.
  ELSEIF RSLGTYPE-PROWAR = 'X'.
    CLEAR: DY_CLASID1, DY_CLASID2, DY_CLASID3,
           DY_CLASID4, DY_CLASID5, DY_CLASID6.
    DY_CLASID1 = 'K'.
    DY_CLASID2 = 'T'.
    DY_CLASID3 = 'W'.
  ELSEIF RSLGTYPE-ALLMSG = 'X'.
    CLEAR: DY_CLASID1, DY_CLASID2, DY_CLASID3,
           DY_CLASID4, DY_CLASID5, DY_CLASID6.
    " no restriction.
  ENDIF.

ENDMODULE. " RADIO_A_0200 INPUT.

*EJECT
*----------------------------------------------------------------------*
MODULE FCODE_200 INPUT.
*----------------------------------------------------------------------*
* Auswertung des OK-Codes des Dynpros 200.
*----------------------------------------------------------------------*
  PERFORM DO_USER_INPUT_EARLY_ALV USING FCODE.

  CALL FUNCTION 'RSLG_SEL_ST_CLASIDS_ALV'
    EXPORTING
      CID1 = DY_CLASID1
      CID2 = DY_CLASID2
      CID3 = DY_CLASID3
      CID4 = DY_CLASID4
      CID5 = DY_CLASID5
      CID6 = DY_CLASID6.

  CALL FUNCTION 'RSLG_SEL_ST_TIMES_ALV'
    EXPORTING
      EDATE = DY_END_DATE
      ETIME = DY_END_TIME
      SDATE = DY_START_DATE
      STIME = DY_START_TIME.

  CALL FUNCTION 'RSLG_SEL_GET_WHICHLOG_ALV'
    IMPORTING
      FILE = TA___WHICHLOG.

  CASE TA___WHICHLOG.
    WHEN REP_ON_LOCAL.
    WHEN REP_ON_REMOTEL.
      DY_RFCDEST = DY_INST.
      CALL FUNCTION 'RSLG_SEL_ST_RFCDEST_ALV'
        EXPORTING
          RFC_DESTINATION = DY_RFCDEST.

      " RFC??? neues DYNPRO Feld !
    WHEN REP_ON_REMOTEA.
      CALL FUNCTION 'RSLG_SEL_ST_RFCDEST_ALV'
        EXPORTING
          RFC_DESTINATION = 'ALL'.
    WHEN REP_ON_CENTRAL.
      CALL FUNCTION 'RSLG_SEL_ST_INST_ALV'
        EXPORTING
          INSTANCE = DY_INST.
  ENDCASE. "TA___WHICHLOG
  CALL FUNCTION 'RSLG_SEL_ST_TASK_ALV'
    EXPORTING
      TASK = RSLGTYPE-TASK.
  CALL FUNCTION 'RSLG_SEL_ST_TASK_TYPNUM_ALV'
    EXPORTING
      TYP = DY_TASK_SEL_TYP
      NUM = DY_TASK_SEL_NUM.
  CALL FUNCTION 'RSLG_SEL_ST_USER_ALV'
    EXPORTING
      USER = RSLGTYPE-USER.
  CALL FUNCTION 'RSLG_SEL_ST_TCODE_ALV'
    EXPORTING
      TCODE = RSLGTYPE-TCODE.
.
  CALL FUNCTION 'RSLG_SEL_ST_REPNA_ALV'
    EXPORTING
      REPNA = RSLGTYPE-REPNA.
  CALL FUNCTION 'RSLG_LAYOUT_ST_PAGES_ALV'
    EXPORTING
      PAGES = RSLGLAYOUT-MAXPAG.
  CALL FUNCTION 'RSLG_LAYOUT_ST_STATS_ALV'
    EXPORTING
      WITH_STATISTICS = DY_STATISTICS.

  " MV '*' TO TA-REGI.

  IF FCODE = 'SLCT'.
    GET CURSOR FIELD CURSOR_FIELD_NAME.
    CASE CURSOR_FIELD_NAME.
      WHEN 'RSLGTYPE-PRONLY'.
        PERFORM ADD_RADIO3 USING 1 RSLGTYPE-PRONLY RSLGTYPE-PROWAR
                                   RSLGTYPE-ALLMSG.
      WHEN 'RSLGTYPE-PROWAR'.
        PERFORM ADD_RADIO3 USING 2 RSLGTYPE-PRONLY RSLGTYPE-PROWAR
                                   RSLGTYPE-ALLMSG.
      WHEN 'RSLGTYPE-ALLMSG'.
        PERFORM ADD_RADIO3 USING 3 RSLGTYPE-PRONLY RSLGTYPE-PROWAR
                                   RSLGTYPE-ALLMSG.
      WHEN OTHERS.
        " Ich kann [F2] an dieser Position nicht verstehen.
        MESSAGE S164.
    ENDCASE.
  ELSE.
    PERFORM DO_USER_INPUT_LATE_ALV  USING FCODE.
  ENDIF.

ENDMODULE. " FCODE_200 INPUT

*EJECT
FORM LOCK_FUNCTION USING A_FCODE.
  LOCKED_FUNCTIONS-FUNC = A_FCODE.
  APPEND LOCKED_FUNCTIONS.
ENDFORM. "LOCK_FUNCTION

*&--------------------------------------------------------------------*
*&      Form  UNLOCK_FUNCTION
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*      -->A_FCODE    text
*---------------------------------------------------------------------*
FORM UNLOCK_FUNCTION USING A_FCODE.
  LOOP AT LOCKED_FUNCTIONS.
    IF LOCKED_FUNCTIONS-FUNC = A_FCODE.
      DELETE LOCKED_FUNCTIONS.
    ENDIF.
  ENDLOOP.
ENDFORM. "UNLOCK_FUNCTION


*EJECT
FORM ACTIVATE_EXPERT_FIELDS_N_FUNCS.
  IF EXPERT_MODE <> 'X'.
    " surpress all fields that need expert knowledge to be used.
    LOOP AT SCREEN.
      IF SCREEN-GROUP2 = 'EXP'.
        SCREEN-ACTIVE    = '0'.
        MODIFY SCREEN.
      ENDIF.
    ENDLOOP.
    " and remove dangerous pull-down functions
    REFRESH DISABLED_FUNCTIONS.
    LOOP AT EXPERT_FUNCTIONS.
      MOVE-CORRESPONDING EXPERT_FUNCTIONS TO DISABLED_FUNCTIONS.
      APPEND DISABLED_FUNCTIONS.
    ENDLOOP.
    LOOP AT LOCKED_FUNCTIONS.
      MOVE-CORRESPONDING LOCKED_FUNCTIONS TO DISABLED_FUNCTIONS.
      APPEND DISABLED_FUNCTIONS.
    ENDLOOP.
  ELSE.
    " Expert? Put all fields onto the screen.
    LOOP AT SCREEN.
      IF SCREEN-GROUP2 = 'EXP'.
        SCREEN-ACTIVE    = '1'.
        MODIFY SCREEN.
      ENDIF.
    ENDLOOP.
    " and allow all pulled-down functions
    REFRESH DISABLED_FUNCTIONS.
    LOOP AT NORMALONLY_FUNCTIONS.
      MOVE-CORRESPONDING NORMALONLY_FUNCTIONS TO DISABLED_FUNCTIONS.
      APPEND DISABLED_FUNCTIONS.
    ENDLOOP.
    LOOP AT LOCKED_FUNCTIONS.
      MOVE-CORRESPONDING LOCKED_FUNCTIONS TO DISABLED_FUNCTIONS.
      APPEND DISABLED_FUNCTIONS.
    ENDLOOP.
  ENDIF.
ENDFORM.                    "ACTIVATE_EXPERT_FIELDS_N_FUNCS

*EJECT

FORM DO_USER_INPUT_EARLY_ALV USING A_FCODE.
*----===================---------------
*
* There is a pair of FORMs: DO_USER_INPUT_EARLY and DO_USER_INPUT_LATE .
* They together handle user input like F-key pressing, pulldown menu
* selection or direct OK-input. Codes which must handles before the rest
* of user data input, are handled by DO_USER_INPUT_EARLY, all other are
* handled by DO_USER_INPUT_LATE.
*
  CASE A_FCODE.

    WHEN 'BACK'.
      CASE SY-PFKEY.
        WHEN '0200'.
          SET SCREEN 0.
          LEAVE SCREEN.
        WHEN '0321'.
          " Dont let him back.
        WHEN '2010'.
          SET SCREEN 0.
          LEAVE SCREEN.
        WHEN '2020'.
          PERFORM LEAVE_2020_WITHOUT_SAVE.
          SET SCREEN 0.
          LEAVE SCREEN.
        WHEN '2030'.
          PERFORM LEAVE_2030_WITHOUT_SAVE.
          SET SCREEN 0.
          LEAVE SCREEN.
        WHEN '2040'.
          SET SCREEN 0.
          LEAVE SCREEN.
        WHEN OTHERS.
          MESSAGE S161 WITH A_FCODE SY-PFKEY.
      ENDCASE.

    WHEN 'RW  '.
      CASE SY-PFKEY.
        WHEN '0200'.
          SET SCREEN 0.
          LEAVE SCREEN.
        WHEN '0321'.
          " Dont let him back.
        WHEN '2010'.
          SET SCREEN 0.
          LEAVE SCREEN.
        WHEN '2020'.
          PERFORM LEAVE_2020_WITHOUT_SAVE.
          SET SCREEN 0.
          LEAVE SCREEN.
        WHEN '2030'.
          PERFORM LEAVE_2030_WITHOUT_SAVE.
          SET SCREEN 0.
          LEAVE SCREEN.
        WHEN '2040'.
          SET SCREEN 0.
          LEAVE SCREEN.
        WHEN OTHERS.
          SET SCREEN 0.
          LEAVE SCREEN.
      ENDCASE.

    WHEN '%EX '.
      CASE SY-PFKEY.
        WHEN '0200'.
          SET SCREEN 0.
          LEAVE SCREEN.
        WHEN '0321'.
          " Dont let him back.
        WHEN '2010'.
          SET SCREEN 0.
          LEAVE SCREEN.
        WHEN '2020'.
          PERFORM LEAVE_2020_WITHOUT_SAVE.
          SET SCREEN 0.
          LEAVE SCREEN.
        WHEN '2030'.
          PERFORM LEAVE_2030_WITHOUT_SAVE.
          SET SCREEN 0.
          LEAVE SCREEN.
        WHEN '2040'.
          SET SCREEN 0.
          LEAVE SCREEN.
        WHEN OTHERS.
          SET SCREEN 0.
          LEAVE SCREEN.
      ENDCASE.

    WHEN 'DEBU'.                    " without CUA
      ADD 1 TO DEBUG_LEVEL.

    WHEN 'DEBUG'.                   " without CUA
      ADD 1 TO DEBUG_LEVEL.

*   WHEN OTHERS. see DO_USER_INPUT_LATE

  ENDCASE. " A_FCODE
ENDFORM. " DO_USER_INPUT_EARLY_ALV.

*EJECT
FORM DO_USER_INPUT_LATE_ALV USING A_FCODE.

*----==================---------------
*
* There is a pair of FORMs: DO_USER_INPUT_EARLY and DO_USER_INPUT_LATE .
* They together handle user input like F-key pressing, pulldown menu
* selection or direct OK-input. Codes which must handles before the rest
* of user data input, are handled by DO_USER_INPUT_EARLY, all other are
* handled by DO_USER_INPUT_LATE.
*
  CASE A_FCODE.

    WHEN SPACE.          " '    '  = [ENTER]
      CASE SY-PFKEY.
        WHEN '0200'.
          " [ENTER] : check fields and update aux-infos.
        WHEN '0321'.
          PERFORM LEAVE_0321.
        WHEN '2000'.
          " SET PF_STATUS BEFORE_2000_PF_STATUS.
          " SET TITLE     BEFORE_2000_PF_STATUS.
          SET SCREEN 0.
          LEAVE SCREEN.
        WHEN '2010'.
          PERFORM LEAVE_2010.
        WHEN '2020'.
          " o.k., stay in popup.
        WHEN '2030'.
          " o.k., stay in popup.
        WHEN '2040'.
          " SET PF_STATUS BEFORE_2040_PF_STATUS.
          " SET TITLE     BEFORE_2040_PF_STATUS.
          SET SCREEN 0.
          LEAVE SCREEN.
        WHEN OTHERS.
          MESSAGE S161 WITH '    ' SY-PFKEY.
      ENDCASE.

    WHEN 'SASE'.         " = F11 on some popups
      CASE SY-PFKEY.
        WHEN '0321'.
          PERFORM LEAVE_0321.
        WHEN '2010'.
          PERFORM LEAVE_2010.
        WHEN '2020'.
          PERFORM LEAVE_2020_WITH_SAVE_ALV.
          SET SCREEN 0.
          LEAVE SCREEN.
        WHEN '2030'.
          PERFORM LEAVE_2030_WITH_SAVE_ALV.
          SET SCREEN 0.
          LEAVE SCREEN.
        WHEN OTHERS.
          MESSAGE S161 WITH '    ' SY-PFKEY.
      ENDCASE.

    WHEN 'ARSL'.
      CASE SY-PFKEY.
        WHEN '0200'.
          CALL FUNCTION 'RSLG_SEL_ST_WHICHLOG_ALV'
            EXPORTING
              FILE = REP_ON_REMOTEA.
        WHEN OTHERS.
          MESSAGE S161 WITH A_FCODE SY-PFKEY.
      ENDCASE.

    WHEN 'CESL'.
      CASE SY-PFKEY.
        WHEN '0200'.
          CALL FUNCTION 'RSLG_SEL_ST_WHICHLOG_ALV'
            EXPORTING
              FILE = REP_ON_CENTRAL.
        WHEN OTHERS.
          MESSAGE S161 WITH A_FCODE SY-PFKEY.
      ENDCASE.

    WHEN 'DEBU'.                    " without CUA
      " nothing here.

    WHEN 'DEBUG'.                   " without CUA
      " nothing here.

    WHEN 'DOAG'.
      CASE SY-PFKEY.
        WHEN '0200'.
          ABOUT_OLD_DATA = 'R'.
          PERFORM WRITE_A_LIST_ALV.
        WHEN 'LIST_ALV'.
          PERFORM START_OVERWRITE_MAIN_LIST.
          ABOUT_OLD_DATA = 'R'.
          PERFORM WRITE_A_LIST_ALV.
          PERFORM FINISH_OVERWRITE_MAIN_LIST.
        WHEN OTHERS.
          MESSAGE S161 WITH A_FCODE SY-PFKEY.
      ENDCASE. " SY-PFKEY.

    WHEN 'DOAP'.
      CASE SY-PFKEY.
        WHEN '0200'.
          ABOUT_OLD_DATA = 'A'.
          PERFORM WRITE_A_LIST_ALV.
        WHEN 'LIST_ALV'.
          PERFORM START_OVERWRITE_MAIN_LIST.
          ABOUT_OLD_DATA = 'A'.
          PERFORM WRITE_A_LIST_ALV.
          PERFORM FINISH_OVERWRITE_MAIN_LIST.
        WHEN OTHERS.
          MESSAGE S161 WITH A_FCODE SY-PFKEY.
      ENDCASE. " SY-PFKEY.

    WHEN 'DOIT'.
      CASE SY-PFKEY.
        WHEN '0200'.
          ABOUT_OLD_DATA = 'N'.
          PERFORM WRITE_A_LIST_ALV.
        WHEN OTHERS.
          MESSAGE S161 WITH A_FCODE SY-PFKEY.
      ENDCASE. " SY-PFKEY.

    WHEN 'TEXP'.       " --> expert mode
      EXPERT_MODE = 'X'.

    WHEN 'TNEX'.       " --> non-expert mode
      EXPERT_MODE = ' '.

    WHEN 'DOC1'.
      CASE SY-PFKEY.
        WHEN 'LIST_ALV'.
          PERFORM SHOW_SL_DOCU.
        WHEN 'INFO_ALV'.
          PERFORM SHOW_SL_DOCU.
        WHEN OTHERS.
          MESSAGE S161 WITH A_FCODE SY-PFKEY.
      ENDCASE.

    WHEN 'DOC2'.
      CASE SY-PFKEY.
        WHEN 'INFO_ALV'.
          PERFORM SHOW_2ND_DOCU.
        WHEN OTHERS.
          MESSAGE S161 WITH A_FCODE SY-PFKEY.
      ENDCASE.

    WHEN 'ENT+'.
      CASE SY-PFKEY.
        WHEN 'BACK'.
          PERFORM SHOW_DETAILS_NEW USING '+1'.
        WHEN 'INFO_ALV'.
          PERFORM SHOW_DETAILS_NEW USING '+1'.
        WHEN OTHERS.
          MESSAGE S161 WITH A_FCODE SY-PFKEY.
      ENDCASE.

    WHEN 'ENT-'.
      CASE SY-PFKEY.
        WHEN 'BACK'.
          PERFORM SHOW_DETAILS_NEW USING '-1'.
        WHEN 'INFO_ALV'.
          PERFORM SHOW_DETAILS_NEW USING '-1'.
        WHEN OTHERS.
          MESSAGE S161 WITH A_FCODE SY-PFKEY.
      ENDCASE.

    WHEN 'EXPL'.
      CASE SY-PFKEY.
        WHEN 'LIST_ALV'.
          PERFORM TAKE_EXAMPLE_FOR_SEL.
        WHEN 'INFO_ALV'.
          PERFORM TAKE_EXAMPLE_FOR_SEL.
        WHEN OTHERS.
          MESSAGE S161 WITH A_FCODE SY-PFKEY.
      ENDCASE.

    WHEN 'GTPO'. " Get position
      CALL FUNCTION 'RSLG_SEL_GET_WHICHLOG_ALV'
        IMPORTING
          FILE = TA___WHICHLOG.
      CASE TA___WHICHLOG.
        WHEN REP_ON_LOCAL.
          CALL 'C_GET_SYSLOG_POS'
                        ID 'POSI' FIELD FC-POS
                        ID 'WRAP' FIELD FC-WRAPCOUNT
                        ID 'MAXS' FIELD FC-MAXSIZE
                        .
          IF FC-WRAPCOUNT = 0.
            IF FC-POS = 0.
              DY_START_FILE = 1.
              DY_START_POS  = 0.
            ELSE.
              DY_START_FILE = 1.
              DY_START_POS  = FC-POS - SYSLOG_FILE-RECORDSIZE.
            ENDIF.
          ELSE.
            IF FC-POS = 0.
              DY_START_FILE = FC-WRAPCOUNT.
              DY_START_POS  = FC-MAXSIZE - SYSLOG_FILE-RECORDSIZE.
            ELSE.
              DY_START_FILE = FC-WRAPCOUNT + 1.
              DY_START_POS  = FC-POS - SYSLOG_FILE-RECORDSIZE.
            ENDIF.
          ENDIF.
        WHEN REP_ON_REMOTEL.
          MESSAGE I174.
        WHEN REP_ON_REMOTEA.
          MESSAGE I174.
        WHEN REP_ON_CENTRAL.
          CALL 'C_SAPGPARAM' ID 'NAME' FIELD 'rslg/central/file'
                             ID 'VALUE' FIELD ACTFILENAME.
          CALL 'C_RSTRB_READ_BUFFERED'
                        ID 'BUFF' FIELD AN_C_ENTRY
                        ID 'NAME' FIELD ACTFILENAME
                        ID 'SIZE' FIELD SYSLOG_FILE-RECORDSIZE
                        ID 'POSI' FIELD SYSLOG_FILE-READ_POSI.
          if sy-subrc = 0 AND UNICODE_SYS = 1 AND CONV_PAGE_REQU = 1.
              perform CONVERT_TO_INTERNAL IN PROGRAM SAPLSLO2_ALV
                                          using    INT_FROM_PAGE
                                                   INT_TO_PAGE
                                          changing AN_C_ENTRY.
           endif.

          " I hope the file starts with its file number.
          IF SY-SUBRC = 0.
            IF  AN_C_ENTRY-sender_id(5)   = OWNCENT " 5 = OWNCENTLG
            AND AN_C_ENTRY-sender_id+5(1) = OWNFILE.
              MOVE AN_C_ENTRY-centdata TO RSLGFILINF.
              IF RSLGFILINF-fi_filenum CO ' 0123456789'.
                SYSLOG_FILE-ACTCFILENO = RSLGFILINF-fi_filenum.
              ELSE.
                "??
              ENDIF.
              DY_START_FILE = SYSLOG_FILE-ACTCFILENO.
            ENDIF.
          ENDIF.
          CALL 'C_RSTRB_READ_BUFFERED'
                        ID 'BUFF' FIELD AN_C_ENTRY
                        ID 'POSI' FIELD SYSLOG_FILE-RECORDSIZE
                        ID 'BACK' FIELD 'X'
                        ID 'RBEG' FIELD SYSLOG_FILE-READ_POSI.  "output
          if sy-subrc = 0 AND UNICODE_SYS = 1 AND CONV_PAGE_REQU = 1.
              perform CONVERT_TO_INTERNAL IN PROGRAM SAPLSLO2_ALV
                                          using   INT_FROM_PAGE
                                                  INT_TO_PAGE
                                         changing AN_C_ENTRY.
           endif.

          IF SY-SUBRC = 0.
            DY_START_POS  = SYSLOG_FILE-READ_POSI.
          ENDIF.
          " Close that file again.
          CALL 'C_RSTRB_READ_BUFFERED'
                        ID 'BUFF' FIELD A_DUMMY_C_ENTRY " Dummy
                        ID 'CLOS' FIELD 'X'
                        .

      ENDCASE.

    WHEN 'IGNO'.
      CASE SY-PFKEY.
        WHEN 'LIST_ALV'.
          PERFORM IGNORE_THIS_MESSAGE_ID_ALV.
        WHEN 'INFO_ALV'.
          PERFORM IGNORE_THIS_MESSAGE_ID_ALV.
        WHEN OTHERS.
          MESSAGE S161 WITH A_FCODE SY-PFKEY.
      ENDCASE.

    WHEN 'INFO'.
      PERFORM SHOW_DETAILS_NEW USING 'F2'.

    WHEN 'LAYO'.
      CALL SCREEN 2010 STARTING AT 20 6 . " ENDING AT 60 21.

    WHEN 'LOSL'.
      CASE SY-PFKEY.
        WHEN '0200'.
          CALL FUNCTION 'RSLG_SEL_ST_WHICHLOG_ALV'
            EXPORTING
              FILE = REP_ON_LOCAL.
        WHEN OTHERS.
          MESSAGE S161 WITH A_FCODE SY-PFKEY.
      ENDCASE.

    WHEN 'MOSE'.
      CASE SY-PFKEY.
        WHEN '0200'.
          CALL SCREEN 2020 STARTING AT 1 6.
        WHEN '2030'.
          PERFORM LEAVE_2030_WITH_SAVE_ALV.
          CALL SCREEN 2020 STARTING AT 1 6.
        WHEN OTHERS.
          MESSAGE S161 WITH '    ' SY-PFKEY.
      ENDCASE.

    WHEN 'MOS2'.
      CASE SY-PFKEY.
        WHEN '0200'.
          IF IGNORE_IDS_CNT < 4.
            CALL SCREEN 2030 STARTING AT 1 6 ENDING AT 79 20.
          ELSE.
            CALL SCREEN 2030.
          ENDIF.
        WHEN '2020'.
          PERFORM LEAVE_2020_WITH_SAVE_ALV.
          IF IGNORE_IDS_CNT < 4.
            CALL SCREEN 2030 STARTING AT 1 6 ENDING AT 79 20.
          ELSE.
            CALL SCREEN 2030.
          ENDIF.
        WHEN OTHERS.
          MESSAGE S161 WITH '    ' SY-PFKEY.
      ENDCASE.

    WHEN 'RESL'.
      CASE SY-PFKEY.
        WHEN '0200'.
          CALL FUNCTION 'RSLG_SEL_ST_WHICHLOG_ALV'
            EXPORTING
              FILE = REP_ON_REMOTEL.
        WHEN OTHERS.
          MESSAGE S161 WITH A_FCODE SY-PFKEY.
      ENDCASE.

    WHEN 'SLCT'.
      CASE SY-PFKEY.
        WHEN '0321'.
          " coding is in PAI module.
        WHEN '3000'.
          RSLGTYPE-USER = USR01-BNAME.
          SET SCREEN 0.
          LEAVE SCREEN.
        WHEN '3010'.
          RSLGTYPE-TCODE = TSTC-TCODE.
          SET SCREEN 0.
          LEAVE SCREEN.
        WHEN '3020'.
          RSLGTYPE-REPNA = TRDIR-NAME.
          SET SCREEN 0.
          LEAVE SCREEN.
        WHEN '3030'.
          DY_INST = RSLGSEL-RFCDEST.
          SET SCREEN 0.
          LEAVE SCREEN.
        WHEN OTHERS.
          MESSAGE S161 WITH A_FCODE SY-PFKEY.
      ENDCASE.

    WHEN 'SNAP'.
      CASE SY-PFKEY.
        WHEN 'INFO_ALV'.
          SET PF-STATUS 'SNA2'.
          PERFORM DO_LOOK_AT_SNAP.
        WHEN OTHERS.
          MESSAGE S161 WITH A_FCODE SY-PFKEY.
      ENDCASE.

    WHEN 'SOCP'.  PERFORM DO_USER_SORT_ALV USING A_FCODE.
    WHEN 'SODC'.  PERFORM DO_USER_SORT_ALV USING A_FCODE.
    WHEN 'SOFI'.  PERFORM DO_USER_SORT_ALV USING A_FCODE.
    WHEN 'SOID'.  PERFORM DO_USER_SORT_ALV USING A_FCODE.
    WHEN 'SOPC'.  PERFORM DO_USER_SORT_ALV USING A_FCODE.
    WHEN 'SOTI'.  PERFORM DO_USER_SORT_ALV USING A_FCODE.
    WHEN 'SOTA'.  PERFORM DO_USER_SORT_ALV USING A_FCODE.
    WHEN 'SOTY'.  PERFORM DO_USER_SORT_ALV USING A_FCODE.

    WHEN 'SBER'. " Umfeld-->Zeige Berechtigung
      PERFORM SHOW_PERMISSIONS.

    WHEN 'SCLK'. " Umfeld-->Uhren
      PERFORM SHOW_CLOCKS.

    WHEN 'SMSG'. " Umfeld-->Zeige Status der Daemonen
      PERFORM SHOW_DAEMON_MSG.

    WHEN 'SPAR'. " Umfeld-->Zeige SAPPARAM
      PERFORM SHOW_SAPPARAMS.

    WHEN OTHERS.
      " '%EX ', 'BACK', 'RW  ' shall not arive here.
      MESSAGE S161 WITH A_FCODE SY-PFKEY.
  ENDCASE. " A_FCODE
ENDFORM. " DO_USER_INPUT_LATE_ALV.

*EJECT

*EJECT
FORM DO_USER_SORT_ALV USING A_FCODE.
*----============---------------
* Called via action and DO_USER_INPUT_LATE_ALV .
*
  DATA: L_ORDER LIKE LAYOUT-NEED_SORT.

  L_ORDER = A_FCODE. " Copy to variable with correct length.
  CASE SY-PFKEY.
    WHEN '0200'.
      CALL FUNCTION 'RSLG_LAYOUT_ST_SORT_ALV'
        EXPORTING
          ORDER = L_ORDER.

    WHEN 'LIST'.
      CALL FUNCTION 'RSLG_LAYOUT_ST_SORT_ALV'
        EXPORTING
          ORDER = L_ORDER.
      PERFORM START_OVERWRITE_MAIN_LIST.
      ABOUT_OLD_DATA = 'R'.
      PERFORM WRITE_A_LIST_ALV.
      PERFORM FINISH_OVERWRITE_MAIN_LIST.
    WHEN OTHERS.
      MESSAGE S161 WITH A_FCODE SY-PFKEY.
  ENDCASE.
ENDFORM. "DO_USER_SORT_ALV

*EJECT

FORM PREPARE_A_LIST.
*----==============-
* Will be called by RSLG0000 and RSLG0001 via extern PERFORM.

* I want to know selection criterias too.
*

  CALL FUNCTION 'RSLG_SEL_DUMP_ALV'
    IMPORTING
      ITSELF = TA.

* Get names of SysLog files and file positions.
*
  IF TA-WHICHLOG = REP_ON_REMOTEL.
    CALL FUNCTION 'RSLG_FILEINFO_INIT_ALV' DESTINATION TA-RFCDEST
      EXPORTING
        WHICHLOG              = TA-WHICHLOG
      IMPORTING
        INFO_AFTER            = SYSLOG_FILE
      EXCEPTIONS
        SYSTEM_FAILURE        = 2  MESSAGE LAST_RFC_MESS
        COMMUNICATION_FAILURE = 3  MESSAGE LAST_RFC_MESS.
    IF SY-SUBRC >< 0.
      CLEAR SYSLOG_FILE.
      "??? ,   ERRRC TYPE I    " 0 or SY-SUBRC of RFC
      "??? ,   ERRMESS(60).    " of RFC
    ENDIF.
  ELSEIF TA-WHICHLOG = REP_ON_REMOTEA.
    " later ???
  ELSE.
    CALL FUNCTION 'RSLG_FILEINFO_INIT_ALV'
      EXPORTING
        WHICHLOG   = 'i' "internal selection
      IMPORTING
        INFO_AFTER = SYSLOG_FILE.
  ENDIF.

  PERFORM INIT_LAYOUT.

ENDFORM. "PREPARE_A_LIST
*EJECT
FORM WRITE_A_LIST_ALV.
*----============-
  REFRESH: GT_GEN_OUTLINE, GT_INST, GT_MAND, GT_REPO,
           GT_TCOD, GT_BENU, GT_MSG, GT_SNAP, GT_CONTENTS,
           GT_TOP, GT_END, GT_HIDE_BUFFER.

  CLEAR:   GS_GEN_OUTLINE, GS_INST, GS_MAND, GS_REPO,
           GS_TCOD, GS_BENU, GS_MSG, GS_SNAP, GS_CONTENTS,
           GS_TOP, GS_END, GV_PAGE.

  REFRESH: INT_USE_SIM_TOP, INT_USE_OUTLINE, INT_USE_DATE.
  CLEAR:   GV_INTERNAL_DATE, LV_H_IND, HH_INT_USE_OUTLINE,
           INT_USE_DATE, GV_INTERNAL_DATE, GV_INDEX.

  DATA DUMMY LIKE CPU_ID.

* * Reset the reporting facility.
  PERFORM INIT_ME USING DUMMY.
  CPU_ID = DUMMY.                "Is calles by RSLG0000/1 also.

* * Bereite Caches vor.
  PERFORM INIT_INTERN_TAB_ALV.
  PERFORM INIT_LAYOUT.

* * Get names of SysLog files and file positions.
*
  CALL FUNCTION 'RSLG_SEL_DUMP_ALV'
    IMPORTING
      ITSELF = TA.
  IF TA-WHICHLOG = REP_ON_REMOTEL.
    CALL FUNCTION 'RSLG_FILEINFO_INIT_ALV' DESTINATION TA-RFCDEST
      EXPORTING
        WHICHLOG              = TA-WHICHLOG
      IMPORTING
        INFO_AFTER            = SYSLOG_FILE
      EXCEPTIONS
        SYSTEM_FAILURE        = 2  MESSAGE LAST_RFC_MESS
        COMMUNICATION_FAILURE = 3  MESSAGE LAST_RFC_MESS.
    IF SY-SUBRC >< 0.
      CLEAR SYSLOG_FILE.
      "??? ,   ERRRC TYPE I    " 0 or SY-SUBRC of RFC
      "??? ,   ERRMESS(60).    " of RFC
    ENDIF.
  ELSEIF TA-WHICHLOG = REP_ON_REMOTEA.
    " later
  ELSE.
    CALL FUNCTION 'RSLG_FILEINFO_INIT_ALV'
      EXPORTING
        WHICHLOG   = 'i' "internal selection
      IMPORTING
        INFO_AFTER = SYSLOG_FILE.
  ENDIF.
  PERFORM DYNPRO_TO_LIST_ALV USING 'LIST_ALV'.

  CALL FUNCTION 'RSLG_LAYOUT_GET_PRINT_ALV'
    IMPORTING
      TO_PRINTER = DY_PRINT
      LAYOUT     = DY_OUT_DEST.
  CALL FUNCTION 'RSLG_LAYOUT_DUMP_ALV'
    IMPORTING
      ITSELF = LAYOUT.


* * Print simulated DYNPRO screen.
  PERFORM WRITE_DYNPRO_ALV.
* * Read and report  about that SysLog file.
  CLEAR INT_USE_DATE.
  PERFORM READ_SYSLOG_ALV.
* * Sort entriestab by default date/time and sender_id
  SORT ENTRIESTAB STABLE BY  POS_CREATT SENDER_ID.
*
  PERFORM WRITE_LIST_ABOUT_SYSLOG_ALV.
*
  PERFORM DO_END_OF_SELECTION_ALV.
*
  GV_OUTPUT_TERM = 'X'.
  PERFORM OUTPUT_ALV.
*   ADD 1 TO GV_LIST_COUNTER.
*   LEAVE TO LIST-PROCESSING.
*   PERFORM END_OF_LIST.

ENDFORM. " WRITE_A_LIST_ALV.

*EJECT
*                         DYNPRO  0321  (popup)
*          +-----------------------------------------------+
*          ! Sie haben die Selektionskriterien geaendert.  !
*          ! Soll die SysLog-Datei erneut gelesen werden?  !
*          !                                               !
*          ! . Werte gelesene Eintraege nochmals aus.      !
*          ! . Lese SysLog-Dateien nochmals.               !
*          +-----------------------------------------------+

MODULE INIT_0321 OUTPUT.
*------===============-
* Initialisierung des Dynpros 0321.

  BEFORE_0321_PF_STATUS = SY-PFKEY.
  SET PF-STATUS '0321'.
  CLEAR: FCODE.
  SET TITLEBAR '321'.

  REASON1   = 'Sie haben die Selektionskriterien geaendert.'(400).
  REASON2   = 'Soll die SysLog-Datei erneut gelesen werden?'(401).
  REASON3   = ' '(402).
  PERFORM SET_RADIO2 USING 0 REUSE READAGAIN.
  SET CURSOR FIELD 'REUSE'.

ENDMODULE. " INIT_0321 OUTPUT


MODULE EARLY_PAI_0321 INPUT.
*------==============-------
* Auswertung des Dynpros 321.

  FCODE = SY-UCOMM. " Pop up dynpro has no FCODE field on its own.
  PERFORM DO_USER_INPUT_EARLY_ALV USING FCODE.

ENDMODULE. " EARLY_PAI_0321 INPUT


*---------------------------------------------------------------------*
*  MODULE USE_READ_PAI_0321 INPUT
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
MODULE USE_READ_PAI_0321 INPUT.
*------=================-------
* Auswertung des Dynpros 321.

  PERFORM CHECK_RADIO2 USING 0 'REUSE' REUSE READAGAIN.

ENDMODULE. " EARLY_PAI_0321 INPUT


*---------------------------------------------------------------------*
*  MODULE FCODE_0321 INPUT
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
MODULE FCODE_0321 INPUT.
*------=========-------
* Auswertung des OK-Codes des Dynpros 321.

  IF FCODE = 'SLCT'.
    GET CURSOR FIELD CURSOR_FIELD_NAME.
    CASE CURSOR_FIELD_NAME.
      WHEN 'REUSE'.
        PERFORM ADD_RADIO2 USING 1 REUSE READAGAIN.
        PERFORM LEAVE_0321.
      WHEN 'READAGAIN'.
        PERFORM ADD_RADIO2 USING 2 REUSE READAGAIN.
        PERFORM LEAVE_0321.
      WHEN OTHERS.
        " Ich kann [F2] an dieser Position nicht verstehen.
        MESSAGE S164.
    ENDCASE.
  ELSE.
    PERFORM DO_USER_INPUT_LATE_ALV  USING FCODE.
  ENDIF.

ENDMODULE. " FCODE_0321 INPUT


*&--------------------------------------------------------------------*
*&      Form  LEAVE_0321
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM LEAVE_0321.
*----==========-

  PERFORM CHECK_RADIO2 USING 1 'REUSE' REUSE READAGAIN.
  IF REUSE     = 'X'. ABOUT_OLD_DATA = 'R'. ENDIF.
  IF READAGAIN = 'X'. ABOUT_OLD_DATA = 'N'. ENDIF.
  " SET PF_STATUS BEFORE_0321_PF_STATUS.
  " SET TITLE     BEFORE_0321_PF_STATUS.
  SET SCREEN 0.
  LEAVE SCREEN.

ENDFORM.                                                    "LEAVE_0321

*EJECT
*                         DYNPRO  2000  (popup)
*          +-------------------------------------------------------+
*          ! Position der SysLog-Datei zu Beginn der Auswertung -- !
*          ! Anzahl Ueberlaeufe...... ________                     !
*          ! Anzahl Bytes............ ________                     !
*          !                                                       !
*          ! Derzeitige Position --------------------------------- !
*          ! Anzahl Ueberlaeufe...... ________                     !
*          ! Anzahl Bytes............ ________                     !
*          !                                                       !
*          ! Nicht in der Auswertung ----------------------------- !
*          ! Anzahl neuer Eintraege.. ________                     !
*          +-------------------------------------------------------+

MODULE INIT_2000 OUTPUT.
*------===============-
* Initialisierung des Dynpros 2000.

  PERFORM ACTIVATE_EXPERT_FIELDS_N_FUNCS.

  BEFORE_2000_PF_STATUS = SY-PFKEY.
  SET PF-STATUS '2000'.
  CLEAR: FCODE.
  SET TITLEBAR '501'.

* DY_2000_OLD_POS = SYSLOG_FILE-POS.
* DY_2000_OLD_WC  = SYSLOG_FILE-WRAPCOUNT.
  DY_2000_CUR_POS = FC-POS.
  DY_2000_CUR_WC  = FC-WRAPCOUNT.
  DY_2000_ENTRIES = FC-ENTRIES.

  SET CURSOR FIELD 'FC-ENTRIES'.

ENDMODULE. " INIT_2000 OUTPUT


*---------------------------------------------------------------------*
*  MODULE FCODE_2000 INPUT
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
MODULE FCODE_2000 INPUT.
*------=========-------
* Auswertung des OK-Codes des Dynpros 2000.
  PERFORM DO_USER_INPUT_EARLY_ALV USING FCODE.
  PERFORM DO_USER_INPUT_LATE_ALV  USING FCODE.

ENDMODULE. " FCODE_2000 INPUT


MODULE INIT_2010 OUTPUT.
*------===============-
* Initialisierung des Dynpros 2010.

  PERFORM ACTIVATE_EXPERT_FIELDS_N_FUNCS.

  BEFORE_2010_PF_STATUS = SY-PFKEY.
  SET PF-STATUS '2010' EXCLUDING DISABLED_FUNCTIONS.
  CLEAR: FCODE.
  SET TITLEBAR '502'.

  IF ENTER_DY2010_1ST_TIME = SAP_YES.
    DY_COL_TABE     = 'X'.
    DY_COL_DEVCLASS = ' '.
    DY_COL_POSI     = ' '.
    DY_LIN_PARAREC  = ' '.
    DY_COL_MAND     = 'X'.
    DY_COL_DATE     = ' '.
    DY_COL_PROG     = ' '.
    DY_COL_TERM     = ' '.
    DY_COL_BEW      = ' '.
    PERFORM SET_RADIO4 USING 0 DY_SCREEN DY_PR80 DY_PR120 DY_PR132.
    ENTER_DY2010_1ST_TIME = SAP_NO.
  ENDIF.

  SET CURSOR FIELD 'DY_COL_TABE'.

ENDMODULE. " INIT_2010 OUTPUT


*---------------------------------------------------------------------*
*  MODULE EARLY_PAI_2010 INPUT
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
MODULE EARLY_PAI_2010 INPUT.
*------==============-------
* Auswertung des Dynpros 2010.

  FCODE = SY-UCOMM. " Pop up dynpro has no FCODE field on its own.
  PERFORM DO_USER_INPUT_EARLY_ALV USING FCODE.

ENDMODULE. " EARLY_PAI_2010 INPUT


*---------------------------------------------------------------------*
*  MODULE OUTPUT_PAI_2010 INPUT
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
MODULE OUTPUT_PAI_2010 INPUT.
*------===============-------
* Auswertung des Dynpros 2010.

  PERFORM CHECK_RADIO4 USING 0 'DY_SCREEN'
                             DY_SCREEN DY_PR80 DY_PR120 DY_PR132.

ENDMODULE. " OUTPUT_PAI_2010 INPUT


*---------------------------------------------------------------------*
*  MODULE FCODE_2010 INPUT
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
MODULE FCODE_2010 INPUT.
*------=========-------
* Auswertung des OK-Codes des Dynpros 2010.

  IF FCODE = 'SLCT'.
    GET CURSOR FIELD CURSOR_FIELD_NAME.
    CASE CURSOR_FIELD_NAME.
      WHEN 'DY_COL_TABE'.
        PERFORM TOGGLE USING DY_COL_TABE.
        " but dont leave.
      WHEN 'DY_COL_DEVCLASS'.
        PERFORM TOGGLE USING DY_COL_DEVCLASS.
        " but dont leave.
      WHEN 'DY_COL_POSI'.
        PERFORM TOGGLE USING DY_COL_POSI.
        " but dont leave.
      WHEN 'DY_LIN_PARAREC'.
        PERFORM TOGGLE USING DY_LIN_PARAREC.
        " but dont leave.
      WHEN 'DY_COL_MAND'.
        PERFORM TOGGLE USING DY_COL_MAND.
        " but dont leave.
      WHEN 'DY_COL_DATE'.
        PERFORM TOGGLE USING DY_COL_DATE.
        " but dont leave.
      WHEN 'DY_COL_PROG'.
        PERFORM TOGGLE USING DY_COL_PROG.
        " but dont leave.
      WHEN 'DY_COL_TERM'.
        PERFORM TOGGLE USING DY_COL_TERM.
        " but dont leave.
      WHEN 'DY_COL_BEW'.
        PERFORM TOGGLE USING DY_COL_BEW.
        " but dont leave.
      WHEN 'DY_SCREEN'.
        PERFORM ADD_RADIO4 USING 1 DY_SCREEN DY_PR80 DY_PR120 DY_PR132.
        PERFORM LEAVE_2010.
      WHEN 'DY_PR80'.
        PERFORM ADD_RADIO4 USING 2 DY_SCREEN DY_PR80 DY_PR120 DY_PR132.
        PERFORM LEAVE_2010.
      WHEN 'DY_PR120'.
        PERFORM ADD_RADIO4 USING 3 DY_SCREEN DY_PR80 DY_PR120 DY_PR132.
        PERFORM LEAVE_2010.
      WHEN 'DY_PR132'.
        PERFORM ADD_RADIO4 USING 4 DY_SCREEN DY_PR80 DY_PR120 DY_PR132.
        PERFORM LEAVE_2010.
      WHEN OTHERS.
        " Ich kann [F2] an dieser Position nicht verstehen.
        MESSAGE S164.
    ENDCASE.
  ELSE.
    PERFORM DO_USER_INPUT_LATE_ALV  USING FCODE.
  ENDIF.

ENDMODULE. " FCODE_2010 INPUT

*&--------------------------------------------------------------------*
*&      Form  LEAVE_2010
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM LEAVE_2010.
*----==========-

  PERFORM CHECK_RADIO4 USING 1 'DY_SCREEN'
                             DY_SCREEN DY_PR80 DY_PR120 DY_PR132.
  CALL FUNCTION 'RSLG_LAYOUT_ST_COL_TABE_ALV'
    EXPORTING
      WITH_COLUMN = DY_COL_TABE.
  CALL FUNCTION 'RSLG_LAYOUT_ST_COL_DEVC_ALV'
    EXPORTING
      WITH_COLUMN = DY_COL_DEVCLASS.
  CALL FUNCTION 'RSLG_LAYOUT_ST_COL_POSI_ALV'
    EXPORTING
      WITH_COLUMN = DY_COL_POSI.
  CALL FUNCTION 'RSLG_SEL_ST_PARAREC_ALV'
    EXPORTING
      WITH_LINE = DY_LIN_PARAREC.
  CALL FUNCTION 'RSLG_LAYOUT_ST_COL_MAND_ALV'
    EXPORTING
      WITH_COLUMN = DY_COL_MAND.
  CALL FUNCTION 'RSLG_LAYOUT_ST_COL_DATE_ALV'
    EXPORTING
      WITH_COLUMN = DY_COL_DATE.
  CALL FUNCTION 'RSLG_LAYOUT_ST_COL_PROG_ALV'
    EXPORTING
      WITH_COLUMN = DY_COL_PROG.
  CALL FUNCTION 'RSLG_LAYOUT_ST_COL_TERM_ALV'
    EXPORTING
      WITH_COLUMN = DY_COL_TERM.
  CALL FUNCTION 'RSLG_LAYOUT_ST_COL_BEW_ALV'
    EXPORTING
      WITH_COLUMN = DY_COL_BEW.

  IF DY_SCREEN = 'X'.
    CALL FUNCTION 'RSLG_LAYOUT_ST_PRINT_ALV'
      EXPORTING
        PRINT_KIND = 'S'.
  ENDIF.
  IF DY_PR80   = 'X'.
    CALL FUNCTION 'RSLG_LAYOUT_ST_PRINT_ALV'
      EXPORTING
        PRINT_KIND = '8'.
  ENDIF.
  IF DY_PR120  = 'X'.
    CALL FUNCTION 'RSLG_LAYOUT_ST_PRINT_ALV'
      EXPORTING
        PRINT_KIND = '2'.
  ENDIF.
  IF DY_PR132  = 'X'.
    CALL FUNCTION 'RSLG_LAYOUT_ST_PRINT_ALV'
      EXPORTING
        PRINT_KIND = '3'.
  ENDIF.
  " SET PF_STATUS BEFORE_2010_PF_STATUS.
  " SET TITLE     BEFORE_2010_PF_STATUS.
  SET SCREEN 0.
  LEAVE SCREEN.

ENDFORM.                                                    "LEAVE_2010

*EJECT
*                         DYNPRO  2020  (popup)
*----------------------------------------------------------------------+
* Weitere Eingrenzungen ---------------------------------------------- !
* Task.................................... __                          !
* Problemklassen.......................... _ _ _ _ _ _                 !
* von Datei / Position.................... ______ / ____________       !
* bis Datei / Position.................... ______ / ____________       !
* Meldungsformat (Typ).................... _    ______________________ !
* Entwicklungsklasse...................... ____ ______________________ !
* mit SysLog-internen Eintraegen.......... _                           !
*----------------------------------------------------------------------+

MODULE INIT_2020 OUTPUT.
*------===============-
* Initialisierung des Dynpros 2020.

  PERFORM ACTIVATE_EXPERT_FIELDS_N_FUNCS.

  IF WITHIN_2020_PROCESSING = ' '.
    BEFORE_2020_PF_STATUS       = SY-PFKEY.
    BEFORE_2020_TASK            = RSLGTYPE-TASK.
    BEFORE_2020_CLASID1         = DY_CLASID1.
    BEFORE_2020_CLASID2         = DY_CLASID2.
    BEFORE_2020_CLASID3         = DY_CLASID3.
    BEFORE_2020_CLASID4         = DY_CLASID4.
    BEFORE_2020_CLASID5         = DY_CLASID5.
    BEFORE_2020_CLASID6         = DY_CLASID6.
    BEFORE_2020_START_FILE      = DY_START_FILE.
    BEFORE_2020_START_FILE_N6   = DY_START_FILE_N6.
    BEFORE_2020_START_POS       = DY_START_POS.
    BEFORE_2020_START_POS_N10   = DY_START_POS_N10.
    BEFORE_2020_STOP_FILE       = DY_STOP_FILE.
    BEFORE_2020_DY_STOP_FILE_N6 = DY_STOP_FILE_N6.
    BEFORE_2020_DY_STOP_POS     = DY_STOP_POS.
    BEFORE_2020_DY_STOP_POS_N10 = DY_STOP_POS_N10.
    BEFORE_2020_SLTYPE          = TSL3T-SLTYPE.
    BEFORE_2020_TYPE            = DY_TYPE.
    BEFORE_2020_TERMINAL        = RSLGTYPE-TERMINAL.
    "     _2020_DEVCLASS        = TADIR-DEVCLASS.
    BEFORE_2020_DEVCLASS        = DY_DEVCLASS.
    BEFORE_2020_INTERNRECS      = DY_INTERNRECS.
    WITHIN_2020_PROCESSING      = 'X'.
  ENDIF.

  SET PF-STATUS '2020' EXCLUDING DISABLED_FUNCTIONS.
  CLEAR: FCODE.
  SET TITLEBAR '503'.

  " TADIR-... is used at differnt places. So my value was saved
  " in DY_DEVCLASS.
  TADIR-DEVCLASS = DY_DEVCLASS.
  IF TADIR-DEVCLASS <> SPACE.
    IF TADIR-DEVCLASS CA '*'.
      TDEVC-CTEXT = '<generisch>'(570).
    ELSE.
      SELECT SINGLE * FROM TDEVC WHERE DEVCLASS = TADIR-DEVCLASS.
      IF SY-SUBRC >< 0.
        TDEVC-CTEXT = '<unbekannt>'(571).
      ENDIF.
    ENDIF.
  ELSE.
    CLEAR TDEVC-CTEXT.
  ENDIF.

  TSL3T-SLTYPE   = DY_TYPE.
  CLEAR: TSL3T-TXT.
  IF TSL3T-SLTYPE <> SPACE.
    SELECT SINGLE * FROM TSL3T
      WHERE SPRAS  = SY-LANGU
      AND   SLTYPE = TSL3T-SLTYPE.
  ENDIF.
  AUX_SLGPROC-TASKTNO = '     '. NO_TASKTNO = 'X'.
  PERFORM EXPLAIN_NEW_TASK_TYPE USING DY_TASK_SEL_TYP DY_TASK_EXPLAIN.
  SET CURSOR FIELD 'TADIR-DEVCLASS'.

ENDMODULE. " INIT_2020 OUTPUT


*---------------------------------------------------------------------*
*  MODULE EARLY_PAI_2020 INPUT
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
MODULE EARLY_PAI_2020 INPUT.
*------==============-------
* Auswertung des Dynpros 2020.

  FCODE = SY-UCOMM. " Pop up dynpro has no FCODE field on its own.
  PERFORM DO_USER_INPUT_EARLY_ALV USING FCODE.

ENDMODULE. " EARLY_PAI_2020 INPUT


*---------------------------------------------------------------------*
*  MODULE FCODE_2020 INPUT
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
MODULE FCODE_2020 INPUT.
*------=========-------
* Auswertung des OK-Codes des Dynpros 2020.

  DY_DEVCLASS = TADIR-DEVCLASS.
  DY_TYPE     = TSL3T-SLTYPE.

  IF FCODE = 'SLCT'.
    GET CURSOR FIELD CURSOR_FIELD_NAME.
    CASE CURSOR_FIELD_NAME.
      WHEN OTHERS.
        " Ich kann [F2] an dieser Position nicht verstehen.
        MESSAGE S164.
    ENDCASE.
  ELSE.
    PERFORM DO_USER_INPUT_LATE_ALV  USING FCODE.
  ENDIF.

ENDMODULE. " FCODE_2020 INPUT

*EJECT

MODULE CHECK_DEVCLASS_2020 INPUT.
*----------------------------------------------------------------------*
* Überprüfen der eingegebenen Entwicklungsklasse.
*

  DATA: CD_LEN     TYPE I
      , CD_STARPOS TYPE I
      .

  CLEAR TDEVC-CTEXT.
  IF TADIR-DEVCLASS <> SPACE.

    CD_LEN       = STRLEN( TADIR-DEVCLASS ) .
    IF TADIR-DEVCLASS CA '*'.
      CD_STARPOS = SY-FDPOS + 1 .
    ELSE.
      CD_STARPOS = 0.
    ENDIF.

    IF CD_STARPOS = CD_LEN. "first and only star at end.
      TDEVC-CTEXT = '<generisch>'(570).
    ELSEIF CD_STARPOS = 0. "no star
      SELECT SINGLE * FROM TDEVC WHERE DEVCLASS = TADIR-DEVCLASS.
      IF SY-SUBRC >< 0.
        TDEVC-CTEXT = '<unbekannt>'(571).
      ENDIF.
    ELSE. "more than one star
      CALL FUNCTION 'POPUP_WITH_WARNING'
        EXPORTING
          TEXTLINE1 = TADIR-DEVCLASS
          TEXTLINE2 = 'Sterne wirken nur am Ende generisch'(575).
    ENDIF.
  ENDIF.
ENDMODULE. " CHECK_DEVCLASS_2020 INPUT


*EJECT
MODULE MODIFY_POS_AND_COUNT INPUT.
*----------------------------------------------------------------------*
* Alle eingegebenen Problemklassen werden linksbündig verschoben.
* Bestimmung der Anzahl der eingegebenen Problemklassen.
*
  DATA: BEGIN OF SECHS
      ,   CLASID1
      ,   CLASID2
      ,   CLASID3
      ,   CLASID4
      ,   CLASID5
      ,   CLASID6
      , END OF SECHS
      , LEN            TYPE I
      , CLASID_COUNTER TYPE I
      .

  CLEAR: TSL2T-CLASSNAME.
  SECHS-CLASID1 = DY_CLASID1 .
  SECHS-CLASID2 = DY_CLASID2 .
  SECHS-CLASID3 = DY_CLASID3 .
  SECHS-CLASID4 = DY_CLASID4 .
  SECHS-CLASID5 = DY_CLASID5 .
  SECHS-CLASID6 = DY_CLASID6 .

  CONDENSE SECHS NO-GAPS.
  LEN = STRLEN( SECHS ).
  CLASID_COUNTER = LEN.

  IF CLASID_COUNTER > 0.
    CLEAR: DY_CLASID1, DY_CLASID2, DY_CLASID3
         , DY_CLASID4, DY_CLASID5, DY_CLASID6.
    DY_CLASID1 = SECHS-CLASID1.
    DY_CLASID2 = SECHS-CLASID2.
    DY_CLASID3 = SECHS-CLASID3.
    DY_CLASID4 = SECHS-CLASID4.
    DY_CLASID5 = SECHS-CLASID5.
    DY_CLASID6 = SECHS-CLASID6.

*   Einlesen des Textfeldes für die links stehende Problemklasse.
    SELECT SINGLE * FROM TSL2T
      WHERE SPRAS  = SY-LANGU
      AND   CLASID = DY_CLASID1.

  ENDIF.

ENDMODULE. " MODIFY_POS_AND_COUNT INPUT

*&--------------------------------------------------------------------*
*&      Form  LEAVE_2020_WITHOUT_SAVE
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM LEAVE_2020_WITHOUT_SAVE.
*----==========-

* Restore all values.
  IF WITHIN_2020_PROCESSING = 'X'.
    RSLGTYPE-TASK     = BEFORE_2020_TASK.
    DY_CLASID1        = BEFORE_2020_CLASID1.
    DY_CLASID2        = BEFORE_2020_CLASID2.
    DY_CLASID3        = BEFORE_2020_CLASID3.
    DY_CLASID4        = BEFORE_2020_CLASID4.
    DY_CLASID5        = BEFORE_2020_CLASID5.
    DY_CLASID6        = BEFORE_2020_CLASID6.
    DY_START_FILE     = BEFORE_2020_START_FILE.
    DY_START_FILE_N6  = BEFORE_2020_START_FILE_N6.
    DY_START_POS      = BEFORE_2020_START_POS.
    DY_START_POS_N10  = BEFORE_2020_START_POS_N10.
    DY_STOP_FILE      = BEFORE_2020_STOP_FILE.
    DY_STOP_FILE_N6   = BEFORE_2020_DY_STOP_FILE_N6.
    DY_STOP_POS       = BEFORE_2020_DY_STOP_POS.
    DY_STOP_POS_N10   = BEFORE_2020_DY_STOP_POS_N10.
    TSL3T-SLTYPE      = BEFORE_2020_SLTYPE.
    DY_TYPE           = BEFORE_2020_TYPE.
    RSLGTYPE-TERMINAL = BEFORE_2020_TERMINAL.
    TADIR-DEVCLASS    = BEFORE_2020_DEVCLASS.
    DY_DEVCLASS       = BEFORE_2020_DEVCLASS.
    DY_INTERNRECS     = BEFORE_2020_INTERNRECS.
    MESSAGE S171. "Kriterien wurden nicht uebernommen
  ENDIF.

  WITHIN_2020_PROCESSING      = ' '.

  " SET PF_STATUS BEFORE_2020_PF_STATUS.
  " SET TITLE     BEFORE_2020_PF_STATUS.
  " SET SCREEN 0.
  " LEAVE SCREEN.

ENDFORM. "LEAVE_2020_WITHOUT_SAVE

*&--------------------------------------------------------------------*
*&      Form  LEAVE_2020_WITH_SAVE_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM LEAVE_2020_WITH_SAVE_ALV.
*----==========-

* * Move paramters in.
*
  DY_START_FILE_N6 = DY_START_FILE.
  DY_START_POS_N10 = DY_START_POS.
  DY_STOP_FILE_N6  = DY_STOP_FILE.
  DY_STOP_POS_N10  = DY_STOP_POS.
  CALL FUNCTION 'RSLG_SEL_ST_POSI_ALV'
    EXPORTING
      EFILE_NO = DY_STOP_FILE_N6
      EPOS     = DY_STOP_POS_N10
      SFILE_NO = DY_START_FILE_N6
      SPOS     = DY_START_POS_N10.

  CALL FUNCTION 'RSLG_SEL_ST_LOGT_ALV'
    EXPORTING
      ENTRYTYPE = DY_TYPE.

  CALL FUNCTION 'RSLG_SEL_ST_TERM_ALV'
    EXPORTING
      TERMINAL = RSLGTYPE-TERMINAL.

  CALL FUNCTION 'RSLG_SEL_ST_DEVCLASS_ALV'
    EXPORTING
      DEVCLASS = DY_DEVCLASS.
  CALL FUNCTION 'RSLG_SEL_ST_CLASIDS_ALV'
    EXPORTING
      CID1 = DY_CLASID1
      CID2 = DY_CLASID2
      CID3 = DY_CLASID3
      CID4 = DY_CLASID4
      CID5 = DY_CLASID5
      CID6 = DY_CLASID6.
  CALL FUNCTION 'RSLG_SEL_ST_INTERNRECS_ALV'
    EXPORTING
      WITH_LINE = DY_INTERNRECS.

  " LL FUNCTION 'RSLG_SEL_ST_PARAREC'
  "    EXPORTING WITH_LINE = ' '.

  " RSLGTYPE-TASK  will be set with screen 0200 !
  " RSLGTYPE-REPNA will be set with screen 0200 !

  WITHIN_2020_PROCESSING      = ' '.

  " SET PF_STATUS BEFORE_2020_PF_STATUS.
  " SET TITLE     BEFORE_2020_PF_STATUS.
  " SET SCREEN 0.
  " LEAVE SCREEN.

ENDFORM. "LEAVE_2020_WITH_SAVE_ALV



*EJECT
*                         DYNPRO  2030  (popup)
*--------------------------------------------------------------------+
* Weitere Eingrenzungen -------------------------------------------- !
* _ nur diese Meldungen                                              !
* _ alle ausser diesen Meldungen                                     !
*                                                                    !
* __ _  ____________________________________________________________ !
* __ _  ____________________________________________________________ !
* __ _  ____________________________________________________________ !
* __ _  ____________________________________________________________ !
*----------------------------------------------------------------------+

MODULE INIT_2030 OUTPUT.
*------===============-
* Initialisierung des Dynpros 2030.

  PERFORM ACTIVATE_EXPERT_FIELDS_N_FUNCS.

  IF WITHIN_2030_PROCESSING = ' '.
    BEFORE_2030_PF_STATUS  = SY-PFKEY.
    BEFORE_2030_MSGINC     = IGNORE_IDS_INC.
    BEFORE_2030_MSGLST     = IGNORE_IDS_LST.

    WITHIN_2030_PROCESSING = 'X'.
  ENDIF.

  SET PF-STATUS '2030' EXCLUDING DISABLED_FUNCTIONS.
  CLEAR: FCODE.
  SET TITLEBAR '503'.

ENDMODULE. " INIT_2030 OUTPUT

*EJECT
MODULE LOOP_2030_OUTPUT OUTPUT.
  READ TABLE IGNORE_IDS INDEX SY-STEPL.
  IF SY-SUBRC = 0.
    MOVE-CORRESPONDING IGNORE_IDS TO TSL1D.
    MOVE-CORRESPONDING IGNORE_IDS TO TSL1T.
  ENDIF.
ENDMODULE.                    "LOOP_2030_OUTPUT OUTPUT


*---------------------------------------------------------------------*
*  MODULE EARLY_PAI_2030 INPUT
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
MODULE EARLY_PAI_2030 INPUT.
*------==============-------
* Auswertung des Dynpros 2030.

  FCODE = SY-UCOMM. " Pop up dynpro has no FCODE field on its own.
  PERFORM DO_USER_INPUT_EARLY_ALV USING FCODE.

ENDMODULE. " EARLY_PAI_2030 INPUT

*EJECT
MODULE LOOP_2030_INPUT INPUT.
  IF TSL1D-AREA <> SPACE OR TSL1D-SUBID <> SPACE.
    SELECT SINGLE * FROM TSL1D INTO *TSL1D
                         WHERE AREA  = TSL1D-AREA
                         and   SUBID = TSL1D-SUBID
                         .
    IF SY-SUBRC = 0.
      READ TABLE IGNORE_IDS INDEX SY-STEPL.
      IF SY-SUBRC = 0.
        " Overtyping is insert and not update.
        IF TSL1D-AREA  <> IGNORE_IDS-AREA
        OR TSL1D-SUBID <> IGNORE_IDS-SUBID.
          CLEAR IGNORE_IDS.
          MOVE-CORRESPONDING TSL1D TO IGNORE_IDS.
          IGNORE_IDS-FRESH = 'X'.
          SELECT SINGLE * FROM TSL1T
                               WHERE SPRAS = SY-LANGU
                               AND   AREA  = TSL1D-AREA
                               AND   SUBID = TSL1D-SUBID.
          IF SY-SUBRC = 0.
            IGNORE_IDS-TXT = TSL1T-TXT.
          ELSE.
            SELECT SINGLE * FROM TSL1T
                            WHERE SPRAS = 'EN'
                            AND   AREA  = TSL1D-AREA
                            AND   SUBID = TSL1D-SUBID.
            IF SY-SUBRC = 0.
              IGNORE_IDS-TXT = TSL1T-TXT.
            ELSE.
              IGNORE_IDS-TXT = '<kein Text?>'(500).
            ENDIF.
          ENDIF.
          APPEND IGNORE_IDS.
        ENDIF.
      ELSE.
        " More than before ==> insert.
        CLEAR IGNORE_IDS.
        MOVE-CORRESPONDING TSL1D TO IGNORE_IDS.
        IGNORE_IDS-FRESH = 'X'.
        SELECT SINGLE * FROM TSL1T
                             WHERE SPRAS = SY-LANGU
                             AND   AREA  = TSL1D-AREA
                             AND   SUBID = TSL1D-SUBID                 .
        IF SY-SUBRC = 0.
          IGNORE_IDS-TXT = TSL1T-TXT.
        ELSE.
          SELECT SINGLE * FROM TSL1T
                            WHERE SPRAS = 'EN'
                            AND   AREA  = TSL1D-AREA
                            AND   SUBID = TSL1D-SUBID.
          IF SY-SUBRC = 0.
            IGNORE_IDS-TXT = TSL1T-TXT.
          ELSE.
            IGNORE_IDS-TXT = '<kein Text?>'(500).
          ENDIF.
        ENDIF.
        APPEND IGNORE_IDS.
      ENDIF.
    ELSE.
      MESSAGE I166 WITH TSL1D-AREA TSL1D-SUBID.
    ENDIF.
  ELSE.
    READ TABLE IGNORE_IDS INDEX SY-STEPL.
    IF SY-SUBRC = 0.
      " If there was something on screen AND it was overwritten
      "   with spaces, then it shall be deleted.
      IGNORE_IDS-DELETED = 'X'.
      MODIFY IGNORE_IDS INDEX SY-STEPL.
    ENDIF.
  ENDIF.
ENDMODULE.                    "LOOP_2030_INPUT INPUT


*---------------------------------------------------------------------*
*  MODULE FCODE_2030 INPUT
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
MODULE FCODE_2030 INPUT.
*------=========-------
* Auswertung des OK-Codes des Dynpros 2030.

  FIELD-SYMBOLS: <TMP_PTR>.

  IGNORE_IDS_INC = RSLGSEL-MSGINC. " part of radio box on screen

  CLEAR: IGNORE_IDS_CNT
       , IGNORE_IDS_LST.
  ASSIGN IGNORE_IDS_LST(3) TO <TMP_PTR>.
  LOOP AT IGNORE_IDS.
    IF IGNORE_IDS-DELETED <> ' ' AND IGNORE_IDS-FRESH = ' '.
      DELETE IGNORE_IDS.
    ELSE.
      IGNORE_IDS-DELETED      = ' '.
      IGNORE_IDS-FRESH        = ' '.
      MODIFY IGNORE_IDS.
      ADD 1 TO IGNORE_IDS_CNT.
*     Put the first 20 message ids also into the IGNORE_IDS_LST.
      IF IGNORE_IDS_CNT <= IGNORE_IDS_LST_LG.
        MOVE IGNORE_IDS-AREA  TO <TMP_PTR>.
        ASSIGN <TMP_PTR>+2(1) TO <TMP_PTR>.
        MOVE IGNORE_IDS-SUBID TO <TMP_PTR>.
        IF IGNORE_IDS_CNT < IGNORE_IDS_LST_LG.
          ASSIGN <TMP_PTR>+1(3) TO <TMP_PTR>.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDLOOP.

  IF IGNORE_IDS_CNT = 0 AND IGNORE_IDS_INC = 'X'.
    MESSAGE I172. "Leere Liste zum Selektieren wird ignoriert.
    RSLGSEL-MSGINC = ' '.
    IGNORE_IDS_INC = ' '.
    MSGINC_OFF     = 'X'.
  ENDIF.

  IF FCODE = 'SLCT'.
    GET CURSOR FIELD CURSOR_FIELD_NAME.
    CASE CURSOR_FIELD_NAME.
      WHEN OTHERS.
        " Ich kann [F2] an dieser Position nicht verstehen.
        MESSAGE S164.
    ENDCASE.
  ELSE.
    PERFORM DO_USER_INPUT_LATE_ALV  USING FCODE.
  ENDIF.

ENDMODULE. " FCODE_2030 INPUT

*&--------------------------------------------------------------------*
*&      Form  LEAVE_2030_WITH_SAVE
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM LEAVE_2030_WITH_SAVE_ALV.
*----==========-
* * Move paramters in.

  CALL FUNCTION 'RSLG_SEL_ST_MSGLST_ALV'
    EXPORTING
      MSGINC = IGNORE_IDS_INC
      MSGLST = IGNORE_IDS_LST.
  WITHIN_2030_PROCESSING = ' '.

  " SET PF_STATUS BEFORE_2030_PF_STATUS.
  " SET TITLE     BEFORE_2030_PF_STATUS.
  " SET SCREEN 0.
  " LEAVE SCREEN.

ENDFORM. "LEAVE_2030_WITH_SAVE_ALV


FORM LEAVE_2030_WITH_SAVE.
*----==========-

* * Move paramters in.
*
  CALL FUNCTION 'RSLG_SEL_ST_MSGLST'
    EXPORTING
      MSGINC = IGNORE_IDS_INC
      MSGLST = IGNORE_IDS_LST.
  WITHIN_2030_PROCESSING = ' '.

  " SET PF_STATUS BEFORE_2030_PF_STATUS.
  " SET TITLE     BEFORE_2030_PF_STATUS.
  " SET SCREEN 0.
  " LEAVE SCREEN.

ENDFORM. "LEAVE_2030_WITH_SAVE

*&--------------------------------------------------------------------*
*&      Form  LEAVE_2030_WITHOUT_SAVE
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM LEAVE_2030_WITHOUT_SAVE.
*----==========-

  DATA: BEGIN OF PATT
      ,   AREA  LIKE IGNORE_IDS-AREA
      ,   SUBID LIKE IGNORE_IDS-SUBID
      , END  OF PATT.

  data: patt_tmp(3).   " wg. Unicode    hgk   15.5.2000

  IF WITHIN_2030_PROCESSING = 'X'.
    IGNORE_IDS_INC = BEFORE_2030_MSGINC.
    IGNORE_IDS_LST = BEFORE_2030_MSGLST.

    REFRESH IGNORE_IDS.
    DO 20 TIMES VARYING PATT_tmp FROM IGNORE_IDS_LST(3)
                             NEXT IGNORE_IDS_LST+3(3)
                             range IGNORE_IDS_LST.

      patt-area  = patt_tmp(2).    " wg. unicode     hgk   15.5.2000
      patt-subid = patt_tmp+2(1).

      IF PATT >< SPACE.
        CLEAR IGNORE_IDS.
        IGNORE_IDS-AREA  = PATT-AREA.
        IGNORE_IDS-SUBID = PATT-SUBID.
        SELECT SINGLE * FROM TSL1T
                             WHERE SPRAS = SY-LANGU
                             AND   AREA  = IGNORE_IDS-AREA
                             AND   SUBID = IGNORE_IDS-SUBID.
        IF SY-SUBRC = 0.
          IGNORE_IDS-TXT = TSL1T-TXT.
        ELSE.
          SELECT SINGLE * FROM TSL1T
                            WHERE SPRAS = 'EN'
                            AND   AREA  = IGNORE_IDS-AREA
                            AND   SUBID = IGNORE_IDS-SUBID.
          IF SY-SUBRC = 0.
            IGNORE_IDS-TXT = TSL1T-TXT.
          ELSE.
            IGNORE_IDS-TXT = '<kein Text?>'(500).
          ENDIF.
        ENDIF.
        APPEND IGNORE_IDS.
      ELSE.
        EXIT."FROM LOOP
      ENDIF.
    ENDDO.
  ENDIF.
  WITHIN_2030_PROCESSING = ' '.

  " SET PF_STATUS BEFORE_2030_PF_STATUS.
  " SET TITLE     BEFORE_2030_PF_STATUS.
  " SET SCREEN 0.
  " LEAVE SCREEN.

ENDFORM. "LEAVE_2030_WITHOUT_SAVE

*EJECT
FORM TEXT_ABOUT_MORE_SELS USING A_TEXT.

  DATA MORE_SELS(140).

  CLEAR MORE_SELS.
  IF DY_CLASID1 <> SPACE OR DY_CLASID2 <> SPACE
  OR DY_CLASID3 <> SPACE OR DY_CLASID4 <> SPACE
  OR DY_CLASID5 <> SPACE OR DY_CLASID6 <> SPACE
  .
    MORE_SELS+100 = 'Prob.kl.'(493).
    CONDENSE MORE_SELS.
  ENDIF.
  IF DY_START_FILE <> SPACE OR DY_START_POS <> SPACE.
    MORE_SELS+100 = 'Anf.pos.'(483).
    CONDENSE MORE_SELS.
  ENDIF.
  IF DY_STOP_FILE <> SPACE OR DY_STOP_POS <> SPACE.
    MORE_SELS+100 = 'End.pos.'(485).
    CONDENSE MORE_SELS.
  ENDIF.
  IF DY_TYPE <> SPACE.
    MORE_SELS+100 = 'Meldungstyp'(487).
    CONDENSE MORE_SELS.
  ENDIF.
  IF RSLGTYPE-REPNA <> SPACE.
    MORE_SELS+100 = 'Prog.'(495).
    CONDENSE MORE_SELS.
  ENDIF.
  IF DY_DEVCLASS <> SPACE.
    MORE_SELS+100 = 'Entw.kl.'(489).
    CONDENSE MORE_SELS.
  ENDIF.
  IF IGNORE_IDS_CNT >= 1.
    MORE_SELS+100 = 'Meld.filter'(491).
    CONDENSE MORE_SELS.
  ENDIF.
  IF MORE_SELS = SPACE.
    A_TEXT = '<keine>'(481).
  ELSE.
    A_TEXT = MORE_SELS.
  ENDIF.

ENDFORM. "TEXT_ABOUT_MORE_SELS

*EJECT
FORM TOGGLE USING A_BOOL_FIELD.
*----======--------------------
  IF A_BOOL_FIELD = SAP_NO.
    A_BOOL_FIELD = SAP_YES.
  ELSE.
    A_BOOL_FIELD = SAP_NO.
  ENDIF.
ENDFORM.                    "TOGGLE



*&--------------------------------------------------------------------*
*&      Form  SET_RADIO2
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*      -->A_NR       text
*      -->A_CLIC1    text
*      -->A_CLIC2    text
*---------------------------------------------------------------------*
FORM SET_RADIO2 USING A_NR A_CLIC1 A_CLIC2.
*----==========----------------------------
* Set up fields in a radio box.
*
* Input:  A_NR          1,2,... number of button to be set
*                       else    clear all button.
*         A_CLICi       DYNPR/ABAP-field for button.
*
  CASE A_NR.
    WHEN 1.
      A_CLIC1 = 'X'.
      A_CLIC2 = '.'.
    WHEN 2.
      A_CLIC1 = '.'.
      A_CLIC2 = 'X'.
    WHEN OTHERS.
      A_CLIC1 = '.'.
      A_CLIC2 = '.'.
  ENDCASE.
ENDFORM.                                                    "SET_RADIO2

*&--------------------------------------------------------------------*
*&      Form  SET_RADIO3
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*      -->A_NR       text
*      -->A_CLIC1    text
*      -->A_CLIC2    text
*      -->A_CLIC3    text
*---------------------------------------------------------------------*
FORM SET_RADIO3 USING A_NR A_CLIC1 A_CLIC2 A_CLIC3.
*----==========------------------------------------
* Set up fields in a radio box. Like 'SET_RADIO2'.
*
  CASE A_NR.
    WHEN 1.
      A_CLIC1 = 'X'.
      A_CLIC2 = '.'.
      A_CLIC3 = '.'.
    WHEN 2.
      A_CLIC1 = '.'.
      A_CLIC2 = 'X'.
      A_CLIC3 = '.'.
    WHEN 3.
      A_CLIC1 = '.'.
      A_CLIC2 = '.'.
      A_CLIC3 = 'X'.
    WHEN OTHERS.
      A_CLIC1 = '.'.
      A_CLIC2 = '.'.
      A_CLIC3 = '.'.
  ENDCASE.
ENDFORM.                                                    "SET_RADIO3

*&--------------------------------------------------------------------*
*&      Form  SET_RADIO4
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*      -->A_NR       text
*      -->A_CLIC1    text
*      -->A_CLIC2    text
*      -->A_CLIC3    text
*      -->A_CLIC4    text
*---------------------------------------------------------------------*
FORM SET_RADIO4 USING A_NR    TYPE I
                      A_CLIC1 TYPE C
                      A_CLIC2 TYPE C
                      A_CLIC3 TYPE C
                      A_CLIC4 TYPE C .
*----==========--------------------------------------------
* Set up fields in a radio box. Like 'SET_RADIO2'.
*
  CASE A_NR.
    WHEN 1.
      A_CLIC1 = 'X'.
      A_CLIC2 = '.'.
      A_CLIC3 = '.'.
      A_CLIC4 = '.'.
    WHEN 2.
      A_CLIC1 = '.'.
      A_CLIC2 = 'X'.
      A_CLIC3 = '.'.
      A_CLIC4 = '.'.
    WHEN 3.
      A_CLIC1 = '.'.
      A_CLIC2 = '.'.
      A_CLIC3 = 'X'.
      A_CLIC4 = '.'.
    WHEN 4.
      A_CLIC1 = '.'.
      A_CLIC2 = '.'.
      A_CLIC3 = '.'.
      A_CLIC4 = 'X'.
    WHEN OTHERS.
      A_CLIC1 = '.'.
      A_CLIC2 = '.'.
      A_CLIC3 = '.'.
      A_CLIC4 = '.'.
  ENDCASE.
ENDFORM.                                                    "SET_RADIO4

*EJECT
FORM ADD_RADIO2 USING A_NR    TYPE I
                      A_CLIC1 TYPE C
                      A_CLIC2 TYPE C .
*----==========----------------------------
* Set up fields in a radio box.
*
* Input:  A_NR          1,2,... number of button to be set
*                       else    clear all button.
*         A_CLICi       DYNPR/ABAP-field for button.
*
  CASE A_NR.
    WHEN 1.
      A_CLIC1 = 'X'.
    WHEN 2.
      A_CLIC2 = 'X'.
  ENDCASE.
ENDFORM.                                                    "ADD_RADIO2

*EJECT
FORM ADD_RADIO3 USING A_NR    TYPE I
                      A_CLIC1 TYPE C
                      A_CLIC2 TYPE C
                      A_CLIC3 TYPE C .
*----==========------------------------------------
* Set up fields in a radio box. Like 'ADD_RADIO2'
*
  CASE A_NR.
    WHEN 1.
      A_CLIC1 = 'X'.
    WHEN 2.
      A_CLIC2 = 'X'.
    WHEN 3.
      A_CLIC3 = 'X'.
  ENDCASE.
ENDFORM.                                                    "ADD_RADIO3

*EJECT
FORM ADD_RADIO4 USING A_NR    TYPE I
                      A_CLIC1 TYPE C
                      A_CLIC2 TYPE C
                      A_CLIC3 TYPE C
                      A_CLIC4 TYPE C .
*----==========--------------------------------------------
* Set up fields in a radio box. Like 'ADD_RADIO2'
*
  CASE A_NR.
    WHEN 1.
      A_CLIC1 = 'X'.
    WHEN 2.
      A_CLIC2 = 'X'.
    WHEN 3.
      A_CLIC3 = 'X'.
    WHEN 4.
      A_CLIC4 = 'X'.
  ENDCASE.
ENDFORM.                                                    "ADD_RADIO4

*EJECT
FORM CHECK_RADIO2 USING A_MIN       TYPE I
                        A_FIELDNAME TYPE C
                        A_CLIC1     TYPE C
                        A_CLIC2     TYPE C .
*----============-----------------------------------------
* Check a radio box and enforce exact one pressed button
*
* Input:  A_FIELDNAME   Name of the DYNPR/ABAP-field of the first button
*         A_CLICi       DYNPR/ABAP-field for button.
*
*
  DATA L_SEL_COUNTER TYPE I.

  CLEAR L_SEL_COUNTER.
  IF A_CLIC1 = 'X'. ADD 1 TO L_SEL_COUNTER. ENDIF.
  IF A_CLIC2 = 'X'. ADD 1 TO L_SEL_COUNTER. ENDIF.

  IF A_MIN = 0.
    IF L_SEL_COUNTER > 1.
      CLEAR FCODE.
      " PERFORM SET_RADIO2 USING 0 A_CLIC1 A_CLIC2.
      SET CURSOR FIELD A_FIELDNAME.
*     'Bitte nur eine Auswahl ankreuzen'.
      MESSAGE E160.
    ENDIF.
  ELSE.
    IF L_SEL_COUNTER <> 1.
      CLEAR FCODE.
      " PERFORM SET_RADIO2 USING 0 A_CLIC1 A_CLIC2.
      SET CURSOR FIELD A_FIELDNAME.
*     'Bitte genau eine Auswahl ankreuzen'.
      MESSAGE E163.
    ENDIF.
  ENDIF.
ENDFORM. "CHECK_RADIO2


*&--------------------------------------------------------------------*
*&      Form  CHECK_RADIO3
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*      -->A_MIN      text
*      -->A_FIELDNAMEtext
*      -->A_CLIC1    text
*      -->A_CLIC2    text
*      -->A_CLIC3    text
*---------------------------------------------------------------------*
FORM CHECK_RADIO3 USING A_MIN       TYPE I
                        A_FIELDNAME TYPE C
                        A_CLIC1     TYPE C
                        A_CLIC2     TYPE C
                        A_CLIC3     TYPE C .
*----============-------------------------------------------------
* Check a radio box and enforce exact one pressed button.
*                  Like 'CHECK_RADIO2'.
*
  DATA L_SEL_COUNTER TYPE I.

  CLEAR L_SEL_COUNTER.
  IF A_CLIC1 = 'X'. ADD 1 TO L_SEL_COUNTER. ENDIF.
  IF A_CLIC2 = 'X'. ADD 1 TO L_SEL_COUNTER. ENDIF.
  IF A_CLIC3 = 'X'. ADD 1 TO L_SEL_COUNTER. ENDIF.

  IF A_MIN = 0.
    IF L_SEL_COUNTER > 1.
      CLEAR FCODE.
      " PERFORM SET_RADIO3 USING 0 A_CLIC1 A_CLIC2 A_CLIC3.
      SET CURSOR FIELD A_FIELDNAME.
*     'Bitte nur eine Auswahl ankreuzen'.
      MESSAGE E160.
    ENDIF.
  ELSE.
    IF L_SEL_COUNTER <> 1.
      CLEAR FCODE.
      " PERFORM SET_RADIO3 USING 0 A_CLIC1 A_CLIC2 A_CLIC3.
      SET CURSOR FIELD A_FIELDNAME.
*     'Bitte genau eine Auswahl ankreuzen'.
      MESSAGE E163.
    ENDIF.
  ENDIF.
ENDFORM. "CHECK_RADIO3

*&--------------------------------------------------------------------*
*&      Form  CHECK_RADIO4
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*      -->A_MIN      text
*      -->A_FIELDNAMEtext
*      -->A_CLIC1    text
*      -->A_CLIC2    text
*      -->A_CLIC3    text
*      -->A_CLIC4    text
*---------------------------------------------------------------------*
FORM CHECK_RADIO4 USING A_MIN       TYPE I
                        A_FIELDNAME TYPE C
                        A_CLIC1     TYPE C
                        A_CLIC2     TYPE C
                        A_CLIC3     TYPE C
                        A_CLIC4     TYPE C .
*----============------------------------------------------------
* Check a radio box and enforce exact one pressed button.
*                  Like 'CHECK_RADIO2'.
*
  DATA L_SEL_COUNTER TYPE I.

  CLEAR L_SEL_COUNTER.
  IF A_CLIC1 = 'X'. ADD 1 TO L_SEL_COUNTER. ENDIF.
  IF A_CLIC2 = 'X'. ADD 1 TO L_SEL_COUNTER. ENDIF.
  IF A_CLIC3 = 'X'. ADD 1 TO L_SEL_COUNTER. ENDIF.
  IF A_CLIC4 = 'X'. ADD 1 TO L_SEL_COUNTER. ENDIF.

  IF A_MIN = 0.
    IF L_SEL_COUNTER > 1.
      CLEAR FCODE.
      " PERFORM SET_RADIO4 USING 0 A_CLIC1 A_CLIC2 A_CLIC3 A_CLIC4.
      SET CURSOR FIELD A_FIELDNAME.
*     'Bitte nur eine Auswahl ankreuzen'.
      MESSAGE E160.
    ENDIF.
  ELSE.
    IF L_SEL_COUNTER <> 1.
      CLEAR FCODE.
      " PERFORM SET_RADIO4 USING 0 A_CLIC1 A_CLIC2 A_CLIC3 A_CLIC4.
      SET CURSOR FIELD A_FIELDNAME.
*     'Bitte genau eine Auswahl ankreuzen'.
      MESSAGE E163.
    ENDIF.
  ENDIF.
ENDFORM. "CHECK_RADIO4

*EJECT
*                         DYNPRO  2040  (popup)
*--------------------------------------------------------------------+
* ~Letzte_Meldung_des_Sendedämons~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !
* !_______________________________________________________________ ! !
* !_________ ________                                              ! !
* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !
*                                                                    !
* ~Letzte_Meldung_des_Sammeldämons~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !
* !_______________________________________________________________ ! !
* !_________ ________                                              ! !
* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !
*--------------------------------------------------------------------+

MODULE D2040_OUTPUT OUTPUT.
*------===============-
* Initialisierung des Dynpros 2040.

  DATA: S_MSG(80)
      , S_DATE TYPE D
      , S_TIME TYPE T
      , C_MSG(80)
      , C_DATE TYPE D
      , C_TIME TYPE T
      , SMDT(14)
      , SMNR(3)
      , SMP1(8)
      , SMP2(8)
      , CMDT(14)
      , CMNR(3)
      , CMP1(8)
      , CMP2(8)
      .

  CLEAR S_MSG.
  S_MSG+16 = 'C kernel too old for this function.'(640).
  C_MSG = S_MSG.

  CALL 'C_GET_SYSLOG_POS' ID 'SMDT' FIELD SMDT
                          ID 'SMNR' FIELD SMNR
                          ID 'SMP1' FIELD SMP1
                          ID 'SMP2' FIELD SMP2
                          ID 'CMDT' FIELD CMDT
                          ID 'CMNR' FIELD CMNR
                          ID 'CMP1' FIELD CMP1
                          ID 'CMP2' FIELD CMP2
                          .

  IF SMNR >< '   ' AND SMNR >< '000'.
    SELECT SINGLE * FROM T100
      WHERE SPRSL = SY-LANGU
      AND   ARBGB = 'SL'
      AND   MSGNR = SMNR    .
    IF SY-SUBRC = 0.
      S_MSG = T100-TEXT.
    ELSE.
      S_MSG = 'T100(&;&,&) missing'(501).
      REPLACE '&' WITH SMNR INTO S_MSG.
    ENDIF.
  ELSE.
    S_MSG = 'keine Meldung  & &'(502).
  ENDIF.
  REPLACE '&' WITH SMP1 INTO S_MSG.
  REPLACE '&' WITH SMP2 INTO S_MSG.

  IF CMNR >< '   ' AND CMNR >< '000'.
    SELECT SINGLE * FROM T100
      WHERE SPRSL = SY-LANGU
      AND   ARBGB = 'SL'
      AND   MSGNR = CMNR    .
    IF SY-SUBRC = 0.
      C_MSG = T100-TEXT.
    ELSE.
      C_MSG = 'T100(&;&,&) missing'(501).
      REPLACE '&' WITH CMNR INTO C_MSG.
    ENDIF.
  ELSE.
    C_MSG = 'keine Meldung  & &'(502).
  ENDIF.
  REPLACE '&' WITH CMP1 INTO C_MSG.
  REPLACE '&' WITH CMP2 INTO C_MSG.

  S_DATE = SMDT+0(8).
  S_TIME = SMDT+8(6).
  MOVE     S_MSG        TO D2040_SEND_MSG .
  WRITE S_DATE          TO D2040_SEND_DATE.
  WRITE S_TIME          TO D2040_SEND_TIME.

  C_DATE = CMDT+0(8).
  C_TIME = CMDT+8(6).
  MOVE     C_MSG        TO D2040_COLL_MSG .
  WRITE C_DATE          TO D2040_COLL_DATE.
  WRITE C_TIME          TO D2040_COLL_TIME.

  SET PF-STATUS '2040' EXCLUDING DISABLED_FUNCTIONS.
  CLEAR: FCODE.
  " SET TITLEBAR ??.

ENDMODULE. "D2040_OUTPUT

*---------------------------------------------------------------------*
*  MODULE D2040_INPUT INPUT
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
MODULE D2040_INPUT INPUT.
*------===============-
* Auswertung des Dynpros 2040.

  FCODE = SY-UCOMM. " Pop up dynpro has no FCODE field on its own.
  PERFORM DO_USER_INPUT_EARLY_ALV USING FCODE.
* ENTER will refresh, all other will leave.
  IF FCODE = SPACE OR FCODE = 'REFR'.
    "fine.
  ELSEIF FCODE = 'SDOC'.
    PERFORM SHOW_MSG_DOCU USING 'SL' SMNR.
  ELSEIF FCODE = 'CDOC'.
    PERFORM SHOW_MSG_DOCU USING 'SL' CMNR.
  ELSE.
    SET SCREEN 0.
    LEAVE SCREEN.
  ENDIF.

ENDMODULE. "D2040_INPUT.

*&--------------------------------------------------------------------*
*&      Form  SHOW_MSG_DOCU
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*      -->MSGAREA    text
*      -->MSGNUMBER  text
*---------------------------------------------------------------------*
FORM SHOW_MSG_DOCU USING MSGAREA MSGNUMBER.
  DATA MSGID(6).
  IDENTITY = 'NA'.
  CLEAR OBJECT.
  OBJECT      = MSGAREA.
  OBJECT+2(3) = MSGNUMBER.
  CALL FUNCTION 'DOCU_EXIST_CHECK'
    EXPORTING
      ID     = IDENTITY     " Dokuklasse Nachricht
      LANGU  = SY-LANGU
      OBJECT = OBJECT       " Eindeutiger Schlüssel
      TYP    = 'E'          " Endanwenderdoku
    EXCEPTIONS
      OTHERS = 1.
  IF SY-SUBRC = 0.
    CALL FUNCTION 'DOCU_CALL'
      EXPORTING
        ID            = IDENTITY     " Dokuklasse Nachricht
        LANGU         = SY-LANGU
        OBJECT        = OBJECT       " Eindeutiger Schlüssel
        TYP           = 'E'          " Endanwenderdoku
        DISPL_MODE    = '2'       " Nice output processing
        DISPL         = 'X'       " Display only
        USE_SEC_LANGU = 'X'    "A. Linke 403490/1995
        SUPPRESS_EDIT = 'X'.    "A. Linke 403490/1995
  ELSE.
    MSGID = MSGAREA.
    MSGID+3 = MSGNUMBER.                " format 'aa nnn'
    CALL FUNCTION 'POPUP_WITH_WARNING'
      EXPORTING
        TEXTLINE1 = 'Keine Dokumentation fuer Nachricht'(505)
        TEXTLINE2 = MSGID.
  ENDIF.
ENDFORM. "SHOW_MSG_DOCU


**** end of the dialog fraction: MODULEs and their FORMs.
*EJECT
**** begin of report fraction: FORMs



*EJECT
END-OF-SELECTION.
*================

FORM DO_END_OF_SELECTION_ALV.
* Write that this is the end and why it is the end.
  PERFORM WRITE_RECORDCNT_ALV.

  CASE END_REASON.
    WHEN 'E'.
      IF RECORDCNT-TOTAL <= 1.
        CLEAR GS_END.
        MOVE 'This SysLog file was empty'(007) TO GS_END-LINE.
        APPEND GS_END TO GT_END.
      ELSE.
        IF PRINT_EACH_LINE = SAP_YES.
          CLEAR GS_END.
          MOVE 'End of SysLog.'(008) TO GS_END-LINE.
          APPEND GS_END TO GT_END.
        ELSE.
          CLEAR: GS_END, GV_LINE.
         CONCATENATE 'The writing of the SysLog was aborted after'(005)
                               END_INFO INTO GV_LINE SEPARATED BY SPACE.
          MOVE GV_LINE TO GS_END-LINE.
          APPEND GS_END TO GT_END.
        ENDIF.
      ENDIF.
    WHEN 'F'.
      CLEAR: GS_END, GV_LINE.
      CONCATENATE 'The SysLog-File'(041) END_INFO
        'could not be opened.'(042) INTO GV_LINE SEPARATED BY SPACE.
      MOVE GV_LINE TO GS_END-LINE.
      APPEND GS_END TO GT_END.
    WHEN 'P'.
      CLEAR: GS_END, GV_LINE.
      CONCATENATE 'The writing of the SysLog was aborted after'(005)
             END_INFO 'pages.'(006) INTO GV_LINE SEPARATED BY SPACE.
      MOVE GV_LINE TO GS_END-LINE.
      APPEND GS_END TO GT_END.
  ENDCASE.

  IF CONTENTS_CHAPTER_EMPTY = SAP_NO.
    MOVE: SY-PAGNO        TO CONTENTS-END_PAGE,
          LAST_TIME_STAMP TO CONTENTS-END_TIME.
    APPEND CONTENTS.
  ENDIF.
  MOVE SAP_YES TO CONTENTS_CHAPTER_EMPTY.


* Inhibbit reusage of this data for future line selections.

  PERFORM CLEAR_ALL_HIDDEN.

* Do some statistics on the selected input data.

  IF SY-LINCT GT 0.
    LINES_ON_PAGE = SY-LINCT.
  ELSE.
    LINES_ON_PAGE = 18.
  ENDIF.

  PERFORM WRITE_INST_STAT_ALV USING LINES_ON_PAGE.

  PERFORM WRITE_MAND_STAT_ALV USING LINES_ON_PAGE.

  PERFORM WRITE_REPO_STAT_ALV USING LINES_ON_PAGE.

  PERFORM WRITE_TCOD_STAT_ALV USING LINES_ON_PAGE.

  PERFORM WRITE_BENU_STAT_ALV USING LINES_ON_PAGE.

  PERFORM WRITE_MSG_STAT_ALV  USING LINES_ON_PAGE.

  PERFORM WRITE_SNAP_STAT_ALV USING LINES_ON_PAGE.

* Write the table of contents.

  PAGE_TYPE = 'C'.
  CONTENTS_NEXT_START_PAGE = SY-PAGNO.
  NEW-PAGE NO-HEADING NO-TITLE.
  ADD 1 TO CONTENTS_NEXT_START_PAGE.

  MOVE: 'Contents            ;;'(049) TO CONTENTS-NAME,
        CONTENTS_NEXT_START_PAGE      TO CONTENTS-START_PAGE,
        CONTENTS_NEXT_START_PAGE      TO CONTENTS-END_PAGE.
  " Too hard to find the truth.
  CLEAR:                           CONTENTS-START_TIME,
                                   CONTENTS-END_TIME.
  APPEND CONTENTS.
  CONTENTS_CHAPTER_EMPTY = SAP_YES.

  DATA: LV_COUNTER TYPE I.
  DATA: LV_DATE TYPE D,
        LV_TIME TYPE T,
        LV_DATE1(10) TYPE C,
        LV_TIME1(8) TYPE C.

  LOOP AT CONTENTS.
    ADD 1 TO LV_COUNTER.
    MOVE CONTENTS-NAME TO GS_CONTENTS-NAME.
    MOVE LV_COUNTER TO GS_CONTENTS-START_PAGE.
        IF CONTENTS-START_PAGE <> CONTENTS-END_PAGE.
      MOVE CONTENTS-END_PAGE TO GS_CONTENTS-END_PAGE.
    ENDIF.
    IF CONTENTS-END_TIME <> SPACE.
      WRITE  CONTENTS-START_TIME+(8) TO LV_DATE.
      WRITE  CONTENTS-START_TIME+8(6) TO LV_TIME.
      WRITE  LV_DATE DD/MM/YYYY TO LV_DATE1.
      WRITE  LV_TIME TO LV_TIME1 USING EDIT MASK '__:__:__'.
      CONCATENATE LV_DATE1 LV_TIME1 INTO GS_CONTENTS-START_TIME
                                             SEPARATED BY SPACE.
      WRITE  CONTENTS-END_TIME+(8) TO LV_DATE.
      WRITE  CONTENTS-END_TIME+8(6) TO LV_TIME.
      WRITE  LV_DATE DD/MM/YYYY TO LV_DATE1.
      WRITE  LV_TIME TO LV_TIME1 USING EDIT MASK '__:__:__'.
      CONCATENATE LV_DATE1 LV_TIME1 INTO GS_CONTENTS-END_TIME
                                             SEPARATED BY SPACE.
    ENDIF.
    MOVE PAGE_TYPE TO GS_CONTENTS-HIDE_LINE_TYPE.
    APPEND GS_CONTENTS TO GT_CONTENTS.
    CLEAR GS_CONTENTS.
  ENDLOOP.

* Write that this is the final end.

  IN_MAIN_REPORT = 'N'.

ENDFORM. " DO_END_OF_SELECTION_ALV.

* Disabled here and called explicitely:  PERFORM DO_END_OF_SELECTION.


*EJECT
AT USER-COMMAND.
*===============
  if sy-ucomm = 'QUIT'.                  "hjl
    leave program.                       "hjl
  endif.                                 "hjl

  PERFORM DO_USER_INPUT_EARLY_ALV USING SY-UCOMM.
  PERFORM DO_USER_INPUT_LATE_ALV  USING SY-UCOMM.
*EJECT
* Store input data selection information
*---------------------------------------

FORM INIT_ME USING A_OUT_CPU_ID.
*
* Output: A_OUT_CPU_ID
*
  CALL 'C_GET_CPU_ID' ID 'CPUID' FIELD RAW_CPU_ID.
  CPU_ID       = RAW_CPU_ID.       "Set global in this program
  "also. In case, that form was called
  "externally.
  A_OUT_CPU_ID = RAW_CPU_ID.

  PAGE_TYPE       = 'D'.      " D = DYNPRO header page
  DATE_OF_PAGE    = '19000101000000'.
  PRINT_EACH_LINE = SAP_YES.
  END_REASON      = '-'.      " Reason of end of report: None yet
  FIRSTTIME       = '1'.      " '1' on start of first main loop
*FB READ_LOOP       = '1'.      " '1' during first main loop
  IN_MAIN_REPORT  = 'Y'.      " 'Y' during wrinting of main

  CLEAR RECORDCNT.

ENDFORM.                    "INIT_ME


*EJECT
FORM INIT_LAYOUT.
  " nothing to do.
ENDFORM. " INIT_LAYOUT.

*&--------------------------------------------------------------------*
*&      Form  WRITE_DYNPRO_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM WRITE_DYNPRO_ALV.
* Print simulated DYNPRO screen.
*

  CALL FUNCTION 'RSLG_WRITE_SEL_ALV'
    EXPORTING
      EXPERT_MODE = EXPERT_MODE
    TABLES
      GT_TOP      = GT_TEMP.

  LOOP AT GT_TEMP INTO GS_TEMP.
    MOVE-CORRESPONDING GS_TEMP TO GS_TOP.
    APPEND GS_TOP TO GT_TOP.
  ENDLOOP.
*  APPEND LINES OF GT_TEMP TO GT_TOP.
  REFRESH GT_TEMP.

  CALL FUNCTION 'RSLG_WRITE_LAYOUT_ALV'
    EXPORTING
      EXPERT_MODE = EXPERT_MODE
    TABLES
      GT_TOP      = GT_TEMP.

  LOOP AT GT_TEMP INTO GS_TEMP.
    MOVE-CORRESPONDING GS_TEMP TO GS_TOP.
    APPEND GS_TOP TO GT_TOP.
  ENDLOOP.
*  APPEND LINES OF GT_TEMP TO GT_TOP.
  REFRESH GT_TEMP.

  CALL FUNCTION 'RSLG_WRITE_FILEINFO_ALV'
    EXPORTING
      EXPERT_MODE = EXPERT_MODE
    TABLES
      GT_TOP      = GT_TEMP.

  LOOP AT GT_TEMP INTO GS_TEMP.
    MOVE-CORRESPONDING GS_TEMP TO GS_TOP.
    APPEND GS_TOP TO GT_TOP.
  ENDLOOP.
*  APPEND LINES OF GT_TEMP TO GT_TOP.
  REFRESH GT_TEMP.

  CLEAR GS_TOP.
  APPEND GS_TOP TO GT_TOP.

  MOVE: 'Selektionskriterien'(058) TO CONTENTS-NAME,
        1                          TO CONTENTS-START_PAGE,
        1                          TO CONTENTS-END_PAGE.
  CLEAR:                        CONTENTS-START_TIME,
                                CONTENTS-END_TIME.
  APPEND CONTENTS.
  CONTENTS_CHAPTER_EMPTY = SAP_YES.

ENDFORM. "WRITE_DYNPRO_ALV


FORM READ_SYSLOG_ALV.

*----==================-
  DATA: LV_TEMP(10) TYPE C.
  MOVE DY_TASK_SEL_TYP TO TA-SELTYP.
  MOVE DY_TASK_SEL_NUM TO TA-SELNUM.
  PERCENTAGE_DONE = 1.
  CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
    EXPORTING
      PERCENTAGE = PERCENTAGE_DONE
      TEXT       = 'Dateien lesen'(690).

  CALL FUNCTION 'RSLG_SEL_GET_WHICHLOG_ALV'
    IMPORTING
      FILE = TA___WHICHLOG.

  IF TA___WHICHLOG <> LAST_TA_WHICHLOG.
    ABOUT_OLD_DATA = 'N'.
  ENDIF.

  CASE ABOUT_OLD_DATA.
    WHEN '?'.
      CALL SCREEN 321 STARTING AT 16 8 ENDING AT 65 16.
      NEW-PAGE LINE-COUNT SY-LINCT.  "kwkwkwkwkwkwkwkwkwkwkwkw
  ENDCASE.

  IF ABOUT_OLD_DATA = 'N'.
    REFRESH ENTRIESTAB.
    REFRESH REC_CNTS.
  ENDIF.
  IF ABOUT_OLD_DATA = 'N' OR ABOUT_OLD_DATA = 'A'.
    IF TA-WHICHLOG = REP_ON_REMOTEL.
      CLEAR REC_CNTS.
      MOVE DY_TASK_SEL_TYP TO TA-SELTYP.
      MOVE DY_TASK_SEL_NUM TO TA-SELNUM.
      CALL FUNCTION 'RSLG_READ_FILE_ALV' DESTINATION TA-RFCDEST
        EXPORTING
          FILE_INFO             = SYSLOG_FILE
          SELECTION             = TA
        IMPORTING
          END_REASON            = END_REASON
          END_INFO              = END_INFO
          LOST_ENTRIES          = FC-ENTRIES_N10
          OLD_POS               = DY_2000_OLD_POS_N10
          OLD_WC                = DY_2000_OLD_WC_N6
          CUR_POS               = FC-POS_N10
          CUR_WC                = FC-WRAPCOUNT_N6
          COUNTERS              = RECORDCNT
        TABLES
          SYSLOG_IN_TABLE       = ENTRIESTAB
          GT_TOP                = GT_TEMP
        EXCEPTIONS
          SYSTEM_FAILURE        = 2  MESSAGE LAST_RFC_MESS
          COMMUNICATION_FAILURE = 3  MESSAGE LAST_RFC_MESS.
      IF SY-SUBRC >< 0.
        REC_CNTS-ERRRC   = SY-SUBRC.
        REC_CNTS-ERRMESS = LAST_RFC_MESS.
      ENDIF.

      IF NOT GT_TEMP IS INITIAL.
          LOOP AT GT_TEMP INTO GS_TEMP.
            MOVE-CORRESPONDING GS_TEMP TO GS_TOP.
            APPEND GS_TOP TO GT_TOP.
          ENDLOOP.
*        APPEND LINES OF GT_TEMP TO GT_TOP.
        REFRESH GT_TEMP.
      ENDIF.

      MOVE 'R'                     TO REC_CNTS-KIND.
      MOVE-CORRESPONDING TA        TO REC_CNTS.
      MOVE-CORRESPONDING RECORDCNT TO REC_CNTS.
      APPEND REC_CNTS.
      CLEAR RECORDCNT.
    ELSEIF TA-WHICHLOG = REP_ON_REMOTEA.
      " Call all instances...

      PERCENTAGE_DONE = 2.
      CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
        EXPORTING
          PERCENTAGE = PERCENTAGE_DONE
          TEXT       = 'Applikationsserver ermitteln'(692).

      PERFORM FIND_ALL_DESTS.

*     Now start working and ask all active applications servers for
*     sending their SysLog data to me.
      DESCRIBE TABLE ALL_DESTS LINES NUMBER_OF_DESTS.
      DESTS_DONE = 0.
      LOOP AT ALL_DESTS.
        IF ALL_DESTS-ACCESS >< 0.
          CLEAR REC_CNTS.
          MOVE 'R'              TO REC_CNTS-KIND.
          MOVE-CORRESPONDING TA TO REC_CNTS.
          MOVE ALL_DESTS-ACCESS TO REC_CNTS-ERRRC.
          MOVE ALL_DESTS-RFCDEST TO REC_CNTS-RFCDEST.
          APPEND REC_CNTS.
        ELSE.

          PERCENTAGE_DONE = 5 + ( 75 * DESTS_DONE ) / NUMBER_OF_DESTS.
          CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
            EXPORTING
              PERCENTAGE = PERCENTAGE_DONE
              TEXT       = ALL_DESTS-RFCDEST.
          TA-RFCDEST = ALL_DESTS-RFCDEST.

          CLEAR REC_CNTS.
          MOVE 'R'              TO REC_CNTS-KIND.
          MOVE-CORRESPONDING TA TO REC_CNTS.

*         * Get names of SysLog files and file positions.
          CALL FUNCTION 'RSLG_FILEINFO_INIT_ALV'
            DESTINATION ALL_DESTS-RFCDEST
            EXPORTING
              WHICHLOG              = TA-WHICHLOG
            IMPORTING
              INFO_AFTER            = SYSLOG_FILE
            EXCEPTIONS
              SYSTEM_FAILURE        = 2  MESSAGE LAST_RFC_MESS
              COMMUNICATION_FAILURE = 3  MESSAGE LAST_RFC_MESS.
          IF SY-SUBRC >< 0.
            REC_CNTS-ERRRC   = SY-SUBRC.
            REC_CNTS-ERRMESS = LAST_RFC_MESS.
          ELSE.

*           * Read that file
            REFRESH ENTRIESTAB_2.
            " Use auxiliary table, so that the growing main table is
            " not copied to each computer and than back again.
            CALL FUNCTION 'RSLG_READ_FILE_ALV'
              DESTINATION ALL_DESTS-RFCDEST
              EXPORTING
                FILE_INFO             = SYSLOG_FILE
                SELECTION             = TA
              IMPORTING
                END_REASON            = END_REASON
                END_INFO              = END_INFO
                LOST_ENTRIES          = FC-ENTRIES_N10
                OLD_POS               = DY_2000_OLD_POS_N10
                OLD_WC                = DY_2000_OLD_WC_N6
                CUR_POS               = FC-POS_N10
                CUR_WC                = FC-WRAPCOUNT_N6
                COUNTERS              = RECORDCNT
              TABLES
                SYSLOG_IN_TABLE       = ENTRIESTAB_2
                GT_TOP                = GT_TEMP
              EXCEPTIONS
                SYSTEM_FAILURE        = 2  MESSAGE LAST_RFC_MESS
                COMMUNICATION_FAILURE = 3  MESSAGE LAST_RFC_MESS.
            IF SY-SUBRC >< 0.
              REC_CNTS-ERRRC   = SY-SUBRC.
              REC_CNTS-ERRMESS = LAST_RFC_MESS.
            ELSE.
              LOOP AT ENTRIESTAB_2.
                ENTRIESTAB = ENTRIESTAB_2.
                APPEND ENTRIESTAB.
              ENDLOOP.
              MOVE-CORRESPONDING RECORDCNT   TO REC_CNTS.
            ENDIF.

            IF NOT GT_TEMP IS INITIAL.
                LOOP AT GT_TEMP INTO GS_TEMP.
                  MOVE-CORRESPONDING GS_TEMP TO GS_TOP.
                  APPEND GS_TOP TO GT_TOP.
                ENDLOOP.
*              APPEND LINES OF GT_TEMP TO GT_TOP.
              REFRESH GT_TEMP.
            ENDIF.

          ENDIF.
          APPEND REC_CNTS.
          CLEAR RECORDCNT.

        ENDIF.
        ADD 1 TO DESTS_DONE.
      ENDLOOP.

    ELSE.
      CLEAR REC_CNTS.
      MOVE 'R'              TO REC_CNTS-KIND.
      MOVE-CORRESPONDING TA TO REC_CNTS.

      CALL FUNCTION 'RSLG_READ_FILE_ALV'
        EXPORTING
          FILE_INFO       = SYSLOG_FILE
          SELECTION       = TA
        IMPORTING
          END_REASON      = END_REASON
          END_INFO        = END_INFO
          LOST_ENTRIES    = FC-ENTRIES_N10
          OLD_POS         = DY_2000_OLD_POS_N10
          OLD_WC          = DY_2000_OLD_WC_N6
          CUR_POS         = FC-POS_N10
          CUR_WC          = FC-WRAPCOUNT_N6
          COUNTERS        = RECORDCNT
        TABLES
          SYSLOG_IN_TABLE = ENTRIESTAB
          GT_TOP          = GT_TEMP.
      IF NOT GT_TEMP IS INITIAL.
          LOOP AT GT_TEMP INTO GS_TEMP.
            MOVE-CORRESPONDING GS_TEMP TO GS_TOP.
            APPEND GS_TOP TO GT_TOP.
          ENDLOOP.
*        APPEND LINES OF GT_TEMP TO GT_TOP.
        REFRESH GT_TEMP.
      ENDIF.

      MOVE-CORRESPONDING RECORDCNT   TO REC_CNTS.
      APPEND REC_CNTS.
      CLEAR RECORDCNT.
    ENDIF. " RFC or local
    FC-ENTRIES      = FC-ENTRIES_N10.
    DY_2000_OLD_POS = DY_2000_OLD_POS_N10.
    DY_2000_OLD_WC  = DY_2000_OLD_WC_N6.
    FC-POS          = FC-POS_N10.
    FC-WRAPCOUNT    = FC-WRAPCOUNT_N6.

    MOVE-CORRESPONDING TA TO LAST_TA.
    MOVE TA___WHICHLOG      TO LAST_TA_WHICHLOG.

    IF FC-ENTRIES <> 0.
      IF SURPRESS_POPUPS = ' '.
        CALL SCREEN 2000 STARTING AT 10 5 ENDING AT 69 16.
        NEW-PAGE LINE-COUNT SY-LINCT.  "kwkwkwkwkwkwkwkwkwkwkwkw
      ELSE.

        CLEAR GS_TOP.
        APPEND GS_TOP TO GT_TOP.
        MOVE 'Position der SysLog-Datei zu Beginn der Auswertung'(700)
                                                        TO GS_TOP-LINE.
        APPEND GS_TOP TO GT_TOP.
        CLEAR GS_TOP.

        CONCATENATE 'Anzahl Bytes'(702) DY_2000_OLD_POS INTO GV_LINE
                                                  SEPARATED BY SPACE.
        MOVE GV_LINE TO GS_TOP-LINE.
        APPEND GS_TOP TO GT_TOP.
        CLEAR: GS_TOP, GV_LINE.

        CONCATENATE 'Anzahl Überläufe'(701) DY_2000_OLD_WC INTO GV_LINE
                                                    SEPARATED BY SPACE.

        MOVE GV_LINE TO GS_TOP-LINE.
        APPEND GS_TOP TO GT_TOP.
        CLEAR: GS_TOP, GV_LINE.

        APPEND GS_TOP TO GT_TOP.

        MOVE 'Derzeitige Position'(703) TO GS_TOP-LINE.
        APPEND GS_TOP TO GT_TOP.
        CLEAR: GS_TOP.

        MOVE FC-POS TO LV_TEMP.
        CONCATENATE 'Anzahl Bytes'(702) LV_TEMP INTO GV_LINE SEPARATED
                                                         BY SPACE.
        MOVE GV_LINE TO GS_TOP-LINE.
        APPEND GS_TOP TO GT_TOP.
        CLEAR: GS_TOP, GV_LINE.

        MOVE FC-WRAPCOUNT TO LV_TEMP.
        CONCATENATE 'Anzahl Überläufe'(701) LV_TEMP INTO GV_LINE
                                              SEPARATED BY SPACE.
        MOVE GV_LINE TO GS_TOP-LINE.
        APPEND GS_TOP TO GT_TOP.
        CLEAR: GS_TOP, GV_LINE.

        APPEND GS_TOP TO GT_TOP.

        MOVE 'Nicht in der Auswertung'(704) TO GS_TOP-LINE.
        APPEND GS_TOP TO GT_TOP.
        CLEAR: GS_TOP.

        MOVE FC-ENTRIES TO LV_tEMP.
        CONCATENATE 'Anzahl neuer Einträge'(705) LV_TEMP INTO
                                    GV_LINE SEPARATED BY SPACE.

        MOVE GV_LINE TO GS_TOP-LINE.
        APPEND GS_TOP TO GT_TOP.
        CLEAR: GS_TOP, GV_LINE.

      ENDIF. " with / without popup
    ENDIF.

*   I have done some work.
*   I did not update anything in the database, but I spent some
*   time and will tell the ABAP/4 processor, that I finished a
*   step and that I am still alive.
*
    COMMIT WORK.

  ENDIF.

  PERCENTAGE_DONE = 80.
  CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
    EXPORTING
      PERCENTAGE = PERCENTAGE_DONE
      TEXT       = SPACE.

ENDFORM. "READ_SYSLOG_ALV

*EJECT
FORM FIND_ALL_DESTS.

  REFRESH ALL_DESTS.              "to get a clean slate
  CALL FUNCTION 'RFC_GET_LOCAL_DESTINATIONS'
       TABLES
         LOCALDEST = LOCAL_DESTS
      "EXCEPTIONS
      "  NOT_AVAILABLE =
       .

* Get the list of all applications servers, which are currently
* active.
  LOOP AT LOCAL_DESTS.
    MOVE-CORRESPONDING LOCAL_DESTS TO ALL_DESTS.
    MOVE               0           TO ALL_DESTS-ACCESS.
    APPEND ALL_DESTS.
  ENDLOOP.
  REFRESH LOCAL_DESTS. " No longer needed.
  FREE    LOCAL_DESTS.

* Get the list of all applications servers, which are known to
* the computer center management system.
  CALL FUNCTION 'RZL_GET_BA_DESCR'
    EXPORTING
      BETRIEBSART_NAME           = ' ' "all
    TABLES
      INSTANCE_DESCRIPTION_TABLE = I_SPFID.

* Note down those applications servers, which are known to the
* computer center management system, but which are currently not
* active.
  LOOP AT I_SPFID.
    ALL_DESTS-RFCDEST = I_SPFID-APSERVER.
    READ TABLE ALL_DESTS.
    IF SY-SUBRC >< 0.
      MOVE-CORRESPONDING I_SPFID          TO ALL_DESTS.
      MOVE               I_SPFID-APSERVER TO ALL_DESTS-RFCDEST.
      MOVE               4                TO ALL_DESTS-ACCESS.
      APPEND ALL_DESTS.
    ENDIF.
  ENDLOOP.
  REFRESH I_SPFID. " No longer needed.
  FREE    I_SPFID. " No longer needed.

ENDFORM. "FIND_ALL_DESTS

*EJECT
FORM FILL_IN_CLASID_ALV.

  READ TABLE ENTRIESTAB INDEX 1.
  IF ENTRIESTAB-CLASID >< SPACE. EXIT. ENDIF.

  READ TABLE ENTRIESTAB INDEX 5.
  IF ENTRIESTAB-CLASID >< SPACE. EXIT. ENDIF.

  READ TABLE ENTRIESTAB INDEX 20.
  IF ENTRIESTAB-CLASID >< SPACE. EXIT. ENDIF.

  PERFORM FILL_IN_DEVC_CLASID_ALV. "That will do both.

ENDFORM. "FILL_IN_CLASID_ALV


FORM FILL_IN_CLASID.

  READ TABLE ENTRIESTAB INDEX 1.
  IF ENTRIESTAB-CLASID >< SPACE. EXIT. ENDIF.

  READ TABLE ENTRIESTAB INDEX 5.
  IF ENTRIESTAB-CLASID >< SPACE. EXIT. ENDIF.

  READ TABLE ENTRIESTAB INDEX 20.
  IF ENTRIESTAB-CLASID >< SPACE. EXIT. ENDIF.

  PERFORM FILL_IN_DEVC_CLASID. "That will do both.

ENDFORM. "FILL_IN_CLASID

*&--------------------------------------------------------------------*
*&      Form  FILL_IN_DEVC_CLASID
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM FILL_IN_DEVC_CLASID.

  LOOP AT ENTRIESTAB.
    IF  ENTRIESTAB-AREA  >< SPACE
    AND ENTRIESTAB-SUBID >< SPACE.
      CALL FUNCTION 'RSLG_TAB_CACHE_ACCESS'
        EXPORTING
          AREA        = ENTRIESTAB-AREA
          SUBID       = ENTRIESTAB-SUBID
        IMPORTING
          CACHE_ENTRY = CUR_SYSLOGTAB.
      ENTRIESTAB-CLASID   = CUR_SYSLOGTAB-CLASID.
      ENTRIESTAB-DEVCLASS = CUR_SYSLOGTAB-DEVCLASS.
      ENTRIESTAB-MONBEW   = CUR_SYSLOGTAB-MONBEW.
      ENTRIESTAB-MONKAT   = CUR_SYSLOGTAB-MONKAT.
      MODIFY ENTRIESTAB.
    ENDIF.
  ENDLOOP.

ENDFORM. "FILL_IN_DEVC_CLASID

*&--------------------------------------------------------------------*
*&      Form  FILL_IN_DEVCLASS_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM FILL_IN_DEVCLASS_ALV.

  READ TABLE ENTRIESTAB INDEX 1.
  IF ENTRIESTAB-DEVCLASS >< SPACE. EXIT. ENDIF.

  READ TABLE ENTRIESTAB INDEX 5.
  IF ENTRIESTAB-DEVCLASS >< SPACE. EXIT. ENDIF.

  READ TABLE ENTRIESTAB INDEX 20.
  IF ENTRIESTAB-DEVCLASS >< SPACE. EXIT. ENDIF.

  PERFORM FILL_IN_DEVC_CLASID_ALV. "That will do both.

ENDFORM. "FILL_IN_DEVCLASS_ALV

FORM FILL_IN_DEVCLASS.

  READ TABLE ENTRIESTAB INDEX 1.
  IF ENTRIESTAB-DEVCLASS >< SPACE. EXIT. ENDIF.

  READ TABLE ENTRIESTAB INDEX 5.
  IF ENTRIESTAB-DEVCLASS >< SPACE. EXIT. ENDIF.

  READ TABLE ENTRIESTAB INDEX 20.
  IF ENTRIESTAB-DEVCLASS >< SPACE. EXIT. ENDIF.

  PERFORM FILL_IN_DEVC_CLASID. "That will do both.
ENDFORM. "FILL_IN_DEVCLASS


*&--------------------------------------------------------------------*
*&      Form  FILL_IN_DEVC_CLASID_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM FILL_IN_DEVC_CLASID_ALV.

  LOOP AT ENTRIESTAB.
    IF  ENTRIESTAB-AREA  >< SPACE
    AND ENTRIESTAB-SUBID >< SPACE.
      CALL FUNCTION 'RSLG_TAB_CACHE_ACCESS_ALV'
        EXPORTING
          AREA        = ENTRIESTAB-AREA
          SUBID       = ENTRIESTAB-SUBID
        IMPORTING
          CACHE_ENTRY = CUR_SYSLOGTAB.
      ENTRIESTAB-CLASID   = CUR_SYSLOGTAB-CLASID.
      ENTRIESTAB-DEVCLASS = CUR_SYSLOGTAB-DEVCLASS.
      ENTRIESTAB-MONBEW   = CUR_SYSLOGTAB-MONBEW.
      ENTRIESTAB-MONKAT   = CUR_SYSLOGTAB-MONKAT.
      MODIFY ENTRIESTAB.
    ENDIF.
  ENDLOOP.

ENDFORM. "FILL_IN_DEVC_CLASID_ALV

*EJECT
FORM WRITE_LIST_ABOUT_SYSLOG_ALV.
*----==================-

  CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
    EXPORTING
      PERCENTAGE = PERCENTAGE_DONE
      TEXT       = 'Liste aufbereiten'(691).

  CLEAR RECORDCNT.

  CALL FUNCTION 'RSLG_SEL_DUMP_ALV'
    IMPORTING
      ITSELF = TA.
  CALL FUNCTION 'RSLG_LAYOUT_DUMP_ALV'
    IMPORTING
      ITSELF = LAYOUT.

  IF LAYOUT-NEED_SORT <> CUR_SORT.
    CASE LAYOUT-NEED_SORT.
      WHEN SORT_INST.                    "                       Rechner
        SORT ENTRIESTAB BY sender_id POS_CREATT FILE_NO POS.
        PERFORM SORT_INST_SORT_BUILD_ALV CHANGING GT_SORT.
        if SORT_TO_PC > 0. perform WRITE_SORT_TO_PC. endif.
      WHEN SORT_DEVCLASS.                "            Entwicklungsklasse
        PERFORM FILL_IN_DEVCLASS_ALV.
        SORT ENTRIESTAB BY DEVCLASS POS_CREATT FILE_NO POS.
        PERFORM SORT_DEVCLASS_SORT_BUILD_ALV CHANGING GT_SORT.
        if SORT_TO_PC > 0. perform WRITE_SORT_TO_PC. endif.
      WHEN SORT_FILE.                    "                  Schreibfolge
        SORT ENTRIESTAB STABLE BY  POS_CREATT SENDER_ID.
        PERFORM SORT_FILE_SORT_BUILD_ALV CHANGING GT_SORT.
        if SORT_TO_PC > 0. perform WRITE_SORT_TO_PC. endif.
      WHEN SORT_TABE.                    "               Meldungskennung
        SORT ENTRIESTAB BY AREA SUBID POS_CREATT FILE_NO POS.
        PERFORM SORT_A_S_SORT_BUILD_ALV CHANGING GT_SORT.
        if SORT_TO_PC > 0. perform WRITE_SORT_TO_PC. endif.
      WHEN SORT_CLASID.                  "                 Problemklasse
        PERFORM FILL_IN_CLASID_ALV.
        SORT ENTRIESTAB BY CLASID POS_CREATT FILE_NO POS.
        PERFORM SORT_CLASID_SORT_BUILD_ALV CHANGING GT_SORT.
        if SORT_TO_PC > ZERO. perform WRITE_SORT_TO_PC. endif.
      WHEN SORT_TIME.                    "                       Uhrzeit
        SORT ENTRIESTAB BY POS_CREATT FILE_NO POS.
        PERFORM SORT_TIME_SORT_BUILD_ALV CHANGING GT_SORT.
        if SORT_TO_PC > ZERO. perform WRITE_SORT_TO_PC. endif.
      WHEN SORT_FTYP.                    "                   Meldungstyp
        SORT ENTRIESTAB BY slgftyp POS_CREATT FILE_NO POS.
        PERFORM SORT_FTYP_SORT_BUILD_ALV CHANGING GT_SORT.
        if SORT_TO_PC > ZERO. perform WRITE_SORT_TO_PC. endif.
      WHEN SORT_TTYP.                    "                       Tasktyp
        SORT ENTRIESTAB BY slgttyp POS_CREATT FILE_NO POS.
        PERFORM SORT_TTYP_SORT_BUILD_ALV CHANGING GT_SORT.
        if SORT_TO_PC > ZERO. perform WRITE_SORT_TO_PC. endif.

      WHEN OTHERS.
        MESSAGE X175 WITH 'LAYOUT-NEED_SORT' LAYOUT-NEED_SORT '?'.
    ENDCASE. "LAYOUT-NEED_SORT
    CUR_SORT = LAYOUT-NEED_SORT.

*   I have done some work.
*   I did not update anything in the database, but I spent some
*   time and will tell the ABAP/4 processor, that I finished a
*   step and that I am still alive.
*
    COMMIT WORK.
  ENDIF.


  COMMIT_CNT = 1000.
  READ TABLE ENTRIESTAB INDEX 1.                                   "xxx
  OLD_SENDER_ID = ENTRIESTAB-SENDER_ID.                            "xxx
  LOOP AT ENTRIESTAB.

    ENTRIESTAB_IX = SY-TABIX.
    ADD 1 TO RECORDCNT-TOTAL.

    IF SY-PAGNO > LAYOUT-MAXPAG OR RECORDCNT-PRINTED > LAYOUT-MAXLIN.
      END_REASON = 'P'. " page limit reached.
      CLEAR END_INFO.
      END_INFO(9) = LAYOUT-MAXPAG.
      IF PRINT_EACH_LINE = SAP_YES.
        " if still on, then switch of.
        PRINT_EACH_LINE = SAP_NO.
      ENDIF.
    ENDIF.

    CUR_SYSLOGTAB_FILLED = ' '.
    AN_ENTRY_FILLED      = ' '.
    PERFORM PREP_SEL_CHECK(SAPLSLO2).   " AN_ENTRY_FILLED = ' '.
    " SEL_CHECK has own instance
    " of AN_ENTRY_FILLED.
    PERFORM SEL_CHECK(SAPLSLO2)
                      TABLES ENTRIESTAB
                      USING SEL
                            SEL_DURING_RESCAN
                            TA
                            CUR_SYSLOGTAB
                            CUR_SYSLOGTAB_FILLED
                            RECORDCNT.
    IF TA-PARAREC             = 'X'
       AND SEL                = 'J'
       AND ENTRIESTAB-SLGFTYP = RSLGTYPA.
      MOVE ENTRIESTAB TO H_ENTRY_PARA_REC.
      SEL = ' '.
    ENDIF.
    IF SEL EQ 'J'.
      IF TA-PARAREC = 'X' AND H_ENTRY_PARA_REC NE SPACE.
         MOVE SY-TABIX TO ACT_TAB_IND.
         SUBTRACT 1 FROM ACT_TAB_IND.
         IF ACT_TAB_IND = 0. ACT_TAB_IND = 1.  ENDIF.
         DO.
            READ TABLE ENTRIESTAB INDEX ACT_TAB_IND.
            IF ENTRIESTAB-SLGFTYP <> RSLGTYpa.
               exit.
            ELSE.
               SUBTRACT 1 FROM ACT_TAB_IND.
               IF ACT_TAB_IND = 0.  EXIT.   ENDIF.
            ENDIF.
         ENDDO.
         CALL FUNCTION 'RSLG_SEL_GET_WHICHLOG_ALV'
                  IMPORTING FILE = TA___WHICHLOG.
         ACT_TAB_IND = ACT_TAB_IND + 1.
         DO.
            READ TABLE ENTRIESTAB INDEX ACT_TAB_IND.
            PERFORM WRITE_WHOLE_ENTRY_ALV USING TA___WHICHLOG.
            AN_ENTRY_FILLED = ' '.
            ADD 1 TO RECORDCNT-GOOD.
            IF ENTRIESTAB-SLGFTYP <> RSLGTYpa.
               EXIT.
            ELSE.
               ACT_TAB_IND = ACT_TAB_IND + 1.
            ENDIF.
         ENDDO.
         MOVE SPACE TO H_ENTRY_PARA_REC.
      ELSE.
        ADD 1 TO RECORDCNT-GOOD.
        CALL FUNCTION 'RSLG_SEL_GET_WHICHLOG_ALV'
          IMPORTING
            FILE = TA___WHICHLOG.
        PERFORM WRITE_WHOLE_ENTRY_ALV USING TA___WHICHLOG.
      ENDIF.
    ELSE.
      "DEB WRITE / 'not selected.'(043). "DEB
    ENDIF.

*   I have done some work.
*   I did not update anything in the database, but I spent some
*   time and will tell the ABAP/4 processor, that I am still alive.
*
    SUBTRACT 1 FROM COMMIT_CNT.
    IF COMMIT_CNT < 1.
      COMMIT WORK.
      COMMIT_CNT = 1000.
    ENDIF.

  ENDLOOP. "ENTRIESTAB

  CLEAR REC_CNTS.
  MOVE 'P'                     TO REC_CNTS-KIND.
  MOVE-CORRESPONDING TA        TO REC_CNTS.
  MOVE-CORRESPONDING RECORDCNT TO REC_CNTS.
  APPEND REC_CNTS.
  " Do not CLEAR RECORDCNT here. It is needed for statistics !

  PERCENTAGE_DONE = 100.
  CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
    EXPORTING
      PERCENTAGE = PERCENTAGE_DONE
      TEXT       = SPACE.
  PERCENTAGE_DONE = 0.

ENDFORM. " WRITE_LIST_ABOUT_SYSLOG_ALV.

*EJECT

FORM WRITE_WHOLE_ENTRY_ALV USING A_WHICHLOG.
************************************************************************
*    WRITE_WHOLE_ENTRY - Display one SysLog entry
*
*    Input ENTRIESTAB      -or-
*    Input AN_ENTRY
*    Input FIRSTTIME
*    Input CTYP_BYTE
*
*    Global: <nearly all ! >
*    Global: ENTRIESTAB-AREA&SUBID   (read_only)
*
*    Output: <nearly all ! >
*
*    Effect: The current entry is written.
*            What does not fit into 79 columns is HIDdEn.
*            The corresponding statistics are updated (if wanted).
*

  IF A_WHICHLOG = REP_ON_CENTRAL.          "?? REP_ON_REMOTEA
    HIDE_LINE_TYPE = 'Z'.       " N(ormal)
  ELSE.
    HIDE_LINE_TYPE = 'N'.            " N(ormal)
  ENDIF.

* On first call: Init some variables and start a data entry in the
* table of contents.
* do not allow for slogmode char greater 9
* this field is only 1 char
* the default system parameter = 6


  IF A_WHICHLOG >< REP_ON_CENTRAL.
*   (PER)FORM FILL_AN_ENTRY.
    IF AN_ENTRY_FILLED <> 'X'.
      AN_ENTRY = ENTRIESTAB-centdata.
* vsq2004-02-26
      IF AN_ENTRY-slgmode < '0' or AN_ENTRY-slgmode > '9'.
        AN_ENTRY-slgmode = '9'.
      ENDIF.
      AN_ENTRY_FILLED = 'X'.
    ENDIF.

    ENTRIESTAB-POS_CREATT = AN_ENTRY-slgdattim.
  ENDIF.

  IF FIRSTTIME <> 'N'.                 " Save Timestamp
    LAST_TIME_STAMP = ENTRIESTAB-POS_CREATT.
    IF A_WHICHLOG = REP_ON_CENTRAL.
      PAGE_TYPE = 'Z'.            " N(ormal)
    ELSE.
      PAGE_TYPE = 'N'.            " N(ormal)
    ENDIF.
    CONTENTS_NEXT_START_PAGE = SY-PAGNO.
    IF FIRSTTIME = '1'.
*      NEW-PAGE NO-HEADING NO-TITLE.
      ADD 1 TO CONTENTS_NEXT_START_PAGE.
      " SY-PAGNO will be incremented not before the first WRITE.
    ENDIF.
    FIRSTTIME = 'N'.            " N(o)
    MOVE: CONTENTS_DATA_NAME       TO CONTENTS-NAME,
          CONTENTS_NEXT_START_PAGE TO CONTENTS-START_PAGE,
          LAST_TIME_STAMP          TO CONTENTS-START_TIME.
    " SY-PAGNO will be incremented not before the first WRITE.
  ENDIF.

* If we crossed a day boundary, then start a new page and start a new
* entry in the table of contents.

  IF  LAYOUT-W_TIT_DATE = SAP_YES
  AND ENTRIESTAB-POS_CREATT(8) <> DATE_OF_PAGE(8).   "#EC PORTABLE  xxx
* OR old_sender_id <> entriestab-sender_id.                        "xxx
    OLD_SENDER_ID = ENTRIESTAB-SENDER_ID.                          "xxx
    IF CONTENTS_CHAPTER_EMPTY = SAP_NO.
      MOVE SY-PAGNO     TO CONTENTS-END_PAGE.
      MOVE DATE_OF_PAGE TO CONTENTS-END_TIME.
      APPEND CONTENTS.
    ENDIF.
    LAST_TIME_STAMP = ENTRIESTAB-POS_CREATT.
    DATE_OF_PAGE    = ENTRIESTAB-POS_CREATT.
    CONTENTS_NEXT_START_PAGE = SY-PAGNO.
    IF CONTENTS_CHAPTER_EMPTY = SAP_NO.
      NEW-PAGE NO-HEADING NO-TITLE.
      ADD 1 TO CONTENTS_NEXT_START_PAGE.
      " SY-PAGNO will be incremented not before the first WRITE.
    ENDIF.
    MOVE: CONTENTS_DATA_NAME       TO CONTENTS-NAME,
          CONTENTS_NEXT_START_PAGE TO CONTENTS-START_PAGE,
          LAST_TIME_STAMP          TO CONTENTS-START_TIME.
    " SY-PAGNO will be incremented not before the first WRITE.
    CONTENTS_CHAPTER_EMPTY = SAP_YES.
  ENDIF.


* Save the time stamp for later comparissons.

  IF ENTRIESTAB-POS_CREATT <> LAST_TIME_STAMP.                     "xxx
    LAST_TIME_STAMP = ENTRIESTAB-POS_CREATT.
  ENDIF.
  IF ENTRIESTAB-POS_CREATT <> DATE_OF_PAGE.                        "xxx
    DATE_OF_PAGE = ENTRIESTAB-POS_CREATT.
  ENDIF.

  HIDE_BUFFER-ENTRIESTAB_IX = ENTRIESTAB_IX.

  CLEAR: GEN_OUTLINE-AREA,     GEN_OUTLINE-SUBID
       , GEN_OUTLINE-IS_TITLE, GEN_OUTLINE-DATE_INT.

* Write time stamp.

  PERFORM WRITE_DATE_OF_ENTRY USING ENTRIESTAB-POS_CREATT
                                    GEN_OUTLINE-DATE.
  PERFORM WRITE_TIME_OF_ENTRY USING ENTRIESTAB-POS_CREATT
                                    GEN_OUTLINE-TIME.
  GEN_OUTLINE-DATE_INT  = ENTRIESTAB-POS_CREATT.

* Write instance name.

  GEN_OUTLINE-INSTID = ENTRIESTAB-SENDER_ID.

  IF A_WHICHLOG = REP_ON_REMOTEA.

*   Hide all remaining fields
*
    CLEAR                            HIDE_C_BUFFER.
    MOVE-CORRESPONDING ENTRIESTAB TO HIDE_C_BUFFER.

*   Do the statistics.
*
    IF LAYOUT-W_STATS = SAP_YES.
      MOVE: ENTRIESTAB-SENDER_ID TO INST_STAT-INST,
            1                    TO INST_STAT-CNT.
      COLLECT INST_STAT.
    ENDIF.

    GEN_OUTLINE-AREA  = ENTRIESTAB-AREA.
    GEN_OUTLINE-SUBID = ENTRIESTAB-SUBID.
    PERFORM WRITE_REST_OF_ENTRY_ALV USING 9.

  ELSEIF A_WHICHLOG = REP_ON_CENTRAL.

* Hide all remaining fields
*
    CLEAR                            HIDE_C_BUFFER.
    MOVE-CORRESPONDING ENTRIESTAB TO HIDE_C_BUFFER.

* Do the statistics.
*
    IF LAYOUT-W_STATS = SAP_YES.
      MOVE: ENTRIESTAB-SENDER_ID TO INST_STAT-INST,
            1                    TO INST_STAT-CNT.
      COLLECT INST_STAT.
    ENDIF.

*EJECT

    IF ENTRIESTAB-sender_id(5) = OWNCENT.
      CASE ENTRIESTAB-sender_id+5(1). " 5 = OWNCENTLG
        WHEN OWNFILE.
          MOVE ENTRIESTAB-centdata TO RSLGFILINF.
          MOVE RSLGFILINF-fi_filenum TO OWNFILE_REST-FI_FILENUM.
          MOVE '= Number of Central SysLog File'(080)
            TO OWNFILE_REST-TEXT.  "'= Number of Central SysLog File'
          MOVE OWNFILE TO CUR_SPECIAL.
          MOVE OWNFILE TO HIDE_LINE_TYPE.
        WHEN OWNCLOCK.
          MOVE ENTRIESTAB-centdata TO sender_info.
          MOVE sender_info-COMPUTERID TO GEN_OUTLINE-INSTID. "Overwrite
          MOVE sender_info-snd_behind TO OWNCLOCK_REST-TIMEDIFF.
          MOVE 'senders clock behind'(081)
            TO OWNCLOCK_REST-TEXT.  "'senders clock behind'
          MOVE OWNCLOCK TO CUR_SPECIAL.
          MOVE OWNCLOCK TO HIDE_LINE_TYPE.
        WHEN OWNINFO.
          MOVE ENTRIESTAB-centdata TO sender_info.
          MOVE sender_info-COMPUTERID TO GEN_OUTLINE-INSTID. "Overwrite
          MOVE 'info '(082)                  TO OWNINFO_REST-INFOTYPE.
          MOVE sender_info-snd_behind TO OWNINFO_REST-TIMEDIFF.
          CASE sender_info-snd_state.
            WHEN clock_only.
              MOVE 'clock di;;'(086) TO OWNINFO_REST-SENDERSTATE.
            WHEN sender_up.
              MOVE 'running ;;'(087) TO OWNINFO_REST-SENDERSTATE.
            WHEN sender_finished.
              MOVE 'finished;;'(088) TO OWNINFO_REST-SENDERSTATE.
            WHEN sender_stoped.
              MOVE 'stoped  ;;'(089) TO OWNINFO_REST-SENDERSTATE.
            WHEN sender_disappeared.
              MOVE 'disappea;;'(090) TO OWNINFO_REST-SENDERSTATE.
            WHEN OTHERS.
              MOVE sender_info-snd_state TO OWNINFO_REST-SENDERSTATE.
              MOVE '?'                   TO OWNINFO_REST-SENDERSTATE+2.
          ENDCASE.
          IF sender_info-snd_state <> clock_only.
            MOVE sender_info-last_reciv TO OWNINFO_REST-LASTRECIVE.
            MOVE sender_info-last_send  TO OWNINFO_REST-LASTSEND.
            MOVE sender_info-native_sid TO HIDE_C_BUFFER-native_s_id.
          ELSE.
            CLEAR OWNINFO_REST-LASTRECIVE.
            CLEAR OWNINFO_REST-LASTSEND.
            CLEAR HIDE_C_BUFFER-native_s_id.
          ENDIF.
          MOVE OWNINFO TO CUR_SPECIAL.
          MOVE OWNINFO TO HIDE_LINE_TYPE.
        WHEN OWNUP.
          MOVE 'collecting daemon was started'(083)
            TO OWNUPDOWN_REST-TEXT.
          MOVE OWNUP TO CUR_SPECIAL.
          MOVE OWNUP TO HIDE_LINE_TYPE.
        WHEN OWNDOWN.
         MOVE 'collecting daemon was ended'(084) TO OWNUPDOWN_REST-TEXT.
          MOVE OWNDOWN TO CUR_SPECIAL.
          MOVE OWNDOWN TO HIDE_LINE_TYPE.
        WHEN OTHERS.
          WRITE ENTRIESTAB-sender_id+5 TO CUR_LINE_DATA(1).
          WRITE ' ????? '              TO CUR_LINE_DATA+1(6).
          WRITE sender_info-snd_behind TO CUR_LINE_DATA+8.
          MOVE USE_DATA TO CUR_SPECIAL.
      ENDCASE.
    ELSE.
      MOVE ENTRIESTAB-centdata to AN_ENTRY.
*   UNPACK_slgtabe(RSLG0400) USING AN_ENTRY ENTRIESTAB-AREA&SUBID.
      IF AN_ENTRY-slgmode < '0' or AN_ENTRY-slgmode > '9'.
         AN_ENTRY-slgmode = 9.
      endif.
      MOVE AN_ENTRY-slgtype TO AUX_slgtype.
      MOVE AUX_slgtype-AREA          TO ENTRIESTAB-AREA.
      MOVE AUX_slgtype-SUBID         TO ENTRIESTAB-SUBID.
      GEN_OUTLINE-AREA    = ENTRIESTAB-AREA.
      GEN_OUTLINE-SUBID   = ENTRIESTAB-SUBID.
      PERFORM WRITE_REST_OF_ENTRY_ALV USING 16.
      MOVE USE_GEN TO CUR_SPECIAL.

    ENDIF.

* Hide all remaining fields

    MOVE HIDE_LINE_TYPE TO GS_HIDE_BUFFER-HIDE_LINE_TYPE.

    CASE TA___WHICHLOG.
      WHEN REP_ON_LOCAL.
      WHEN REP_ON_REMOTEL. "RFC???
      WHEN REP_ON_REMOTEA. "RFC???
        MOVE HIDE_C_BUFFER TO GS_HIDE_BUFFER-native_s_id.
      WHEN REP_ON_CENTRAL.
        MOVE HIDE_C_BUFFER TO GS_HIDE_BUFFER-native_s_id.
    ENDCASE. "TA___WHICHLOG

  ELSE. " A_WHICHLOG >< REP_ON_CENTRAL. ,  >< REP_ON_REMOTEA
    GEN_OUTLINE-AREA  = ENTRIESTAB-AREA.
    GEN_OUTLINE-SUBID = ENTRIESTAB-SUBID.
    PERFORM WRITE_REST_OF_ENTRY_ALV USING 9.

  ENDIF.
* And write all other.

  IF PRINT_EACH_LINE = SAP_YES.
    IF A_WHICHLOG = REP_ON_CENTRAL. "?? REP_ON_REMOTEA
      PERFORM WRITE_DATA_LINE_ALV USING CUR_SPECIAL NO_OV_DATE.
    ELSE.
      PERFORM WRITE_DATA_LINE_ALV USING USE_GEN NO_OV_DATE.
    ENDIF.
    CONTENTS_CHAPTER_EMPTY = SAP_NO.
    ADD 1 TO RECORDCNT-PRINTED.
  ENDIF. "PRINT_EACH_LINE

ENDFORM. "WRITE_WHOLE_ENTRY_ALV

*EJECT

FORM WRITE_DOCUTITLE USING A_TITLE.
*----===============
* Write one titleline for documentation.
*
  IF A_TITLE >< SPACE.
    FORMAT COLOR COL_HEADING INTENSIFIED OFF.
    WRITE: / SY-VLINE NO-GAP, 2(78) A_TITLE, 80 SY-VLINE NO-GAP
         , /(80) SY-ULINE .
    FORMAT COLOR COL_NORMAL  INTENSIFIED    .
  ENDIF.
ENDFORM.                    "WRITE_DOCUTITLE

*&--------------------------------------------------------------------*
*&      Form  WRITE_DOCULINE
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*      -->A_LINE     text
*      -->A_LOOK_DOCUtext
*---------------------------------------------------------------------*
FORM WRITE_DOCULINE USING A_LINE A_LOOK_DOCU.
*----==============
* Write one line of raw documentation.
* Remove formating commands like <ZH>, </>,...
* Set a_look_docu, if something like <DS:...> was seen.
* Never clear a_look_docu.
*
  DATA: LL(132)
      , POS1 TYPE I
      , POS2 TYPE I
      , RESTLEN TYPE I
      , NLEN TYPE I
      .
  FIELD-SYMBOLS: <LP>
              , <RP>
              .
  LL = A_LINE.
  RESTLEN = STRLEN( LL ).
  IF RESTLEN > 0.
    ASSIGN LL(RESTLEN) TO <LP>.
    WHILE RESTLEN > 0.
      IF <LP> CA '<'.
        POS1 = SY-FDPOS.
        POS2 = POS1 + 2.        " Look for   </> ,...
        NLEN = RESTLEN - 3.
        IF RESTLEN >= 3.
          ASSIGN <LP>+POS2(1) TO <RP>.
          IF <RP> = '>'.
            RESTLEN = RESTLEN - POS1.
            ASSIGN <LP>+POS1(RESTLEN) TO <LP>.
            SHIFT <LP> LEFT BY 3 PLACES.
            RESTLEN = RESTLEN - 3.
          ELSEIF RESTLEN >= 4.
            POS2 = POS1 + 3.        " Look for   <ZH> ,...
            ASSIGN <LP>+POS2(1) TO <RP>.
            IF <RP> = '>'.
              RESTLEN = RESTLEN - POS1.
              ASSIGN <LP>+POS1(RESTLEN) TO <LP>.
              SHIFT <LP> LEFT BY 4 PLACES.
              RESTLEN = RESTLEN - 4.
            ELSE.
              IF <RP> = ':'.         " Look for <DS:.......>
                A_LOOK_DOCU = 'X'.
              ENDIF.
*             Skip behind that unusable '<'.
              ADD 1 TO POS1.
              RESTLEN = RESTLEN - POS1.
              ASSIGN <LP>+POS1(RESTLEN) TO <LP>.
            ENDIF.
          ELSE.
            EXIT. "from WHILE loop. Too close to end.
          ENDIF.
        ELSE.
          EXIT. "from WHILE loop. Too close to end.
        ENDIF.
      ELSE.
        EXIT. " No (more) '<'.
      ENDIF.
    ENDWHILE.
  ENDIF.
  WRITE: / SY-VLINE NO-GAP, 2(78) LL, 80 SY-VLINE NO-GAP  .
ENDFORM.                    "WRITE_DOCULINE

*&--------------------------------------------------------------------*
*&      Form  WRITE_DOCU_COMPLEX
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*      -->A_COMPLEX_Dtext
*---------------------------------------------------------------------*
FORM WRITE_DOCU_COMPLEX USING A_COMPLEX_DOCU.
  IF A_COMPLEX_DOCU >< SPACE.
    WRITE: /      SY-VLINE NO-GAP
         , 38(40) 'Eine Doku-Aufbereitung zeigt mehr       ;;'(680)
                   COLOR COL_NEGATIVE INTENSIFIED OFF CENTERED NO-GAP
         , 80 SY-VLINE NO-GAP  .
  ENDIF.
ENDFORM.                    "WRITE_DOCU_COMPLEX

*EJECT

FORM SHOW_DETAILS_NEW USING A_KEY.
************************************************************************
*    SHOW_DETAILS - Show all the details for one data line.
*
*    Input : A_KEY          'F2'
*                           '+1' or '-1'
*            SY-LISEL
*            HIDE_BUFFER    ( refilled )
*            HIDE_TEXT      ( refilled or empty )
*            HIDE_C_BUFFER  ( refilled ) (only in RSLG0001)
*            HIDE_LINE_TYPE ( refilled or empty )
*
*    Global: AUX_slgproc        (write/read)
*
*    Output: WRITE a pop-up page
*
*    Effect: The selected data line is rewritten.
*            More datails are taken out of HIDE buffers and shown.
*            More information is looked up in table "T100 " and in DOKU.
*
*            The pick-up list contains of several blocks. Ech block
*            starts with ULINE and a header

  DATA: LV_DATE(10) TYPE C,
        LV_TIME(8)  TYPE C,
        FULLDATE(8) TYPE C.

  DATA: TMP_D TYPE D
      , TMP_T TYPE T
      , TMP_I TYPE I
      , L_TASK_EXPLAIN(38)
      , MSG(78)
      , COMPLEX_DOCU
      , I_GOT_DOCU
      , DOKTITLE LIKE DSYST-DOKTITLE                        " C(60)
      .
  FIELD-SYMBOLS: <TMP_PTR>.

  PERFORM LOCK_FUNCTION USING 'SNAP'. " Most often off.

  REFRESH GT_DETAIL_TOP.
  CLEAR GV_PAGE.

  IF A_KEY = '+1'.
    ADD 1 TO GV_TABINDEX.
    CLEAR GS_HIDE_BUFFER.
    REFRESH GT_GEN_OUTLINE1.
    READ TABLE GT_HIDE_BUFFER INTO GS_HIDE_BUFFER INDEX
                                    GV_TABINDEX.
    MOVE GS_HIDE_BUFFER-HIDE_LINE_TYPE TO HIDE_LINE_TYPE.
    MOVE-CORRESPONDING GS_HIDE_BUFFER TO HIDE_BUFFER.
    MOVE GS_HIDE_BUFFER-native_s_id TO HIDE_C_BUFFER-NATIVE_S_ID.
    MOVE-CORRESPONDING GS_HIDE_BUFFER TO HIDE_ABAP_INFO.
    MOVE GS_HIDE_BUFFER-HIDE_TEXT TO HIDE_TEXT.
    MOVE GS_HIDE_BUFFER-HIDE_TEXT_LG TO HIDE_TEXT_LG.
    MOVE GS_HIDE_BUFFER-HIDE_PARAMS TO HIDE_PARAMS.
    MOVE GS_HIDE_BUFFER-HIDE_AREA   TO HIDE_AREA.
    MOVE GS_HIDE_BUFFER-HIDE_SUBID  TO HIDE_SUBID.
    READ TABLE GT_GEN_OUTLINE INTO GS_GEN_OUTLINE INDEX
                                   GV_TABINDEX.
    IF SY-SUBRC = 0.
      MOVE-CORRESPONDING GS_GEN_OUTLINE TO GS_GEN_OUTLINE1.
      APPEND GS_GEN_OUTLINE1 TO GT_GEN_OUTLINE1.
    ENDIF.
  ELSEIF A_KEY = '-1'.
    SUBTRACT 1 FROM GV_TABINDEX.
    REFRESH GT_GEN_OUTLINE1.
    READ TABLE GT_HIDE_BUFFER INTO GS_HIDE_BUFFER INDEX
                                    GV_TABINDEX.
    MOVE GS_HIDE_BUFFER-HIDE_LINE_TYPE TO HIDE_LINE_TYPE.
    MOVE-CORRESPONDING GS_HIDE_BUFFER TO HIDE_BUFFER.
    MOVE GS_HIDE_BUFFER-native_s_id TO HIDE_C_BUFFER-NATIVE_S_ID.
    MOVE-CORRESPONDING GS_HIDE_BUFFER TO HIDE_ABAP_INFO.
    MOVE GS_HIDE_BUFFER-HIDE_TEXT TO HIDE_TEXT.
    MOVE GS_HIDE_BUFFER-HIDE_TEXT_LG TO HIDE_TEXT_LG.
    MOVE GS_HIDE_BUFFER-HIDE_PARAMS TO HIDE_PARAMS.
    MOVE GS_HIDE_BUFFER-HIDE_AREA   TO HIDE_AREA.
    MOVE GS_HIDE_BUFFER-HIDE_SUBID  TO HIDE_SUBID.
    READ TABLE GT_GEN_OUTLINE INTO GS_GEN_OUTLINE INDEX
                                   GV_TABINDEX.
    IF SY-SUBRC = 0.
      MOVE-CORRESPONDING GS_GEN_OUTLINE TO GS_GEN_OUTLINE1.
      APPEND GS_GEN_OUTLINE1 TO GT_GEN_OUTLINE1.
    ENDIF.
  ENDIF.

  PAGE_TYPE = HIDE_LINE_TYPE.

  IF HIDE_LINE_TYPE = 'N' OR HIDE_LINE_TYPE = 'Z'.

    INFO_ENTRIESTAB_IX = HIDE_BUFFER-ENTRIESTAB_IX.
    INFO_CURSOR_MOVED = ' '.

*   Refill the header entry of ENTRIESTAB.
*   This saves a lot of memory, because all fields, which are restored
*   by this statement, dont need to be HIDEd any longer.
*
    READ TABLE ENTRIESTAB INDEX INFO_ENTRIESTAB_IX.
    ENTRIESTAB_IX =             INFO_ENTRIESTAB_IX.

    LAST_TIME_STAMP = HIDE_BUFFER-slgdattim.

*   * Repeat the selected data line.
    " Is done in WRITE_NORMAL_TITLE.
    " WRITE SY-LISEL.

*   * If the line is truncated on the screen, show next part too.
    IF SY-SCOLS > 1.
      TMP_I = STRLEN( SY-LISEL ) .
      IF SY-SCOLS < TMP_I .
        TMP_I = TMP_I - SY-SCOLS.
        ASSIGN SY-LISEL+SY-SCOLS(TMP_I) TO <TMP_PTR>.
      ENDIF.
    ENDIF.

*   * If the text field was truncated, then show the full text.

    IF HIDE_TEXT_LG > 0.
      REFRESH GT_D_END.
      PERFORM SHOW_TEXT_ALV USING HIDE_TEXT. " hide_text_lg ?
      IF NOT GT_D_END IS INITIAL.
        APPEND LINES OF GT_D_END TO GT_DETAIL_TOP.
        REFRESH GT_D_END.
        CLEAR GS_DETAIL_TOP.
        APPEND GS_DETAIL_TOP TO GT_DETAIL_TOP.
      ENDIF.
      CLEAR: HIDE_TEXT, HIDE_TEXT_LG.
    ENDIF.
    IF HIDE_BUFFER-slgdata+26(4) = '\/\/'
    OR HIDE_BUFFER-slgdata+27(4) = '\/\/'.
      CONCATENATE
      'This record had been dammaged and later repaired'(620)
                        'by a program like "RSLG0019".'(621)
                        'Data seems to be inclomplete.'(623)
       INTO GS_DETAIL_TOP-LINE SEPARATED BY SPACE.

      APPEND GS_DETAIL_TOP TO GT_DETAIL_TOP.
      CLEAR GS_DETAIL_TOP.
    ENDIF.

*   * If an raw hostname was stored, then show the full text.
*   * ( Will be ignored in report RSLG0000 always. )

    IF HIDE_C_BUFFER-native_s_id NE ' '.
      CONCATENATE 'raw sender name.....'(085) HIDE_C_BUFFER-native_s_id
                          INTO GS_DETAIL_TOP-LINE SEPARATED BY SPACE.
      APPEND GS_DETAIL_TOP TO GT_DETAIL_TOP.
      CLEAR GS_DETAIL_TOP.
    ENDIF.

    IF ENTRIESTAB-slgftyp  = RSLGTYad.
       RSLGADDATA = HIDE_BUFFER-slgdata.
       FULLDATE+2 = RSLGADDATA-datum.
       FULLDATE(2) = '20'.
       PERFORM PREPARE_SNAP_REPORTING USING HIDE_BUFFER-SLGMAND
                                            FULLDATE
                                            RSLGADDATA-uzeit
                                            RSLGADDATA-host
                                            RSLGADDATA-user
                                            HIDE_BUFFER-slgmode.
    ENDIF.
    MOVE 'Details'(284) TO GS_DETAIL_TOP-LINE.
    APPEND GS_DETAIL_TOP TO GT_DETAIL_TOP.
    CLEAR GS_DETAIL_TOP.
*   * If the three timestamps differ, then show them all.
*   * ( Will be ignored in report RSLG0000 always. )

    IF  ENTRIESTAB-RECEVIVE_T  NE SPACE
    AND ENTRIESTAB-POS_CREATT  NE SPACE.
      IF ENTRIESTAB-POS_CREATT NE HIDE_BUFFER-slgdattim.
        TMP_D = HIDE_BUFFER-slgdattim+0(8).
        TMP_T = HIDE_BUFFER-slgdattim+8(6).

        WRITE TMP_D DD/MM/YYYY TO LV_DATE.
        WRITE TMP_T USING EDIT MASK '__:__:__' TO LV_TIME.
        CONCATENATE
     'time the entry was collected according to local clock......'(280)
             LV_DATE LV_TIME INTO GS_DETAIL_TOP-LINE SEPARATED BY SPACE.
        APPEND GS_DETAIL_TOP TO GT_DETAIL_TOP.
        CLEAR GS_DETAIL_TOP.

        TMP_D = ENTRIESTAB-POS_CREATT+0(8).
        TMP_T = ENTRIESTAB-POS_CREATT+8(6).

        WRITE TMP_D DD/MM/YYYY TO LV_DATE.
        WRITE TMP_T USING EDIT MASK '__:__:__' TO LV_TIME.
        CONCATENATE
     'recording time re-caluculated for central clock............'(282)
             LV_DATE LV_TIME INTO GS_DETAIL_TOP-LINE SEPARATED BY SPACE.
        APPEND GS_DETAIL_TOP TO GT_DETAIL_TOP.
        CLEAR GS_DETAIL_TOP.

      ELSE.
        TMP_D = HIDE_BUFFER-slgdattim+0(8).
        TMP_T = HIDE_BUFFER-slgdattim+8(6).

        WRITE TMP_D DD/MM/YYYY TO LV_DATE.
        WRITE TMP_T USING EDIT MASK '__:__:__' TO LV_TIME.
        CONCATENATE
     'time the entry was collected according to both clocks......'(283)
             LV_DATE LV_TIME INTO GS_DETAIL_TOP-LINE SEPARATED BY SPACE.
        APPEND GS_DETAIL_TOP TO GT_DETAIL_TOP.
        CLEAR GS_DETAIL_TOP.
      ENDIF.
      IF ENTRIESTAB-RECEVIVE_T    NE HIDE_BUFFER-slgdattim.
        TMP_D = ENTRIESTAB-RECEVIVE_T+0(8).
        TMP_T = ENTRIESTAB-RECEVIVE_T+8(6).

        WRITE TMP_D DD/MM/YYYY TO LV_DATE.
        WRITE TMP_T USING EDIT MASK '__:__:__' TO LV_TIME.
        CONCATENATE
     'time the entry was collected according to central clock....'(281)
             LV_DATE LV_TIME INTO GS_DETAIL_TOP-LINE SEPARATED BY SPACE.
        APPEND GS_DETAIL_TOP TO GT_DETAIL_TOP.
        CLEAR GS_DETAIL_TOP.
      ENDIF.
    ENDIF. "All three timestamps given.

*   * Show the process-Id and the task-Id.
    AUX_slgproc = HIDE_BUFFER-slgproc.
    NO_TASKTNO = ' '.
    PERFORM EXPLAIN_TASK_TYPE USING AUX_slgproc-slgttyp L_TASK_EXPLAIN.

    REFRESH GT_DETAILS.

    MOVE AUX_SLGPROC-UNIXPID TO GS_DETAILS-TASK.
    MOVE L_TASK_EXPLAIN TO GS_DETAILS-TASK_EXPLAIN.
    MOVE HIDE_BUFFER-slguser TO GS_DETAILS-USER.
    MOVE HIDE_BUFFER-SLGMAND TO GS_DETAILS-CLIENT.

    MOVE HIDE_BUFFER-slgltrm TO GS_DETAILS-TERMINAL.
    MOVE HIDE_BUFFER-SLGMODE TO GS_DETAILS-MODE.

*   * Show the transaction code and the report name
    MOVE HIDE_BUFFER-slgtc    TO GS_DETAILS-TCODE.
    MOVE HIDE_BUFFER-SLGREPNA TO GS_DETAILS-REPNA.

*   show class of problems.                   " neu eingefügt
    CLEAR: CLASSTAB.
    SELECT SINGLE * FROM TSL1D                " Why i/o ??
      WHERE AREA  = ENTRIESTAB-AREA           " ENTRIESTAB-CLASID is
      AND   SUBID = ENTRIESTAB-SUBID.         "  empty

    IF SY-SUBRC = 0.
      CLASSTAB-CLASID = TSL1D-CLASID.
      CLASSTAB-SPRAS  = SY-LANGU.
      READ TABLE CLASSTAB.
    ENDIF.

    MOVE CLASSTAB-CLASID TO GS_DETAILS-CID.
    MOVE CLASSTAB-CLASSNAME TO GS_DETAILS-CNAME.

*   show developementclass.                   " neu eingefügt
    CLEAR: TDEVC, TADIR.
    SELECT SINGLE * FROM TADIR
      WHERE PGMID    = 'R3TR'
      AND   OBJECT   = 'SYAG'
      AND   OBJ_NAME = ENTRIESTAB-AREA.

    TDEVC-DEVCLASS = TADIR-DEVCLASS.

    IF TDEVC-DEVCLASS <> SPACE.
      SELECT SINGLE * FROM TDEVC
        WHERE DEVCLASS = TDEVC-DEVCLASS.
    ENDIF.
    MOVE TDEVC-DEVCLASS TO GS_DETAILS-DCLASS.
*   MOVE TDEVC-CTEXT    TO GS_DETAILS-CTEXT.
    APPEND GS_DETAILS TO GT_DETAILS.
    CLEAR GS_DETAILS.

*   * Now go and show fields of variant part.
*   * ---------------------------------------
*
    MOVE ENTRIESTAB-slgftyp TO GV_SLGFTYP.
    PERFORM SET_TRUE_PF_STATUS.
    REFRESH GT_DOC.

*   Dokumentation für SysLog-Meldung ---------------------------
    CLEAR: LINE, OBJECT, IDENTITY.
    CLEAR: I_GOT_DOCU.
    REFRESH LINE.
    OBJECT   = ENTRIESTAB-AREA.
    OBJECT+2 = ENTRIESTAB-SUBID.
    CALL FUNCTION 'DOCU_GET'
      EXPORTING
        ID       = 'SL'                " Dokuklasse System-Log
        LANGU    = SY-LANGU
        OBJECT   = OBJECT              " Eindeutiger Schlüssel
        TYP      = 'E'                 " Endanwenderdoku
      IMPORTING
        DOKTITLE = DOKTITLE
      TABLES
        LINE     = LINE
      EXCEPTIONS
        RET_CODE = 1.
    IF SY-SUBRC = 0.
*     Nachschauen, ob Doku-Baustein in Tabelle LINE abgelegt wurde.
      READ TABLE LINE INDEX 1.
      IF SY-SUBRC = 0.         " Doku-Baustein vorhanden
        I_GOT_DOCU = 'X'.
      ENDIF.
    ENDIF.
    IF I_GOT_DOCU >< SPACE. " Doku-Baustein vorhanden

      CONCATENATE 'Dokumentation für SysLog-Meldung'(250)
            ENTRIESTAB-AREA ENTRIESTAB-SUBID ''(251) INTO GV_LINE
                                              SEPARATED BY SPACE.
      MOVE GV_LINE TO GS_DOC-LINE.
      REFRESH GT_COLOR.
      GS_COLOR-FNAME = 'LINE'.
      GS_COLOR-COLOR-COL = COL_HEADING.
      GS_COLOR-COLOR-INT = 1.
      GS_COLOR-COLOR-INV = 0.
      APPEND GS_COLOR TO GT_COLOR.
      MOVE GT_COLOR TO GS_DOC-COLOR.
      APPEND GS_DOC TO GT_DOC.
      CLEAR GS_COLOR.
      CLEAR: GS_DOC, GV_LINE.
      APPEND GS_DOC TO GT_DOC.

      PERFORM WRITE_DOCUTITLE_ALV USING DOKTITLE.

*     Ausgabe des Doku-Bausteins.
      CLEAR COMPLEX_DOCU.
      LOOP AT LINE.
        PERFORM WRITE_DOCULINE_ALV USING LINE-TDLINE COMPLEX_DOCU.
      ENDLOOP.
      PERFORM WRITE_DOCU_COMPLEX_ALV USING COMPLEX_DOCU.
    ELSE.

      CONCATENATE 'Keine Dokumentation für SysLog-Meldung'(252)
            ENTRIESTAB-AREA ENTRIESTAB-SUBID 'vorhanden.'(253) INTO
                                         GV_LINE SEPARATED BY SPACE.
      MOVE GV_LINE TO GS_DOC-LINE.
      REFRESH GT_COLOR.
      GS_COLOR-FNAME = 'LINE'.
      GS_COLOR-COLOR-COL = COL_NEGATIVE.
      GS_COLOR-COLOR-INT = 0.
      GS_COLOR-COLOR-INV = 0.
      APPEND GS_COLOR TO GT_COLOR.
      MOVE GT_COLOR TO GS_DOC-COLOR.
      APPEND GS_DOC TO GT_DOC.
      CLEAR: GS_COLOR, GS_DOC, GV_LINE.
      APPEND GS_DOC TO GT_DOC.
    ENDIF.

*   Weitere Dokumentation für Nachricht -------------------------
    IF ENTRIESTAB-slgftyp  = RSLGTYex.
       RSLGEXDATA = HIDE_BUFFER-slgdata.
       PERFORM PUT_T100_INTO_ENTRIESTAB  USING RSLGEXDATA-t100.
    ENDIF.
    IF ENTRIESTAB-slgftyp  = RSLGTYdd.
       RSLGDDDATA = HIDE_BUFFER-slgdata.
       PERFORM PUT_T100_INTO_ENTRIESTAB  USING RSLGDDDATA-t100.
    ENDIF.
    IF ENTRIESTAB-slgftyp  = RSLGTYab.
       RSLGABDATA = HIDE_BUFFER-slgdata.
       PERFORM SHOW_AB_LOOK_T100_SY USING RSLGABDATA-parameters.
    ENDIF.
    IF NOT ENTRIESTAB-T100ARBGB IS INITIAL.
      APPEND GS_DOC to GT_DOC.
      MSG = 'Weitere Dokumentation für Nachricht &1&2'(258).
      REPLACE '&1' WITH ENTRIESTAB-T100ARBGB INTO MSG.
      REPLACE '&2' WITH ENTRIESTAB-T100MSGNR INTO MSG.
      MOVE MSG TO GS_DOC-LINE.
      REFRESH GT_COLOR.
      GS_COLOR-FNAME = 'LINE'.
      GS_COLOR-COLOR-COL = COL_HEADING.
      GS_COLOR-COLOR-INT = 1.
      GS_COLOR-COLOR-INV = 0.
      APPEND GS_COLOR TO GT_COLOR.
      MOVE GT_COLOR TO GS_DOC-COLOR.
      APPEND GS_DOC TO GT_DOC.
      CLEAR: GS_COLOR, GT_COLOR, GS_DOC, GV_LINE.
      APPEND GS_DOC TO GT_DOC.
      SELECT SINGLE * FROM T100
        WHERE SPRSL = SY-LANGU
        AND   ARBGB = ENTRIESTAB-T100ARBGB
        AND   MSGNR = ENTRIESTAB-T100MSGNR.
      IF SY-SUBRC = 0.
        MOVE T100-TEXT TO GS_DOC-LINE.
        APPEND GS_DOC TO GT_DOC.
        CLEAR GS_DOC.
        APPEND GS_DOC TO GT_DOC.
      ELSE.
        GS_COLOR-FNAME = 'LINE'.
        GS_COLOR-COLOR-COL = COL_NEGATIVE.
        GS_COLOR-COLOR-INT = 1.
        GS_COLOR-COLOR-INV = 0.
        APPEND GS_COLOR TO GT_COLOR.
        MOVE GT_COLOR TO GS_DOC-COLOR.
        MOVE 'not found.'(132) TO GS_DOC-LINE.
        APPEND GS_DOC TO GT_DOC.
        CLEAR: GS_DOC, GS_COLOR, GT_COLOR.
      ENDIF.

      CLEAR: LINE, OBJECT, IDENTITY.
      CLEAR: I_GOT_DOCU.
      REFRESH LINE.
      IDENTITY = 'NA'.
      CONCATENATE ENTRIESTAB-T100ARBGB ENTRIESTAB-T100MSGNR into OBJECT.
      CALL FUNCTION 'DOCU_GET'
        EXPORTING
          ID       = IDENTITY     " Dokuklasse Nachricht
          LANGU    = SY-LANGU
          OBJECT   = OBJECT       " Eindeutiger Schlüssel
          TYP      = 'E'          " Endanwenderdoku
        IMPORTING
          DOKTITLE = DOKTITLE
        TABLES
          LINE     = LINE
        EXCEPTIONS
          RET_CODE = 1.
      IF SY-SUBRC = 0.
*       Nachschauen, ob Doku-Baustein in Tabelle LINE abgelegt wurde.
        READ TABLE LINE INDEX 1.
        IF SY-SUBRC = 0.         " Doku-Baustein vorhanden
          I_GOT_DOCU = 'X'.
        ENDIF.
      ENDIF.
      IF I_GOT_DOCU >< SPACE. " Doku-Baustein vorhanden
*       Ausgabe des Doku-Bausteins.
        GS_COLOR-FNAME = 'LINE'.
        GS_COLOR-COLOR-COL = COL_NORMAL.
        GS_COLOR-COLOR-INT = 0.
        GS_COLOR-COLOR-INV = 0.
        APPEND GS_COLOR TO GT_COLOR.
        MOVE GT_COLOR TO GS_DOC-COLOR.
        PERFORM WRITE_DOCUTITLE_ALV USING DOKTITLE.
        CLEAR COMPLEX_DOCU.
        LOOP AT LINE.
          PERFORM WRITE_DOCULINE_ALV USING LINE-TDLINE COMPLEX_DOCU.
        ENDLOOP.
        PERFORM WRITE_DOCU_COMPLEX_ALV USING COMPLEX_DOCU.
      ELSE.
        MSG = 'Keine Dokumentation für Nachricht & vorhanden'(259).
        REPLACE '&' WITH OBJECT(23) INTO MSG.
        MOVE MSG TO GS_DOC-LINE.
        GS_COLOR-FNAME = 'LINE'.
        GS_COLOR-COLOR-COL = COL_NEGATIVE.
        GS_COLOR-COLOR-INT = 1.
        GS_COLOR-COLOR-INV = 0.
        APPEND GS_COLOR TO GT_COLOR.
        MOVE GT_COLOR TO GS_DOC-COLOR.
        APPEND GS_DOC TO GT_DOC.
        CLEAR: GS_DOC, GS_COLOR, GT_COLOR.
      ENDIF.
    ENDIF. " ENTRIESTAB-T100ARBGB/MSGNR

*   Weitere Angaben zur Fehlernummer ----------------------------
    IF NOT ENTRIESTAB-ERRNO IS INITIAL.
      MSG = 'Weitere Angaben zur Fehlernummer &'(660).
      REPLACE '&' WITH ENTRIESTAB-ERRNO INTO MSG.
      CONDENSE MSG.
      MOVE MSG TO GS_DOC-LINE.
      APPEND GS_DOC TO GT_DOC.
      CLEAR GS_DOC.
      CALL FUNCTION 'RSLG_EXPLAIN_ERRNO'
        EXPORTING
          ERRNO         = ENTRIESTAB-ERRNO
          INSTANCE      = ENTRIESTAB-SENDER_ID
        IMPORTING
          ERRORNAME     = ERRORNAME
          ERRORTEXT     = ERRORTEXT
        EXCEPTIONS
          OPSYS_UNKNOWN = 1.
      IF SY-SUBRC = 1.
        MSG = 'Tabelle &3 muß noch gepflegt werden.'(668).
        REPLACE '&3' WITH 'TSLE4' INTO MSG.
        MOVE MSG TO GS_DOC-LINE.
        APPEND GS_DOC TO GT_DOC.
        CLEAR GS_DOC.

        MSG =
          'Bitte starten Sie Transaktion &1 auf der Instanz "&2".'(669).
        REPLACE '&1' WITH SY-TCODE INTO MSG.
        REPLACE '&2' WITH ENTRIESTAB-SENDER_ID INTO MSG.

        MOVE MSG TO GS_DOC-LINE.
        APPEND GS_DOC TO GT_DOC.
        CLEAR GS_DOC.
      ELSE.

        CONCATENATE 'Name für errno-Nr.  ;'(662) ERRORNAME INTO GV_LINE
                                                     SEPARATED BY SPACE.
        MOVE GV_LINE TO GS_DOC-LINE.
        APPEND GS_DOC TO GT_DOC.
        CLEAR: GS_DOC, GV_LINE.

*       Search for documentation:
*       In the hyperbook 'SYSLOGREAD' there may be a chapter with
*       a name consisting of 'RSLG_E_' and die error name.
        CLEAR: LINE, OBJECT, IDENTITY.
        CLEAR: I_GOT_DOCU.
        REFRESH LINE.
        IDENTITY    = 'HY'.      "??
        OBJECT      = 'CHAP'.
        OBJECT+4    = 'RSLG_E_'.
        OBJECT+11   = ERRORNAME.
        CALL FUNCTION 'DOCU_GET'
          EXPORTING
            ID       = IDENTITY     " Dokuklasse Nachricht
            LANGU    = SY-LANGU
            OBJECT   = OBJECT       " Eindeutiger Schlüssel
            TYP      = 'E'          " Endanwenderdoku
          IMPORTING
            DOKTITLE = DOKTITLE
          TABLES
            LINE     = LINE
          EXCEPTIONS
            RET_CODE = 1.
        IF SY-SUBRC = 0.
*         Nachschauen, ob Doku-Baustein in Tabelle LINE abgelegt wurde.
          READ TABLE LINE INDEX 1.
          IF SY-SUBRC = 0.         " Doku-Baustein vorhanden
            I_GOT_DOCU = 'X'.
          ENDIF.
        ENDIF.
        IF I_GOT_DOCU >< SPACE. " Doku-Baustein vorhanden
          PERFORM WRITE_DOCUTITLE_ALV USING DOKTITLE.

*         Ausgabe des Doku-Bausteins.
          CLEAR COMPLEX_DOCU.
          LOOP AT LINE.
            PERFORM WRITE_DOCULINE_ALV USING LINE-TDLINE COMPLEX_DOCU.
          ENDLOOP.
          PERFORM WRITE_DOCU_COMPLEX_ALV USING COMPLEX_DOCU.
        ELSE.
          MSG = 'Keine Dokumentation für Fehler & vorhanden'(666).
          REPLACE '&' WITH ERRORNAME INTO MSG.
          CONDENSE MSG.
          MOVE MSG TO GS_DOC-LINE.
          APPEND GS_DOC TO GT_DOC.
          CLEAR GS_DOC.
        ENDIF.
      ENDIF. " errno and opsys known.
    ENDIF. " ENTRIESTAB-ERRNO

*   Parameter -----------------
    IF HIDE_PARAMS <> SPACE.
      REFRESH: GT_PARAM_TOP, GT_PARAM.
      MOVE 'Parameter'(290) TO GS_PARAM_TOP.
      APPEND GS_PARAM_TOP TO GT_PARAM_TOP.
      CLEAR GS_PARAM_TOP.
      CALL FUNCTION 'RSLG_WRITE_PARAMS_ALV'
        EXPORTING
          PARAM_ARRAY = HIDE_PARAMS
        TABLES
          GT_TOP      = GT_PARAM.

    ENDIF.

*   Technische Details ----------------------
    REFRESH GT_TECH_TOP.
    MOVE 'Technische Details'(448) TO GS_TECH_TOP-LINE.
    APPEND GS_TECH_TOP TO GT_TECH_TOP.
    CLEAR GS_TECH_TOP.
    CLEAR TSL3T-TXT.
    SELECT SINGLE * FROM TSL3T
      WHERE SPRAS  = SY-LANGU
      AND   SLTYPE = ENTRIESTAB-slgftyp.
    " ignore SY-SUBRC
    REFRESH GT_TECHNICAL.
    MOVE ENTRIESTAB-FILE_NO TO GS_TECHNICAL-FILE_NO.
    MOVE ENTRIESTAB-POS     TO GS_TECHNICAL-POS.
    MOVE ENTRIESTAB-SLGFTYP TO GS_TECHNICAL-SLGFTYP.
    MOVE TSL3T-TXT          TO GS_TECHNICAL-TXT.
    MOVE ENTRIESTAB-AREA    TO GS_TECHNICAL-AREA.
    MOVE ENTRIESTAB-SUBID   TO GS_TECHNICAL-SUBID.
    MOVE HIDE_BUFFER-SLGDATA TO GS_TECHNICAL-SLGDATA.
    APPEND GS_TECHNICAL TO GT_TECHNICAL.
    CLEAR GS_TECHNICAL.
    PERFORM SHOW_DETAILS_ALV USING A_KEY.

  ELSE.

    SET PF-STATUS 'BACK'.
*   * Oops, this line was not prepared for selection.
    IF HIDE_LINE_TYPE = 'C'.
      PERFORM CONTENTS1_ALV.
    ELSE.
      PERFORM COMMON_DISPLAY.
    ENDIF.
  ENDIF. " HIDE_LINE_TYPE = '-'.

* * Inhibbit reusage of this data for other lines.

  PERFORM CLEAR_ALL_HIDDEN.
  REFRESH: GT_PARAM_TOP, GT_PARAM, GT_D_END.
  CLEAR:   GS_D_END, GS_DETAIL_TOP, GS_DETAILS, GS_DOC,
           GV_LINE, GS_TECHNICAL.


* * Reinitialize locked functions.
  PERFORM ACTIVATE_EXPERT_FIELDS_N_FUNCS.

ENDFORM.                    "SHOW_DETAILS_NEW

*EJECT
FORM TAKE_EXAMPLE_FOR_SEL.
************************************************************************
*
*    TAKE_EXAMPLE_FOR_SEL - Use all the details of one data line as
*                           new selection cretieria.
*
*    Input : HIDE_BUFFER    ( refilled )
*            HIDE_TEXT      ( refilled or empty )
*            HIDE_C_BUFFER  ( refilled ) (only in RSLG0001)
*            HIDE_LINE_TYPE ( refilled or empty )
*
*    Global: AUX_slgproc        (write/read)
*
*    Output: WRITE a pop-up page
*
*    Effect: The selected data line is rewritten.
*            More datails are taken out of HIDE buffers and shown.
*            More information is looked up in table "T100 " and in DOKU.
*

  DATA: TMP_D TYPE D
      , TMP_T TYPE T
*     , tmp_i type i
*     , l_task_explain(38)
      , L_CLASSID(1)
      , L_DEVCLASS(4)
      .
* field-symbols: <tmp_ptr>.

  PAGE_TYPE = HIDE_LINE_TYPE.

  IF HIDE_LINE_TYPE <> 'N' AND HIDE_LINE_TYPE <> 'Z'
  AND HIDE_LINE_TYPE <> '-'.
    MESSAGE W162. " no info for this line.
    EXIT. "------------>
  ENDIF.

  IF HIDE_LINE_TYPE = '-' AND SY-PFKEY <> 'INFO'.
    MESSAGE W162. " no info for this line.
    EXIT. "------------>
  ENDIF.

* Refill the header entry of ENTRIESTAB.
*   This saves a lot of memory, because all fields, which are restored
*   by this statement, dont need to be HIDEd any longer.
*
  READ TABLE ENTRIESTAB INDEX HIDE_BUFFER-ENTRIESTAB_IX.
  ENTRIESTAB_IX =             HIDE_BUFFER-ENTRIESTAB_IX.

  IF ENTRIESTAB-POS_CREATT <> SPACE.
    TMP_D = ENTRIESTAB-POS_CREATT+0(8).
    TMP_T = ENTRIESTAB-POS_CREATT+8(6).
  ELSE.
    TMP_D = HIDE_BUFFER-slgdattim+0(8).
    TMP_T = HIDE_BUFFER-slgdattim+8(6).
  ENDIF.

  AUX_slgproc = HIDE_BUFFER-slgproc.

*   find class of problems.
  SELECT SINGLE * FROM TSL1D
    WHERE AREA  = ENTRIESTAB-AREA
    AND   SUBID = ENTRIESTAB-SUBID.
  IF SY-SUBRC = 0.
    L_CLASSID = TSL1D-CLASID.
  ELSE.
    L_CLASSID = DY_CLASID6. "old value
  ENDIF.

*   find developementclass.
  SELECT SINGLE * FROM TADIR
    WHERE PGMID    = 'R3TR'
    AND   OBJECT   = 'SYAG'
    AND   OBJ_NAME = ENTRIESTAB-AREA.
  IF SY-SUBRC = 0.
    L_DEVCLASS = TADIR-DEVCLASS.
  ELSE.
    L_DEVCLASS = DY_DEVCLASS. "old value
  ENDIF.


  DY_START_FILE   = ENTRIESTAB-FILE_NO.
  DY_START_POS    = ENTRIESTAB-POS.
  DY_STOP_FILE    = ENTRIESTAB-FILE_NO.
  DY_STOP_POS     = ENTRIESTAB-POS.
  DY_START_DATE   = TMP_D.
  DY_START_TIME   = TMP_T.
  DY_END_DATE     = TMP_D.
  DY_END_TIME     = TMP_T.
* message id      = ENTRIESTAB-AREA&SUBID.
  DY_TYPE         = ENTRIESTAB-slgftyp.
  DY_DEVCLASS     = L_DEVCLASS.
* DY_CLASID1      .. unchanged.
* DY_CLASID2      .. unchanged.
* DY_CLASID3      .. unchanged.
* DY_CLASID4      .. unchanged.
* DY_CLASID5      .. unchanged.
  DY_CLASID6      = L_CLASSID.
  RSLGTYPE-TASK   = AUX_slgproc-slgttyp.
* DY_TASK_EXPLAIN .. will be set at PBO
  RSLGTYPE-TERMINAL = HIDE_BUFFER-slgltrm.
* RSLGTYPE-USER   .. I cannot figure it out.
* RSLGTYPE-TCODE  .. I cannot figure it out.
* RSLGTYPE-REPNA  .. I cannot figure it out.
* DY_INST         .. I cannot figure it out.
* transaction cod = HIDE_BUFFER-slgtc.
* report name     = HIDE_BUFFER-slgrepna.
* mode            = HIDE_BUFFER-slgmode.
* RSLGLAYOUT-MAXPAG .. not affected.
* DY_STATISTICS   .. not affected.
* DY_INTERNRECS   .. not affected.
* DY_PRINT        .. not affected.
* DY_OUT_DEST     .. not affected.


ENDFORM.                    "TAKE_EXAMPLE_FOR_SEL

*EJECT
FORM SHOW_2ND_DOCU.
  PERFORM SHOW_SL_DOCU.  "?? Still not impl.
ENDFORM.                    "SHOW_2ND_DOCU

*&--------------------------------------------------------------------*
*&      Form  SHOW_SL_DOCU
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM SHOW_SL_DOCU.
************************************************************************
*
*    SHOW_SL_DOCU  -  Start the nice document viewer on the current
*                     SysLog documentation.
*
*    Input : HIDE_BUFFER    ( refilled )
*            HIDE_TEXT      ( refilled or empty )
*            HIDE_C_BUFFER  ( refilled ) (only in RSLG0001)
*            HIDE_LINE_TYPE ( refilled or empty )
*
*    Global: AUX_slgproc        (write/read)
*
*    Output: WRITE a pop-up page
*
*    Effect: The selected data line is rewritten.
*            More datails are taken out of HIDE buffers and shown.
*            More information is looked up in table "T100 " and in DOKU.
*

* data: tmp_d type d
*     , tmp_t type t
*     , tmp_i type i
*     , l_task_explain(38)
*     , l_classid(1)
*     , l_devclass(4)
*     .
* field-symbols: <tmp_ptr>.

  PAGE_TYPE = HIDE_LINE_TYPE.

  IF HIDE_LINE_TYPE <> 'N' AND HIDE_LINE_TYPE <> 'Z'
  AND HIDE_LINE_TYPE <> '-'.
    MESSAGE W162. " no info for this line.
    EXIT. "------------>
  ENDIF.

* Refill the header entry of ENTRIESTAB.
*   This saves a lot of memory, because all fields, which are restored
*   by this statement, dont need to be HIDEd any longer.
*
  READ TABLE ENTRIESTAB INDEX HIDE_BUFFER-ENTRIESTAB_IX.
  ENTRIESTAB_IX =             HIDE_BUFFER-ENTRIESTAB_IX.


  CLEAR: LINE, OBJECT, IDENTITY.        " neu eingefügt
  REFRESH LINE.
  OBJECT   = ENTRIESTAB-AREA.
  OBJECT+2 = ENTRIESTAB-SUBID.
  CALL FUNCTION 'DOCU_CALL'
    EXPORTING
      DISPL_MODE    = '2'       " Nice output processing
      DISPL         = 'X'       " Display only
      ID            = 'SL'      " Dokuklasse System-Log
      LANGU         = SY-LANGU
      OBJECT        = OBJECT    " Eindeutiger Schlüssel
      TYP           = 'E'       " Doku-Typ: Endanwenderdokum.
      USE_SEC_LANGU = 'X'    "A. Linke 403490/1995
      SUPPRESS_EDIT = 'X'.    "A. Linke 403490/1995

ENDFORM.                    "SHOW_SL_DOCU

*EJECT
FORM IGNORE_THIS_MESSAGE_ID_ALV.
************************************************************************
*
*    IGNORE_THIS_MESSAGE_ID - Use the details of one data line as
*                             lock out message id Selection criteria
*
*    Input : HIDE_BUFFER    ( refilled )
*            HIDE_LINE_TYPE ( refilled or empty )
*

  IF HIDE_LINE_TYPE = 'J'. " a line from message statistics
    CLEAR IGNORE_IDS.
    IGNORE_IDS-AREA    = HIDE_AREA.
    IGNORE_IDS-SUBID   = HIDE_SUBID.

  ELSE.
    IF HIDE_LINE_TYPE <> 'N' AND HIDE_LINE_TYPE <> 'Z'
    AND HIDE_LINE_TYPE <> '-'.
      MESSAGE W162. " no info for this line.
      EXIT. "------------>
    ENDIF.

    IF HIDE_LINE_TYPE = '-' AND SY-PFKEY <> 'INFO'.
      MESSAGE W162. " no info for this line.
      EXIT. "------------>
    ENDIF.

*   Refill the header entry of ENTRIESTAB.
*   This saves a lot of memory, because all fields, which are restored
*   by this statement, dont need to be HIDEd any longer.
*
    READ TABLE ENTRIESTAB INDEX HIDE_BUFFER-ENTRIESTAB_IX.
    ENTRIESTAB_IX =             HIDE_BUFFER-ENTRIESTAB_IX.

    CLEAR IGNORE_IDS.
    IGNORE_IDS-AREA    = ENTRIESTAB-AREA.
    IGNORE_IDS-SUBID   = ENTRIESTAB-SUBID.
  ENDIF.

  SELECT SINGLE * FROM TSL1T
                       WHERE SPRAS = SY-LANGU
                       AND   AREA  = IGNORE_IDS-AREA
                       AND   SUBID = IGNORE_IDS-SUBID.
  IF SY-SUBRC = 0.
    IGNORE_IDS-TXT = TSL1T-TXT.
  ELSE.
    SELECT SINGLE * FROM TSL1T
                       WHERE SPRAS = 'EN'
                       AND   AREA  = IGNORE_IDS-AREA
                       AND   SUBID = IGNORE_IDS-SUBID.
    IF SY-SUBRC = 0.
      IGNORE_IDS-TXT = TSL1T-TXT.
    ELSE.
      IGNORE_IDS-TXT = '<kein Text?>'(500).
    ENDIF.
  ENDIF.
  APPEND IGNORE_IDS.
  ADD 1 TO IGNORE_IDS_CNT.
  SHIFT IGNORE_IDS_LST RIGHT BY 3 PLACES.
  IGNORE_IDS_LST(2)   = ENTRIESTAB-AREA.
  IGNORE_IDS_LST+2(1) = ENTRIESTAB-SUBID.

  CALL FUNCTION 'RSLG_SEL_ST_MSGLST_ALV'
    EXPORTING
      MSGINC = IGNORE_IDS_INC
      MSGLST = IGNORE_IDS_LST.

  " Bei der naechsten Aufbereitung werden $$-Meldungen weggelassen
  MESSAGE S165 WITH IGNORE_IDS-AREA IGNORE_IDS-SUBID.

ENDFORM.                    "IGNORE_THIS_MESSAGE_ID_ALV

*EJECT
FORM SHOW_TEXT_ALV USING A26_TEXT.
************************************************************************
*
*    SHOW_TEXT - Write a full text, by breaking into several lines.
*
  DATA  L26_OFFSET TYPE I.
  DATA  L26_LENGTH TYPE I.
  DATA  L26_REST   TYPE I.

  MOVE 0        TO L26_OFFSET.
  MOVE 130      TO L26_LENGTH.
  SUBTRACT 1  FROM L26_LENGTH.
  L26_REST = STRLEN( A26_TEXT ).
  WHILE L26_REST > 0.
    MOVE A26_TEXT TO GS_D_END-LINE.
    APPEND GS_D_END TO GT_D_END.
    CLEAR GS_D_END.
    SHIFT A26_TEXT BY L26_LENGTH PLACES.
    SUBTRACT L26_LENGTH FROM L26_REST.
    IF L26_LENGTH > L26_REST.
      MOVE L26_REST TO L26_LENGTH.
    ENDIF.
  ENDWHILE.
ENDFORM.                    "SHOW_TEXT_ALV

*EJECT
FORM SHOW_CF_DETAILS_ALV.
************************************************************************
*
*    SHOW_CF_DETAILS - Show additional details for message about change
*                      of SysLog file.
*
*    Input : SY-LISEL
*            HIDE_BUFFER    ( refilled )
*            HIDE_TEXT      ( refilled or empty )
*
*    Global: ?
*
*    Output: WRITE to pop-up page
*
*    Effect:
*
  CONSTANTS: LC_INAME TYPE DD02L-TABNAME VALUE 'GT_CF',
             LC_SNAME TYPE DD02L-TABNAME VALUE 'RSLGCFDATA'.
  RSLGCFDATA = HIDE_BUFFER-slgdata.

  REFRESH GT_D_TOP.
  MOVE 'A new SysLog file was started.'(153) TO GS_D_TOP-LINE.
  APPEND GS_D_TOP TO GT_D_TOP.
  CLEAR GS_D_TOP.

  REFRESH GT_CF.
  MOVE RSLGCFDATA-CF_FILENUM TO GS_CF-CF_FILENUM.
  MOVE RSLGCFDATA-CF_PUB_VER TO GS_CF-CF_PUB_VER.
  MOVE RSLGCFDATA-CF_INT_VER TO GS_CF-CF_INT_VER.
  APPEND GS_CF TO GT_CF.
  CLEAR GS_CF.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_INAME LC_SNAME
                           CHANGING  GT_FIELDCAT1[] .

  CLEAR GS_FIELDCAT.
  LOOP AT GT_FIELDCAT1 INTO GS_FIELDCAT.
    IF GS_FIELDCAT-FIELDNAME = 'CF_CPU_ID'.
      GS_FIELDCAT-TECH = GC_X.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'CF_REC_SIZ'.
      GS_FIELDCAT-TECH = GC_X.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'UNUSED_CF'.
      GS_FIELDCAT-TECH = GC_X.
    ENDIF.
    MODIFY GT_FIELDCAT1 FROM GS_FIELDCAT TRANSPORTING TECH.
    CLEAR GS_FIELDCAT.
  ENDLOOP.

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD1 CHANGING GT_EVENTS[].

  GS_LAYOUT-LIST_APPEND     = 'X'.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM = GV_REPID
      I_STRUCTURE_NAME   = LC_SNAME
      IS_LAYOUT          = GS_LAYOUT
      IT_FIELDCAT        = GT_FIELDCAT1
      I_SAVE             = GC_X
      IT_EVENTS          = GT_EVENTS
    TABLES
      T_OUTTAB           = GT_CF
    EXCEPTIONS
      PROGRAM_ERROR      = 1
      OTHERS             = 2.

  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
          WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM. " SHOW_CF_DETAILS_ALV

*&--------------------------------------------------------------------*
*&      Form  SHOW_UP_DETAILS_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM SHOW_UP_DETAILS_ALV.
************************************************************************
*
*    SHOW_UP_DETAILS - Show additional details for message about some
*                      error.
*
*    Input : SY-LISEL
*            HIDE_BUFFER    ( refilled )
*            HIDE_TEXT      ( refilled or empty )
*
*    Global: ?
*
*    Output: WRITE to pop-up page
*
*    Effect:
*
  CONSTANTS: LC_INAME TYPE DD02L-TABNAME VALUE 'GT_UP',
             LC_SNAME TYPE DD02L-TABNAME VALUE 'RSLGUPDATA'.

  RSLGUPDATA = HIDE_BUFFER-slgdata.

  REFRESH GT_D_TOP.
  MOVE 'A daemon was started.'(157) TO GS_D_TOP-LINE.
  APPEND GS_D_TOP TO GT_D_TOP.
  CLEAR GS_D_TOP.

  REFRESH GT_UP.
  MOVE RSLGUPDATA-DEAMON TO GS_UP-DEAMON.
  MOVE RSLGUPDATA-PROBLEM TO GS_UP-PROBLEM.
  APPEND GS_UP TO GT_UP.
  CLEAR GS_UP.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_INAME LC_SNAME
                           CHANGING  GT_FIELDCAT1[] .

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD1 CHANGING GT_EVENTS[].

  GS_LAYOUT-LIST_APPEND     = 'X'.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM = GV_REPID
      I_STRUCTURE_NAME   = LC_SNAME
      IS_LAYOUT          = GS_LAYOUT
      IT_FIELDCAT        = GT_FIELDCAT1
      I_SAVE             = GC_X
      IT_EVENTS          = GT_EVENTS
    TABLES
      T_OUTTAB           = GT_UP
    EXCEPTIONS
      PROGRAM_ERROR      = 1
      OTHERS             = 2.

  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
          WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM. " SHOW_UP_DETAILS_ALV

*&--------------------------------------------------------------------*
*&      Form  SHOW_DO_DETAILS_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM SHOW_DO_DETAILS_ALV.
************************************************************************
*
*    SHOW_DO_DETAILS - Show additional details for message about some
*                      error.
*
*    Input : SY-LISEL
*            HIDE_BUFFER    ( refilled )
*            HIDE_TEXT      ( refilled or empty )
*
*    Global: ?
*
*    Output: WRITE to pop-up page
*
*    Effect:
*
  CONSTANTS: LC_INAME TYPE DD02L-TABNAME VALUE 'GT_DO',
             LC_SNAME TYPE DD02L-TABNAME VALUE 'RSLGDODATA'.

  RSLGDODATA = HIDE_BUFFER-slgdata.
  REFRESH GT_D_TOP.
  MOVE 'A daemon finished.'(160) TO GS_D_TOP-LINE.
  APPEND GS_D_TOP TO GT_D_TOP.
  CLEAR GS_D_TOP.

  REFRESH GT_DO.
  MOVE RSLGDODATA-DEAMON TO GS_DO-DEAMON.
  MOVE RSLGDODATA-PROBLEM TO GS_DO-PROBLEM.
  APPEND GS_DO TO GT_DO.
  CLEAR GS_DO.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_INAME LC_SNAME
                           CHANGING  GT_FIELDCAT1[] .

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD1 CHANGING GT_EVENTS[].

  GS_LAYOUT-LIST_APPEND     = 'X'.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM = GV_REPID
      I_STRUCTURE_NAME   = LC_SNAME
      IS_LAYOUT          = GS_LAYOUT
      IT_FIELDCAT        = GT_FIELDCAT1
      I_SAVE             = GC_X
      IT_EVENTS          = GT_EVENTS
    TABLES
      T_OUTTAB           = GT_DO
    EXCEPTIONS
      PROGRAM_ERROR      = 1
      OTHERS             = 2.

  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
          WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM. " SHOW_DO_DETAILS_ALV

*&--------------------------------------------------------------------*
*&      Form  SHOW_PR_DETAILS_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM SHOW_PR_DETAILS_ALV.
************************************************************************
*
*    SHOW_PR_DETAILS - Show additional details for message about some
*                      problem within a daemon.
*
*    Input : SY-LISEL
*            HIDE_BUFFER    ( refilled )
*            HIDE_TEXT      ( refilled or empty )
*
*    Global: ?
*
*    Output: WRITE to pop-up page
*
*    Effect:
*

  CONSTANTS: LC_INAME TYPE DD02L-TABNAME VALUE 'GT_PR',
             LC_SNAME TYPE DD02L-TABNAME VALUE 'RSLGPRDATA'.

  RSLGPRDATA = HIDE_BUFFER-slgdata.
  REFRESH GT_D_TOP.
  MOVE 'A daemon has some problem.'(162) TO GS_D_TOP-LINE.
  APPEND GS_D_TOP TO GT_D_TOP.
  CLEAR GS_D_TOP.

  REFRESH GT_PR.
  MOVE RSLGPRDATA-DEAMON TO GS_PR-DEAMON.
  MOVE RSLGPRDATA-PROBLEM TO GS_PR-PROBLEM.
  APPEND GS_PR TO GT_PR.
  CLEAR GS_PR.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_INAME LC_SNAME
                           CHANGING  GT_FIELDCAT1[] .

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD1 CHANGING GT_EVENTS[].

  GS_LAYOUT-LIST_APPEND     = 'X'.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM = GV_REPID
      I_STRUCTURE_NAME   = LC_SNAME
      IS_LAYOUT          = GS_LAYOUT
      IT_FIELDCAT        = GT_FIELDCAT1
      I_SAVE             = GC_X
      IT_EVENTS          = GT_EVENTS
    TABLES
      T_OUTTAB           = GT_PR
    EXCEPTIONS
      PROGRAM_ERROR      = 1
      OTHERS             = 2.

  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
          WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.
ENDFORM. " SHOW_PR_DETAILS_ALV

*&--------------------------------------------------------------------*
*&      Form  SHOW_EP_DETAILS_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM SHOW_EP_DETAILS_ALV.
************************************************************************
*
*    SHOW_EP_DETAILS - Show additional details for message about some
*                      error.
*
*    Input : SY-LISEL
*            HIDE_BUFFER    ( refilled )
*            HIDE_TEXT      ( refilled or empty )
*
*    Global: ?
*
*    Output: WRITE to pop-up page
*
*    Effect:
*
  CONSTANTS: LC_INAME TYPE DD02L-TABNAME VALUE 'GT_EP',
             LC_SNAME TYPE DD02L-TABNAME VALUE 'RSLGEPDATA'.
  DATA: LV_TEXT(40) TYPE C.

  RSLGEPDATA = HIDE_BUFFER-slgdata.
  REFRESH GT_D_TOP.
  MOVE 'Weitere Angaben bei diesem Meldungstyp'(165) TO GS_D_TOP-LINE.
  APPEND GS_D_TOP TO GT_D_TOP.
  CLEAR GS_D_TOP.

  REFRESH GT_EP.
  MOVE RSLGEPDATA-modulname TO GS_EP-MODULNAME.
  MOVE RSLGEPDATA-LOCATION  TO GS_EP-LOCATION.
  MOVE RSLGEPDATA-ERRTEXT   TO GS_EP-ERRTEXT.
  APPEND GS_EP TO GT_EP.
  CLEAR GS_EP.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_INAME LC_SNAME
                           CHANGING  GT_FIELDCAT1[] .

  CLEAR GS_FIELDCAT.
  LOOP AT GT_FIELDCAT1 INTO GS_FIELDCAT.
    IF GS_FIELDCAT-FIELDNAME = 'MODULNAME'.
      GS_FIELDCAT-COL_POS = 1.
      WRITE 'modulname...........'(123) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
      MODIFY GT_FIELDCAT1 FROM GS_FIELDCAT TRANSPORTING
       COL_POS SELTEXT_S SELTEXT_M SELTEXT_L REPTEXT_DDIC .
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'LOCATION'.
      GS_FIELDCAT-COL_POS = 2.
      MODIFY GT_FIELDCAT1 FROM GS_FIELDCAT TRANSPORTING COL_POS.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'ERRTEXT'.
      GS_FIELDCAT-COL_POS = 3.
      WRITE 'errtext.............'(126) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
      MODIFY GT_FIELDCAT1 FROM GS_FIELDCAT TRANSPORTING COL_POS
        SELTEXT_S SELTEXT_M SELTEXT_L REPTEXT_DDIC.          "#EC *
    ENDIF.
    CLEAR GS_FIELDCAT.
  ENDLOOP.

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD1 CHANGING GT_EVENTS[].

  GS_LAYOUT-LIST_APPEND     = 'X'.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM = GV_REPID
      I_STRUCTURE_NAME   = LC_SNAME
      IS_LAYOUT          = GS_LAYOUT
      IT_FIELDCAT        = GT_FIELDCAT1
      I_SAVE             = GC_X
      IT_EVENTS          = GT_EVENTS
    TABLES
      T_OUTTAB           = GT_EP
    EXCEPTIONS
      PROGRAM_ERROR      = 1
      OTHERS             = 2.

  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
          WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM. " SHOW_EP_DETAILS_ALV

*&--------------------------------------------------------------------*
*&      Form  SHOW_EL_DETAILS_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM SHOW_EL_DETAILS_ALV.
************************************************************************
*
*    SHOW_EL_DETAILS - Show additional details for message about some
*                      error.
*
*    Input : SY-LISEL
*            HIDE_BUFFER    ( refilled )
*            HIDE_TEXT      ( refilled or empty )
*
*    Global: ?
*
*    Output: WRITE to pop-up page
*
*    Effect:
*
  CONSTANTS: LC_INAME TYPE DD02L-TABNAME VALUE 'GT_EL',
             LC_SNAME TYPE DD02L-TABNAME VALUE 'RSLGELDATA'.
  DATA: LV_TEXT(40) TYPE C.

  RSLGELDATA = HIDE_BUFFER-slgdata.
  REFRESH GT_D_TOP.
  MOVE 'Weitere Angaben bei diesem Meldungstyp'(201) TO GS_D_TOP-LINE.
  APPEND GS_D_TOP TO GT_D_TOP.
  CLEAR GS_D_TOP.

  REFRESH GT_EL.
  MOVE RSLGELDATA-modulname TO GS_EL-MODULNAME.
  MOVE RSLGELDATA-LINE      TO GS_EL-LINE.
  MOVE RSLGELDATA-ERRTEXT   TO GS_EL-ERRTEXT.
  APPEND GS_EL TO GT_EL.
  CLEAR GS_EL.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_INAME LC_SNAME
                           CHANGING  GT_FIELDCAT1[] .

  CLEAR GS_FIELDCAT.
  LOOP AT GT_FIELDCAT1 INTO GS_FIELDCAT.
    IF GS_FIELDCAT-FIELDNAME = 'MODULNAME'.
      GS_FIELDCAT-COL_POS = 1.
      WRITE 'modulname...........'(123) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
      MODIFY GT_FIELDCAT1 FROM GS_FIELDCAT TRANSPORTING COL_POS
                    SELTEXT_S SELTEXT_M SELTEXT_L REPTEXT_DDIC.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'LINE'.
      GS_FIELDCAT-COL_POS = 2.
      MODIFY GT_FIELDCAT1 FROM GS_FIELDCAT TRANSPORTING COL_POS.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'ERRTEXT'.
      GS_FIELDCAT-COL_POS = 3.
      WRITE 'errtext.............'(126) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
      MODIFY GT_FIELDCAT1 FROM GS_FIELDCAT TRANSPORTING COL_POS
                    SELTEXT_S SELTEXT_M SELTEXT_L REPTEXT_DDIC.
    ENDIF.
    CLEAR GS_FIELDCAT.
  ENDLOOP.

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD1 CHANGING GT_EVENTS[].

  GS_LAYOUT-LIST_APPEND     = 'X'.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM = GV_REPID
      I_STRUCTURE_NAME   = LC_SNAME
      IS_LAYOUT          = GS_LAYOUT
      IT_FIELDCAT        = GT_FIELDCAT1
      I_SAVE             = GC_X
      IT_EVENTS          = GT_EVENTS
    TABLES
      T_OUTTAB           = GT_EL
    EXCEPTIONS
      PROGRAM_ERROR      = 1
      OTHERS             = 2.

  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
          WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM. " SHOW_EL_DETAILS_ALV

*&--------------------------------------------------------------------*
*&      Form  SHOW_ED_DETAILS_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM SHOW_ED_DETAILS_ALV.
************************************************************************
*
*    SHOW_ED_DETAILS - Show additional details for message about some
*                      error.
*
*    Input : SY-LISEL
*            HIDE_BUFFER    ( refilled )
*            HIDE_TEXT      ( refilled or empty )
*
*    Global: ?
*
*    Output: WRITE to pop-up page
*
*    Effect:
*
  CONSTANTS: LC_INAME TYPE DD02L-TABNAME VALUE 'GT_ED',
             LC_SNAME TYPE DD02L-TABNAME VALUE 'RSLGEDDATA'.
  DATA: LV_TEXT(40) TYPE C.

  RSLGEDDATA = HIDE_BUFFER-slgdata.

  REFRESH GT_D_TOP.
  MOVE 'Weitere Angaben bei diesem Meldungstyp'(167) TO GS_D_TOP-LINE.
  APPEND GS_D_TOP TO GT_D_TOP.
  CLEAR GS_D_TOP.

  REFRESH GT_ED.
  MOVE RSLGEDDATA-modulname TO GS_ED-MODULNAME.
  MOVE RSLGEDDATA-LINE      TO GS_ED-LINE.
  MOVE RSLGEDDATA-ERRTEXT   TO GS_ED-ERRTEXT.
  MOVE RSLGEDDATA-FUNCNAME  TO GS_ED-FUNCNAME.
  MOVE RSLGEDDATA-REASON    TO GS_ED-REASON.
  APPEND GS_ED TO GT_ED.
  CLEAR GS_ED.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_INAME LC_SNAME
                           CHANGING  GT_FIELDCAT1[] .
  CLEAR GS_FIELDCAT.
  LOOP AT GT_FIELDCAT1 INTO GS_FIELDCAT.
    IF GS_FIELDCAT-FIELDNAME = 'MODULNAME'.
      GS_FIELDCAT-COL_POS = 1.
      WRITE 'modulname...........'(123) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'LINE'.
      GS_FIELDCAT-COL_POS = 2.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'ERRTEXT'.
      GS_FIELDCAT-COL_POS = 3.
      WRITE 'errtext.............'(126) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'FUNCNAME'.
      GS_FIELDCAT-COL_POS = 4.
      WRITE 'caller..............'(169) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'REASON'.
      GS_FIELDCAT-COL_POS = 5.
      WRITE 'reason/callee.......'(170) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.
    MODIFY GT_FIELDCAT1 FROM GS_FIELDCAT TRANSPORTING COL_POS
                SELTEXT_S SELTEXT_M SELTEXT_L REPTEXT_DDIC.
    CLEAR GS_FIELDCAT.
  ENDLOOP.

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD1 CHANGING GT_EVENTS[].

  GS_LAYOUT-LIST_APPEND     = 'X'.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM = GV_REPID
      I_STRUCTURE_NAME   = LC_SNAME
      IS_LAYOUT          = GS_LAYOUT
      IT_FIELDCAT        = GT_FIELDCAT1
      I_SAVE             = GC_X
      IT_EVENTS          = GT_EVENTS
    TABLES
      T_OUTTAB           = GT_ED
    EXCEPTIONS
      PROGRAM_ERROR      = 1
      OTHERS             = 2.

  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
          WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM. " SHOW_ED_DETAILS_ALV

*&--------------------------------------------------------------------*
*&      Form  SHOW_ER_DETAILS_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM SHOW_ER_DETAILS_ALV.
************************************************************************
*
*    SHOW_ER_DETAILS - Show additional details for operating system
*                      error message.
*
*    Input : SY-LISEL
*            HIDE_BUFFER    ( refilled )
*            HIDE_TEXT      ( refilled or empty )
*
*    Global: ?
*
*    Output: WRITE to pop-up page
*
*    Effect:
*
  CONSTANTS: LC_INAME TYPE DD02L-TABNAME VALUE 'GT_ER',
             LC_SNAME TYPE DD02L-TABNAME VALUE 'RSLGERDATA'.
  DATA: LV_TEXT(40) TYPE C.

  RSLGERDATA = HIDE_BUFFER-slgdata.
  REFRESH GT_ER.

  MOVE RSLGERDATA-modulname TO GS_ER-MODULNAME.
  MOVE RSLGERDATA-LOCATION  TO GS_ER-LOCATION.
  MOVE RSLGERDATA-ER_ERRNO  TO GS_ER-ER_ERRNO.
  MOVE RSLGERDATA-ERRTEXT   TO GS_ER-ERRTEXT.
  APPEND GS_ER TO GT_ER.
  CLEAR GS_ER.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_INAME LC_SNAME
                           CHANGING  GT_FIELDCAT1[] .

  CLEAR GS_FIELDCAT.
  LOOP AT GT_FIELDCAT1 INTO GS_FIELDCAT.
    IF GS_FIELDCAT-FIELDNAME = 'MODULNAME'.
      GS_FIELDCAT-COL_POS = 1.
      WRITE 'modulname...........'(123) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'LOCATION'.
      GS_FIELDCAT-COL_POS = 2.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'ER_ERRNO'.
      GS_FIELDCAT-COL_POS = 3.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'ERRTEXT'.
      GS_FIELDCAT-COL_POS = 4.
      WRITE 'errtext.............'(126) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.
    MODIFY GT_FIELDCAT1 FROM GS_FIELDCAT TRANSPORTING COL_POS
                SELTEXT_S SELTEXT_M SELTEXT_L REPTEXT_DDIC.
    CLEAR GS_FIELDCAT.
  ENDLOOP.

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD1 CHANGING GT_EVENTS[].

  GS_LAYOUT-LIST_APPEND     = 'X'.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM = GV_REPID
      I_STRUCTURE_NAME   = LC_SNAME
      IS_LAYOUT          = GS_LAYOUT
      IT_FIELDCAT        = GT_FIELDCAT1
      I_SAVE             = GC_X
      IT_EVENTS          = GT_EVENTS
    TABLES
      T_OUTTAB           = GT_ER
    EXCEPTIONS
      PROGRAM_ERROR      = 1
      OTHERS             = 2.

  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
          WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

  PERFORM PUT_ERRNO_INTO_ENTRIESTAB USING RSLGERDATA-er_errno.

ENDFORM. " SHOW_ER_DETAILS_ALV

*&--------------------------------------------------------------------*
*&      Form  SHOW_EX_DETAILS_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM SHOW_EX_DETAILS_ALV.
************************************************************************
*
*    SHOW_EX_DETAILS - Show additional details for dap_dext
*
*    Input : SY-LISEL
*            HIDE_BUFFER    ( refilled )
*            HIDE_TEXT      ( refilled or empty )
*
*    Global: ?
*
*    Output: WRITE to pop-up page
*
*    Effect:
*
  CONSTANTS: LC_INAME TYPE DD02L-TABNAME VALUE 'GT_EX',
              LC_SNAME TYPE DD02L-TABNAME VALUE 'RSLGEXDATA'.
  DATA: LV_TEXT(40) TYPE C.

  RSLGEXDATA = HIDE_BUFFER-slgdata.

  REFRESH GT_EX.
  MOVE RSLGEXDATA-modulname TO GS_EX-MODULNAME.
  MOVE RSLGEXDATA-LOCATION  TO GS_EX-LOCATION.
  MOVE RSLGEXDATA-T100      TO GS_EX-T100.
  MOVE RSLGEXDATA-T100PARMS TO GS_EX-T100PARMS.
  APPEND GS_EX TO GT_EX.
  CLEAR GS_EX.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_INAME LC_SNAME
                           CHANGING  GT_FIELDCAT1[] .

  CLEAR GS_FIELDCAT.
  LOOP AT GT_FIELDCAT1 INTO GS_FIELDCAT.
    IF GS_FIELDCAT-FIELDNAME = 'MODULNAME'.
      GS_FIELDCAT-COL_POS = 1.
      WRITE 'modulname...........'(123) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'LOCATION'.
      GS_FIELDCAT-COL_POS = 2.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'T100'.
      GS_FIELDCAT-COL_POS = 3.
      WRITE 'T100................'(127) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'T100PARMS'.
      GS_FIELDCAT-COL_POS = 4.
      WRITE 'parameters..........'(135) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.
    MODIFY GT_FIELDCAT1 FROM GS_FIELDCAT TRANSPORTING COL_POS
                SELTEXT_S SELTEXT_M SELTEXT_L REPTEXT_DDIC.
    CLEAR GS_FIELDCAT.
  ENDLOOP.

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD1 CHANGING GT_EVENTS[].

  GS_LAYOUT-LIST_APPEND     = 'X'.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM = GV_REPID
      I_STRUCTURE_NAME   = LC_SNAME
      IS_LAYOUT          = GS_LAYOUT
      IT_FIELDCAT        = GT_FIELDCAT1
      I_SAVE             = GC_X
      IT_EVENTS          = GT_EVENTS
    TABLES
      T_OUTTAB           = GT_EX
    EXCEPTIONS
      PROGRAM_ERROR      = 1
      OTHERS             = 2.

  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
          WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM. " SHOW_EX_DETAILS_ALV

*&--------------------------------------------------------------------*
*&      Form  SHOW_SQL_DETAILS_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM SHOW_SQL_DETAILS_ALV.
************************************************************************
*
*    SHOW_SQL_DETAILS - Show additional details for data base management
*                      system error message.
*
*    Input : SY-LISEL
*            HIDE_BUFFER    ( refilled )
*            HIDE_TEXT      ( refilled or empty )
*
*    Global: ?
*
*    Output: WRITE to pop-up page
*
*    Effect:
*

  CONSTANTS: LC_INAME TYPE DD02L-TABNAME VALUE 'GT_SQL',
             LC_SNAME TYPE DD02L-TABNAME VALUE 'RSLGSQLDAT'.
  DATA: LV_TEXT(40) TYPE C.

  RSLGSQLDAT = HIDE_BUFFER-slgdata.

  REFRESH GT_SQL.
  MOVE RSLGSQLDAT-MODULNAME  TO GS_SQL-MODULNAME.
  MOVE RSLGSQLDAT-LINENUMBER TO GS_SQL-LINENUMBER.
  MOVE RSLGSQLDAT-SQLFUNC    TO GS_SQL-SQLFUNC.
  MOVE RSLGSQLDAT-TABNAME    TO GS_SQL-TABNAME.
  MOVE RSLGSQLDAT-SQLCODE    TO GS_SQL-SQLCODE.
  APPEND GS_SQL TO GT_SQL.
  CLEAR GS_SQL.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_INAME LC_SNAME
                           CHANGING  GT_FIELDCAT1[] .

  CLEAR GS_FIELDCAT.
  LOOP AT GT_FIELDCAT1 INTO GS_FIELDCAT.
    IF GS_FIELDCAT-FIELDNAME = 'MODULNAME'.
      GS_FIELDCAT-COL_POS = 1.
      WRITE 'modulname...........'(123) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'LINENUMBER'.
      GS_FIELDCAT-COL_POS = 2.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'SQLFUNC'.
      GS_FIELDCAT-COL_POS = 3.
      WRITE 'sqlfunct............'(128) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'TABNAME'.
      GS_FIELDCAT-COL_POS = 4.
      WRITE 'tabname.............'(129) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'SQLCODE'.
      GS_FIELDCAT-COL_POS = 4.
      WRITE 'sqlcode.............'(130) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'UNUSED_SQL'.
      GS_FIELDCAT-TECH = GC_X.
      MODIFY GT_FIELDCAT1 FROM GS_FIELDCAT INDEX SY-INDEX
                                TRANSPORTING TECH.
      CLEAR GS_FIELDCAT.
      CONTINUE.
    ENDIF.
    MODIFY GT_FIELDCAT1 FROM GS_FIELDCAT TRANSPORTING COL_POS
                SELTEXT_S SELTEXT_M SELTEXT_L REPTEXT_DDIC.
    CLEAR GS_FIELDCAT.
  ENDLOOP.

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD1 CHANGING GT_EVENTS[].

  GS_LAYOUT-LIST_APPEND     = 'X'.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM = GV_REPID
      I_STRUCTURE_NAME   = LC_SNAME
      IS_LAYOUT          = GS_LAYOUT
      IT_FIELDCAT        = GT_FIELDCAT1
      I_SAVE             = GC_X
      IT_EVENTS          = GT_EVENTS
    TABLES
      T_OUTTAB           = GT_SQL
    EXCEPTIONS
      PROGRAM_ERROR      = 1
      OTHERS             = 2.

  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
          WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM. " SHOW_SQL_DETAILS_ALV

*&--------------------------------------------------------------------*
*&      Form  SHOW_DBI_DETAILS_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM SHOW_DBI_DETAILS_ALV.
************************************************************************
*
*    SHOW_DBI_DETAILS - Show additional details for data base management
*                      system error message.
*
*    Input : SY-LISEL
*            HIDE_BUFFER    ( refilled )
*            HIDE_TEXT      ( refilled or empty )
*
*    Global: ?
*
*    Output: WRITE to pop-up page
*
*    Effect:
*
  CONSTANTS: LC_INAME TYPE DD02L-TABNAME VALUE 'GT_DBI',
             LC_SNAME TYPE DD02L-TABNAME VALUE 'RSLGDBIDAT'.
  DATA: LV_TEXT(40) TYPE C.

  RSLGDBIDAT = HIDE_BUFFER-slgdata.
  REFRESH GT_DBI.
  MOVE RSLGDBIDAT-MODULNAME  TO GS_DBI-MODULNAME.
  MOVE RSLGDBIDAT-LINENUMBER TO GS_DBI-LINENUMBER.
  MOVE RSLGDBIDAT-PARAMETER1 TO GS_DBI-PARAMETER1.
  MOVE RSLGDBIDAT-PARAMETER2 TO GS_DBI-PARAMETER2.
  APPEND GS_DBI TO GT_DBI.
  CLEAR GS_DBI.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_INAME LC_SNAME
                            CHANGING GT_FIELDCAT1[] .

  CLEAR GS_FIELDCAT.
  LOOP AT GT_FIELDCAT1 INTO GS_FIELDCAT.
    IF GS_FIELDCAT-FIELDNAME = 'MODULNAME'.
      GS_FIELDCAT-COL_POS = 1.
      WRITE 'modulname...........'(123) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'LINENUMBER'.
      GS_FIELDCAT-COL_POS = 2.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'PARAMETER1'.
      GS_FIELDCAT-COL_POS = 3.
      WRITE 'tabname.............'(129) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'PARAMETER2'.
      GS_FIELDCAT-COL_POS = 4.
      WRITE 'fieldname...........'(171) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'UNUSED_DBI'.
       GS_FIELDCAT-TECH = GC_X.
    ENDIF.
    MODIFY GT_FIELDCAT1 FROM GS_FIELDCAT TRANSPORTING TECH
              COL_POS SELTEXT_S SELTEXT_M SELTEXT_L REPTEXT_DDIC.
    CLEAR GS_FIELDCAT.
  ENDLOOP.

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD1 CHANGING GT_EVENTS[].

  GS_LAYOUT-LIST_APPEND     = 'X'.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM = GV_REPID
      I_STRUCTURE_NAME   = LC_SNAME
      IS_LAYOUT          = GS_LAYOUT
      IT_FIELDCAT        = GT_FIELDCAT1
      I_SAVE             = GC_X
      IT_EVENTS          = GT_EVENTS
    TABLES
      T_OUTTAB           = GT_DBI
    EXCEPTIONS
      PROGRAM_ERROR      = 1
      OTHERS             = 2.

  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
          WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM. " SHOW_DBI_DETAILS_ALV

*&--------------------------------------------------------------------*
*&      Form  SHOW_DD_DETAILS_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM SHOW_DD_DETAILS_ALV.
************************************************************************
*
*    SHOW_DD_DETAILS - Show additional details for data base management
*                      system error message.
*
*    Input : SY-LISEL
*            HIDE_BUFFER    ( refilled )
*            HIDE_TEXT      ( refilled or empty )
*
*    Global: ?
*
*    Output: WRITE to pop-up page
*
*    Effect:
*
  CONSTANTS: LC_INAME TYPE DD02L-TABNAME VALUE 'GT_DD',
             LC_SNAME TYPE DD02L-TABNAME VALUE 'RSLGDDDATA'.
  DATA: LV_TEXT(40) TYPE C.

  RSLGDDDATA = HIDE_BUFFER-slgdata.

  REFRESH GT_DD.
  MOVE RSLGDDDATA-MODULNAME TO GS_DD-MODULNAME.
  MOVE RSLGDDDATA-LOCATION  TO GS_DD-LOCATION.
  MOVE RSLGDDDATA-T100      TO GS_DD-T100.
  MOVE RSLGDDDATA-SQLCODE   TO GS_DD-SQLCODE.
  MOVE RSLGDDDATA-ERRTEXT   TO GS_DD-ERRTEXT.
  APPEND GS_DD TO GT_DD.
  CLEAR GS_DD.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_INAME LC_SNAME
                           CHANGING  GT_FIELDCAT1[] .

  CLEAR GS_FIELDCAT.
  LOOP AT GT_FIELDCAT1 INTO GS_FIELDCAT.
    IF GS_FIELDCAT-FIELDNAME = 'MODULNAME'.
      GS_FIELDCAT-COL_POS = 1.
      WRITE 'modulname...........'(123) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'LOCATION'.
      GS_FIELDCAT-COL_POS = 2.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'T100'.
      GS_FIELDCAT-COL_POS = 3.
      WRITE 'T100................'(127) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'SQLCODE'.
      GS_FIELDCAT-COL_POS = 4.
      WRITE 'sqlcode.............'(130) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'ERRTEXT'.
      GS_FIELDCAT-COL_POS = 5.
      WRITE 'errtext.............'(126) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.
    MODIFY GT_FIELDCAT1 FROM GS_FIELDCAT TRANSPORTING COL_POS
                SELTEXT_S SELTEXT_M SELTEXT_L REPTEXT_DDIC.
    CLEAR GS_FIELDCAT.
  ENDLOOP.

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD1 CHANGING GT_EVENTS[].

  GS_LAYOUT-LIST_APPEND     = 'X'.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM = GV_REPID
      I_STRUCTURE_NAME   = LC_SNAME
      IS_LAYOUT          = GS_LAYOUT
      IT_FIELDCAT        = GT_FIELDCAT1
      I_SAVE             = GC_X
      IT_EVENTS          = GT_EVENTS
    TABLES
      T_OUTTAB           = GT_DD
    EXCEPTIONS
      PROGRAM_ERROR      = 1
      OTHERS             = 2.

  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
          WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM. " SHOW_DD_DETAILS_ALV

*&--------------------------------------------------------------------*
*&      Form  SHOW_AB_DETAILS_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM SHOW_AB_DETAILS_ALV.
************************************************************************
*
*    SHOW_AB_DETAILS - Show additional details for ABAP entry
*
*    Input : SY-LISEL
*            HIDE_BUFFER    ( refilled )
*            HIDE_TEXT      ( refilled or empty )
*
*    Global: ?
*
*    Output: WRITE to pop-up page
*
*    Effect:
*
  CONSTANTS: LC_INAME TYPE DD02L-TABNAME VALUE 'GT_AB',
             LC_SNAME TYPE DD02L-TABNAME VALUE 'RSLGABDATA'.
  DATA: LV_TEXT(40) TYPE C.

  RSLGABDATA = HIDE_BUFFER-slgdata.
  REFRESH GT_D_TOP.
  MOVE 'Meldung vom ABAP-Prozessor'(316) TO GS_D_TOP-LINE.
  APPEND GS_D_TOP TO GT_D_TOP.
  CLEAR GS_D_TOP.

  REFRESH GT_AB.
  MOVE RSLGABDATA-MODULNAME TO GS_AB-MODULNAME.
  MOVE RSLGABDATA-LOCATION  TO GS_AB-LOCATION.
  MOVE RSLGABDATA-PROGRAM   TO GS_AB-PROGRAM.
  MOVE RSLGABDATA-GEN_OR_RUN TO GS_AB-GEN_OR_RUN.
  MOVE RSLGABDATA-PARAMETERS TO GS_AB-PARAMETERS.
  APPEND GS_AB TO GT_AB.
  CLEAR GS_AB.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_INAME LC_SNAME
                           CHANGING  GT_FIELDCAT1[] .

  CLEAR GS_FIELDCAT.
  LOOP AT GT_FIELDCAT1 INTO GS_FIELDCAT.
    IF GS_FIELDCAT-FIELDNAME = 'MODULNAME'.
      GS_FIELDCAT-COL_POS = 1.
      WRITE 'modulname...........'(123) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'LOCATION'.
      GS_FIELDCAT-COL_POS = 2.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'PROGRAM'.
      GS_FIELDCAT-COL_POS = 3.
      WRITE 'program.............'(133) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'GEN_OR_RUN'.
      GS_FIELDCAT-COL_POS = 4.
      WRITE 'gen_or_run..........'(134) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'PARAMETERS'.
      GS_FIELDCAT-COL_POS = 5.
      WRITE 'parameters..........'(135) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.
    MODIFY GT_FIELDCAT1 FROM GS_FIELDCAT TRANSPORTING COL_POS
                SELTEXT_S SELTEXT_M SELTEXT_L REPTEXT_DDIC.
    CLEAR GS_FIELDCAT.
  ENDLOOP.

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD1 CHANGING GT_EVENTS[].

  GS_LAYOUT-LIST_APPEND     = 'X'.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM = GV_REPID
      I_STRUCTURE_NAME   = LC_SNAME
      IS_LAYOUT          = GS_LAYOUT
      IT_FIELDCAT        = GT_FIELDCAT1
      I_SAVE             = GC_X
      IT_EVENTS          = GT_EVENTS
    TABLES
      T_OUTTAB           = GT_AB
    EXCEPTIONS
      PROGRAM_ERROR      = 1
      OTHERS             = 2.

  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
          WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM. " SHOW_AB_DETAILS_ALV

*&--------------------------------------------------------------------*
*&      Form  SHOW_AX_DETAILS_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM SHOW_AX_DETAILS_ALV.
************************************************************************
*
*    SHOW_AX_DETAILS - Show additional details for ABAP extension entry
*
*    Input : SY-LISEL
*            HIDE_BUFFER    ( refilled )
*            HIDE_TEXT      ( refilled or empty )
*
*    Global: ?
*
*    Output: WRITE to pop-up page
*
*    Effect:
*

  DATA: L21_LAST_TEXT       TYPE MSGTEXT_T  " Long!
      , L21_P_DUMMY(2)      TYPE P
      , L21_DUMMY_slgltrm   LIKE AN_ENTRY-slgltrm
      , L21_DUMMY_slgmode   LIKE AN_ENTRY-slgmode
      , L21_DUMMY_CURTIME(16)
      , L21_DUMMY_ERRNO(6)
      , L21_DUMMY_T100(5)
      .
  CONSTANTS: LC_INAME TYPE DD02L-TABNAME VALUE 'GT_AX',
             LC_SNAME TYPE DD02L-TABNAME VALUE 'RSLGAXDATA'.
  DATA: LV_TEXT(40) TYPE C.

  RSLGAXDATA = HIDE_BUFFER-slgdata.
  REFRESH GT_D_TOP.
  MOVE 'ABAP Zusatzinformationen'(317) TO GS_D_TOP-LINE.
  APPEND GS_D_TOP TO GT_D_TOP.
  CLEAR GS_D_TOP.

  REFRESH GT_AX.
  MOVE RSLGAXDATA-TEXTNAME TO GS_AX-TEXTNAME.
  MOVE RSLGAXDATA-LINE     TO GS_AX-LINE.
  MOVE RSLGAXDATA-EVENT    TO GS_AX-EVENT.
  APPEND GS_AX TO GT_AX.
  CLEAR GS_AX.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_INAME LC_SNAME
                           CHANGING  GT_FIELDCAT1[] .

  CLEAR GS_FIELDCAT.
  LOOP AT GT_FIELDCAT1 INTO GS_FIELDCAT.
    IF GS_FIELDCAT-FIELDNAME = 'TEXTNAME'.
      WRITE 'textname............'(136) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'UNUSED'.
      GS_FIELDCAT-TECH = GC_X.
    ENDIF.
    MODIFY GT_FIELDCAT1 FROM GS_FIELDCAT.
    CLEAR GS_FIELDCAT.
  ENDLOOP.

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD1 CHANGING GT_EVENTS[].

  GS_LAYOUT-LIST_APPEND     = 'X'.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM = GV_REPID
      I_STRUCTURE_NAME   = LC_SNAME
      IS_LAYOUT          = GS_LAYOUT
      IT_FIELDCAT        = GT_FIELDCAT1
      I_SAVE             = GC_X
      IT_EVENTS          = GT_EVENTS
    TABLES
      T_OUTTAB           = GT_AX
    EXCEPTIONS
      PROGRAM_ERROR      = 1
      OTHERS             = 2.

  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
          WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

  IF HIDE_ABAP_INFO IS INITIAL.
    "Sorry.
  ELSE.
    REFRESH GT_D_END.
    MOVE 'Information from the preceeding ABAP problem entry'(139) TO
                                                       GS_D_END-LINE.
    APPEND GS_D_END TO GT_D_END.
    CLEAR GS_D_END.
    APPEND GS_D_END TO GT_D_END.

    PERFORM USE_TABE_AND_DATA USING
        HIDE_ABAP_INFO-first_AREA
        HIDE_ABAP_INFO-first_SUBID
        HIDE_ABAP_INFO " its beginning is like <INC.STRUC. RSLGABDATA>
        L21_LAST_TEXT L21_P_DUMMY
        L21_DUMMY_slgltrm L21_DUMMY_slgmode L21_DUMMY_CURTIME
        L21_DUMMY_ERRNO L21_DUMMY_T100 .
    "Cannot find any parameters without filled dummy fields ??
    PERFORM SHOW_TEXT_ALV USING L21_LAST_TEXT.

    CONCATENATE 'modulname...........'(123) HIDE_ABAP_INFO-modulname
                              INTO GS_D_END-LINE SEPARATED BY SPACE.
    APPEND GS_D_END TO GT_D_END.
    CLEAR GS_D_END.

    CONCATENATE 'location............'(124) HIDE_ABAP_INFO-LOCATION
                              INTO GS_D_END-LINE SEPARATED BY SPACE.
    APPEND GS_D_END TO GT_D_END.
    CLEAR GS_D_END.

    CONCATENATE 'program.............'(133) HIDE_ABAP_INFO-PROGRAM
                              INTO GS_D_END-LINE SEPARATED BY SPACE.
    APPEND GS_D_END TO GT_D_END.
    CLEAR GS_D_END.

    CONCATENATE 'gen_or_run..........'(134) HIDE_ABAP_INFO-GEN_OR_RUN
                              INTO GS_D_END-LINE SEPARATED BY SPACE.
    APPEND GS_D_END TO GT_D_END.
    CLEAR GS_D_END.

    CONCATENATE 'parameters..........'(135) HIDE_ABAP_INFO-PARAMETERS
                              INTO GS_D_END-LINE SEPARATED BY SPACE.
    APPEND GS_D_END TO GT_D_END.
    CLEAR GS_D_END.

    PERFORM SHOW_AB_LOOK_T100_SY USING HIDE_ABAP_INFO-parameters.
  ENDIF.

ENDFORM. " SHOW_AX_DETAILS

*&--------------------------------------------------------------------*
*&      Form  SHOW_AB_LOOK_T100_SY
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*      -->A25_PARAMETtext
*---------------------------------------------------------------------*
FORM SHOW_AB_LOOK_T100_SY USING A25_parameters.
************************************************************************
*
*    SHOW_AB_LOOK_T100_SY - Look, wether the parameter field starts
*                           with a key for T100, ARBGB 'SY'.
*
  DATA: BEGIN OF L35_PAR,
          KEY1(1),
          KEY2(1),
          KEY3(1),
          GAP(1),
        END   OF L35_PAR
      , L35_T100(5)
      .

  L35_PAR = A25_parameters.
  IF  L35_PAR-GAP  =  ' '
  AND L35_PAR-KEY1 >= '0'                                 "#EC PORTABLE
  AND L35_PAR-KEY1 <= '9'                                 "#EC PORTABLE
  AND L35_PAR-KEY2 >= '0'                                 "#EC PORTABLE
  AND L35_PAR-KEY2 <= '9'                                 "#EC PORTABLE
  AND L35_PAR-KEY3 >= '0'                                 "#EC PORTABLE
  AND L35_PAR-KEY3 <= '9'.                                "#EC PORTABLE
    L35_T100+0(2) = 'SY'.
    L35_T100+2(3) = L35_PAR.
    ENTRIESTAB-T100ARBGB = L35_T100+0(2).
    ENTRIESTAB-T100MSGNR = L35_T100+2(3).
    MODIFY ENTRIESTAB INDEX ENTRIESTAB_IX.
" Note: this is only one of a pair of ENTRIESTAB entries.
  ENDIF.
ENDFORM.                    "SHOW_AB_LOOK_T100_SY

FORM SHOW_AD_DETAILS_ALV.
************************************************************************
**    SHOW_AD_DETAILS - Show additional details for ABAP SNAP entry
*
*    Input : SY-LISEL
*            HIDE_BUFFER    ( refilled )
*            HIDE_TEXT      ( refilled or empty )
*
*    Global: ?
*
*    Output: WRITE to pop-up page
*
*    Effect:
*
  DATA: FULLDATE(8)      .

  CONSTANTS: LC_INAME TYPE DD02L-TABNAME VALUE 'GT_AD',
             LC_SNAME TYPE DD02L-TABNAME VALUE 'RSLGADDATA'.

  PERFORM UNLOCK_FUNCTION USING 'SNAP'.
  " Most often off, but this time on.

  RSLGADDATA = HIDE_BUFFER-slgdata.
  FULLDATE+2 = RSLGADDATA-datum.
  IF FULLDATE+2(2) >= '94'.                               "#EC PORTABLE
    FULLDATE(2) = '19'.
  ELSE.
    FULLDATE(2) = '20'.
  ENDIF.

  REFRESH GT_D_TOP.
  MOVE 'ABAP Minidump'(315) TO GS_D_TOP-LINE.
  APPEND GS_D_TOP TO GT_D_TOP.
  CLEAR GS_D_TOP.

  REFRESH GT_AD.
  MOVE FULLDATE TO GS_AD-DATUM.
  MOVE RSLGADDATA-UZEIT TO GS_AD-UZEIT.
  MOVE RSLGADDATA-HOST  TO GS_AD-HOST.
  MOVE RSLGADDATA-USER  TO GS_AD-USER.
  APPEND GS_AD TO GT_AD.
  CLEAR GS_AD.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_INAME LC_SNAME
                           CHANGING  GT_FIELDCAT1[] .
  CLEAR GS_FIELDCAT.
  LOOP AT GT_FIELDCAT1 INTO GS_FIELDCAT.
    IF GS_FIELDCAT-FIELDNAME = 'UNSED_IB'.
      GS_FIELDCAT-TECH = GC_X.
      MODIFY GT_FIELDCAT1 FROM GS_FIELDCAT.
      CLEAR GS_FIELDCAT.
    ENDIF.
  ENDLOOP.

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD1 CHANGING GT_EVENTS[].

  GS_LAYOUT-LIST_APPEND     = 'X'.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM = GV_REPID
      I_STRUCTURE_NAME   = LC_SNAME
      IS_LAYOUT          = GS_LAYOUT
      IT_FIELDCAT        = GT_FIELDCAT1
      I_SAVE             = GC_X
      IT_EVENTS          = GT_EVENTS
    TABLES
      T_OUTTAB           = GT_AD
    EXCEPTIONS
      PROGRAM_ERROR      = 1
      OTHERS             = 2.

  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
          WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM. " SHOW_AD_DETAILS_ALV

*&--------------------------------------------------------------------*
*&      Form  SHOW_IB_DETAILS_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM SHOW_IB_DETAILS_ALV.
************************************************************************
*
*    SHOW_IB_DETAILS - Show additional details for message about
*                      internal buffers, global aeras,...
*
*    Input : SY-LISEL
*            HIDE_BUFFER    ( refilled )
*            HIDE_TEXT      ( refilled or empty )
*
*    Global: ?
*
*    Output: WRITE to pop-up page
*
*    Effect:
*

  CONSTANTS: LC_INAME TYPE DD02L-TABNAME VALUE 'GT_IB',
             LC_SNAME TYPE DD02L-TABNAME VALUE 'RSLGIBDATA'.
  DATA: LV_TEXT(40) TYPE C.

  RSLGIBDATA = HIDE_BUFFER-slgdata.

  REFRESH GT_D_TOP.
  MOVE 'about internal buffer or area.'(172) TO GS_D_TOP-LINE.
  APPEND GS_D_TOP TO GT_D_TOP.
  CLEAR GS_D_TOP.

  REFRESH GT_IB.
  MOVE RSLGIBDATA-IB_NAME TO GS_IB-IB_NAME.
  MOVE RSLGIBDATA-IB_SIZE TO GS_IB-IB_SIZE.
  APPEND GS_IB TO GT_IB.
  CLEAR GS_IB.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_INAME LC_SNAME
                           CHANGING  GT_FIELDCAT1[] .

  CLEAR GS_FIELDCAT.
  LOOP AT GT_FIELDCAT1 INTO GS_FIELDCAT.
    IF GS_FIELDCAT-FIELDNAME = 'IB_NAME'.
      WRITE 'name................'(173) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_S    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M    = LV_TEXT.
      GS_FIELDCAT-SELTEXT_L    = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'UNUSED_IB'.
      GS_FIELDCAT-TECH = GC_X.
    ENDIF.
    MODIFY GT_FIELDCAT1 FROM GS_FIELDCAT.
    CLEAR GS_FIELDCAT.
  ENDLOOP.

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD1 CHANGING GT_EVENTS[].

  GS_LAYOUT-LIST_APPEND     = 'X'.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM = GV_REPID
      I_STRUCTURE_NAME   = LC_SNAME
      IS_LAYOUT          = GS_LAYOUT
      IT_FIELDCAT        = GT_FIELDCAT1
      I_SAVE             = GC_X
      IT_EVENTS          = GT_EVENTS
    TABLES
      T_OUTTAB           = GT_IB
    EXCEPTIONS
      PROGRAM_ERROR      = 1
      OTHERS             = 2.

  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
          WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.
ENDFORM. " SHOW_IB_DETAILS_ALV

*&--------------------------------------------------------------------*
*&      Form  SHOW_PA_DETAILS_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM SHOW_PA_DETAILS_ALV.
************************************************************************
*
*    SHOW_PA_DETAILS - Show additional details for SysLog entry
*                      containing parameters for the following entry.
*
*    Input : SY-LISEL
*            HIDE_BUFFER    ( refilled )
*            HIDE_TEXT      ( refilled or empty )
*
*    Output: WRITE to pop-up page
*
*    Effect:
*
  CONSTANTS: LC_INAME TYPE DD02L-TABNAME VALUE 'GT_IB',
             LC_SNAME TYPE DD02L-TABNAME VALUE 'RSLGIBDATA'.

  REFRESH GT_D_TOP.
  MOVE
  'Parameters, which will be picked up in successor SysLog entry.'(291)
                                                       TO GS_D_TOP-LINE.
  APPEND GS_D_TOP TO GT_D_TOP.
  CLEAR GS_D_TOP.

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD1 CHANGING GT_EVENTS[].

  GS_LAYOUT-LIST_APPEND     = GC_X.
  GS_LAYOUT-NO_COLHEAD      = GC_X.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM = GV_REPID
      I_STRUCTURE_NAME   = LC_SNAME
      IS_LAYOUT          = GS_LAYOUT
      IT_FIELDCAT        = GT_FIELDCAT1
      I_SAVE             = GC_X
      IT_EVENTS          = GT_EVENTS
    TABLES
      T_OUTTAB           = GT_IB
    EXCEPTIONS
      PROGRAM_ERROR      = 1
      OTHERS             = 2.

  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
          WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

  GS_LAYOUT-NO_COLHEAD      = SPACE.


ENDFORM. " SHOW_PA_DETAILS_ALV

*&--------------------------------------------------------------------*
*&      Form  WRITE_DATA_LINE_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*      -->A_SPECIAL  text
*      -->A_DATETIME text
*---------------------------------------------------------------------*
FORM WRITE_DATA_LINE_ALV USING A_SPECIAL A_DATETIME.
************************************************************************
*    WRITE_DATA_LINE - Write one data line into listing.
*
*                      The data for the columns is taken from the fields
*                      of GEN_OUTLINE. The information, which columns
*                      are to be printed and which shall not, are taken
*                      from LAYOUT.
*
*                      There are two special handlings:
*
*    Input : A_SPECIAL  : Where to take the data for some of the right
*                         side columns from. Possible values are:
*                         USE_GEN  ' ': use remaining fields from
*                                       GEN_OUTLINE.
*                         USE_DATA '-': use CUR_LINE_DATA.
*                         OWNCLOCK 'c': use OWNCLOCK_REST.
*                         OWNINFO  'i': use OWNINFO_REST.
*                         OWNUP    'u': use OWNUPDOWN_REST.
*                         OWNDOWN  'd': use OWNUPDOWN_REST.
*                         OWNFILE  'f': use OWNFILE_REST.
*
*    Input : A_DATETIME : a date which will be put into the right hand
*                           side of the output line by overwriting.
*                       or: NO_OV_DATE
*
*    Global constants : NO_OV_DATE, OWNCLOCK, OWNDOWN, OWNFILE, OWNINFO,
*                       OWNUP, USE_DATA, USE_GEN
*    Global variables : CUR_LINE_DATA, GEN_OUTLINE, LAYOUT,
*                       OWNCLOCK_REST, OWNFILE_REST, OWNINFO_REST,
*                       OWNUPDOWN_REST
*    Output: <none>
*
*    Effect: POSITION, WRITE
*

  DATA: L17_STAMP(8)
      , PROBLEM_IND         VALUE ' '
      , LPOS                TYPE I
      , TEXT_POS            TYPE I
      , TEXT_LG             TYPE I
      , COLS                TYPE I
      , TEXT_COLS           TYPE I
      , WORDS_COLS          TYPE I
      , WRAP_AREA           TYPE I
      , USE_COLS            TYPE I
      , USE_COLS2           TYPE I
      , LOOK_COLS           TYPE I
      , FILLED_COLS         TYPE I
      , LINECONT                     " line is a continuation line
      , SEP(1)                       " column seperator
      , BEW_COLOR           TYPE I
      , BEW_NAME(9)         TYPE C
      .

  FIELD-SYMBOLS: <TEXT_PTR>
               , <PTR2>.

  DATA: LV_INT TYPE I.
  SEP = SY-VLINE. " column seperator
  COLS = LAYOUT-PRI_COLUMN.
* If no special number of columns given, then take
*    if online: width of screen window
*    if batch:  width of list.

  IF COLS = 0. COLS = GV_DEFAULT_LINESIZE. ENDIF.

* ODDLINE = SY-LINNO MOD 2.
  IF A_DATETIME NE NO_OV_DATE.
    ODDLINE = 1.
    LV_INT = 1.
  ELSE.
*   This line is a logical new line. (No continuation.)
*   It is neiter easy nor safe to find out:
    LINECONT = ' '. "Most lines are NOT continuation lines.
    CASE A_SPECIAL.
      WHEN OWNCLOCK. " 'c',
      WHEN OWNINFO. " 'i',
      WHEN OWNUP. " 'u',
      WHEN OWNDOWN. " 'd',
      WHEN OWNFILE. " 'f'.
      WHEN USE_DATA.
      WHEN OTHERS.
        IF  GEN_OUTLINE-TEXT+0(1) = '>'
        AND LAST_TASK = GEN_OUTLINE-TASK.
          LINECONT = 'X'.
        ENDIF.
    ENDCASE.
    IF LINECONT = ' '.
      IF ODDLINE = 1.
        ODDLINE = 0.
        LV_INT = 0.
        GS_COLOR-COLOR-COL = COL_NORMAL.
        GS_COLOR-COLOR-INT = 0.
        GS_COLOR-COLOR-INV = 0.
        APPEND GS_COLOR TO GT_COLOR.
        CLEAR GS_COLOR.
      ELSE.
        ODDLINE = 1.
        LV_INT = 1.
        GS_COLOR-COLOR-COL = COL_NORMAL.
        GS_COLOR-COLOR-INT = 1.
        GS_COLOR-COLOR-INV = 0.
        APPEND GS_COLOR TO GT_COLOR.
        CLEAR GS_COLOR.
      ENDIF.
    ELSE.
      IF ODDLINE = 1.
        LV_INT = 1.
        GS_COLOR-COLOR-COL = COL_NORMAL.
        GS_COLOR-COLOR-INT = 1.
        GS_COLOR-COLOR-INV = 0.
        APPEND GS_COLOR TO GT_COLOR.
        CLEAR GS_COLOR.
      ELSE.
        LV_INT = 0.
        GS_COLOR-COLOR-COL = COL_NORMAL.
        GS_COLOR-COLOR-INT = 0.
        GS_COLOR-COLOR-INV = 0.
        APPEND GS_COLOR TO GT_COLOR.
        CLEAR GS_COLOR.
      ENDIF.
    ENDIF.
  ENDIF.   " header / non-header

* *  set size for additional filed
  CASE LAYOUT-NEED_SORT.

    WHEN 'SOFI'.
       LPOS = SOFI_COUNT.
    WHEN 'SOCP'.
       LPOS = SOCP_COUNT.
    WHEN 'SOTI'.
       LPOS = SOTI_COUNT.
    WHEN 'SOPC'.
       LPOS = SOPC_COUNT.
    WHEN 'SOTA'.
       LPOS = SOTA_COUNT.
    WHEN 'SODC'.
       LPOS = SODC_COUNT.
    WHEN 'SOID'.
       LPOS = SOID_COUNT.
    WHEN 'SOTY'.
       LPOS = SOTY_COUNT.

  ENDCASE.

  POSITION 1.
  CLEAR LAST_TASK.

  IF LAYOUT-W_COL_POSI = SAP_YES.
    MOVE GEN_OUTLINE-FILE_NO TO GS_GEN_OUTLINE-FILE_NO.
    MOVE GEN_OUTLINE-POS TO GS_GEN_OUTLINE-POS.
    ADD 18 to LPOS.
  ENDIF.
  MOVE GEN_OUTLINE-DATE_INT TO GS_GEN_OUTLINE-DATE_INT.
  MOVE GEN_OUTLINE-DATE TO GS_GEN_OUTLINE-DATE.
  MOVE GEN_OUTLINE-DATE TO SAVE_GS_OUTLINE_DATE.
    IF GV_INTERNAL_DATE   <> GEN_OUTLINE-DATE.
     INT_USE_DATE-DATE  =  GEN_OUTLINE-DATE.
     ADD 1 TO GV_INTERNAL_NUMBER.
     APPEND INT_USE_DATE.
     GV_INTERNAL_DATE   =  GEN_OUTLINE-DATE.
  ENDIF.
  MOVE GEN_OUTLINE-DATE TO HH_INT_USE_OUTLINE-DATE.
  MOVE GEN_OUTLINE-TIME TO GS_GEN_OUTLINE-TIME.
  MOVE GEN_OUTLINE-TIME TO HH_INT_USE_OUTLINE-TIME.
  MOVE GEN_OUTLINE-TIME TO SAVE_GS_OUTLINE_TIME.
  MOVE GV_INTERNAL_NUMBER TO HH_INT_USE_OUTLINE-NUMBER.
  HH_INT_USE_OUTLINE-USER = GEN_OUTLINE-USER.
*  APPEND HH_INT_USE_OUTLINE TO INT_USE_OUTLINE.
*SOLO
  MOVE GEN_OUTLINE-INSTID TO SAVE_GS_OUTLINE_INSTID.
  MOVE GEN_OUTLINE-INSTID TO GS_GEN_OUTLINE-INSTID.
  ADD 9 TO LPOS.
  IF LAYOUT-W_COL_INST = SAP_YES.
*    MOVE GEN_OUTLINE-INSTID TO GS_GEN_OUTLINE-INSTID.
    ADD 21 TO LPOS.
  ENDIF.

  CASE A_SPECIAL.
    WHEN OWNCLOCK. " 'c',
    WHEN OWNINFO. " 'i',
    WHEN OWNUP. " 'u',
    WHEN OWNDOWN. " 'd',
    WHEN OWNFILE. " 'f'.
    WHEN USE_DATA.
    WHEN OTHERS.
      IF GEN_OUTLINE-CLASID = 'K' OR GEN_OUTLINE-CLASID = 'T'.
        PROBLEM_IND = 'X'.
      ELSE.
        PROBLEM_IND = ' '.
      ENDIF.

      IF LAYOUT-W_COL_TASK = SAP_YES.
        MOVE GEN_OUTLINE-TSKNA TO GS_GEN_OUTLINE-TSKNA.
        MOVE GEN_OUTLINE-TSKNU TO GS_GEN_OUTLINE-TSKNU.
        ADD 8 TO LPOS.
      ENDIF.

*     Note down the task for detection of continuation lines.
      LAST_TASK = GEN_OUTLINE-TASK.

      IF LAYOUT-W_COL_MAND = SAP_YES.
        MOVE GEN_OUTLINE-MAND TO GS_GEN_OUTLINE-MAND.
        ADD 4 TO LPOS.
      ENDIF.

      IF LAYOUT-W_COL_USER = SAP_YES.
        MOVE GEN_OUTLINE-USER TO GS_GEN_OUTLINE-USER.
        ADD 13 TO LPOS.
      ENDIF.

      IF LAYOUT-W_COL_TRAN = SAP_YES.
        MOVE GEN_OUTLINE-TRANSCODE TO GS_GEN_OUTLINE-TRANSCODE.
        ADD 6 TO LPOS.
      ENDIF.

      IF LAYOUT-W_COL_PROG = SAP_YES.
        MOVE GEN_OUTLINE-REPNA TO GS_GEN_OUTLINE-REPNA.
        ADD 9 TO LPOS.
      ENDIF.

      IF LAYOUT-W_COL_TERM = SAP_YES.
        MOVE GEN_OUTLINE-TERMINAL TO GS_GEN_OUTLINE-TERMINAL.
        ADD 9 TO LPOS.
      ENDIF.

      IF LAYOUT-W_COL_DEVC = SAP_YES.
        MOVE GEN_OUTLINE-DEVCLASS TO GS_GEN_OUTLINE-DEVCLASS.
        ADD 6 TO LPOS.
      ENDIF.
DATA : LV_ICON TYPE ICONNAME,
       LV_TEXT TYPE CHAR40.
      ADD 6 TO LPOS.
      CASE GEN_OUTLINE-MONBEW(1).
*        WHEN 'R'. BEW_COLOR    = 6. BEW_NAME = 'Rot'(990).
*        WHEN 'Y'. BEW_COLOR    = 3. BEW_NAME = 'Gelb'(991).
*        WHEN 'G'. BEW_COLOR    = 5. BEW_NAME = 'Grün'(992).
*        WHEN OTHERS. BEW_COLOR = 0. BEW_NAME = 'Weiß'(993).
        WHEN 'R'. BEW_COLOR    = 1.
           LV_TEXT = 'sehr hohe Priorität'(140).
           LV_ICON = 'ICON_LED_RED'.
        WHEN 'Y'. BEW_COLOR    = 2.
           LV_TEXT = 'hohe Priorität'(141).
           LV_ICON = 'ICON_LED_YELLOW'.
        WHEN 'G'. BEW_COLOR    = 3.
           LV_TEXT = 'Warnung'(142).
           LV_ICON = 'ICON_LED_GREEN'.
        WHEN OTHERS. BEW_COLOR = 0.
            LV_TEXT = 'Information'(116).
            LV_ICON = 'ICON_WD_RADIO_BUTTON_EMPTY'.
        PERFORM icon_tool_tips_create USING LV_ICON  LV_TEXT
                                  CHANGING GS_GEN_OUTLINE-ICON.


      ENDCASE.

      IF GEN_OUTLINE-IS_TITLE = ' '.
        IF BEW_COLOR >< 0.                        "Farbe

          IF LAYOUT-W_COL_TABE = SAP_YES.                    "***hjl
            IF LV_INT = 0.
              LV_INT = 1.
            ELSE.
              LV_INT = 0.
            ENDIF.

            MOVE GEN_OUTLINE-AREA TO GS_GEN_OUTLINE-AREA.
            PERFORM icon_tool_tips_create USING LV_ICON LV_TEXT
                                  CHANGING GS_GEN_OUTLINE-ICON.
            MOVE GEN_OUTLINE-SUBID TO GS_GEN_OUTLINE-SUBID.
            ADD 6 TO LPOS.

          ENDIF.
        ELSE.
          IF LAYOUT-W_COL_TABE = SAP_YES.                    "***hjl
            MOVE GEN_OUTLINE-AREA TO GS_GEN_OUTLINE-AREA.
            MOVE GEN_OUTLINE-SUBID TO GS_GEN_OUTLINE-SUBID.
            ADD 6 TO LPOS.
          ENDIF.
        ENDIF.
      ELSE.
        IF LAYOUT-W_COL_TABE = SAP_YES.                    "***hjl
          MOVE GEN_OUTLINE-AREA TO GS_GEN_OUTLINE-AREA.
          MOVE GEN_OUTLINE-SUBID TO GS_GEN_OUTLINE-SUBID.
          ADD 6 TO LPOS.
        ENDIF.
        IF LAYOUT-W_COL_BEW = SAP_YES.     "bewertung ausschaltbar
          MOVE GEN_OUTLINE-BEWERTUNG TO GS_GEN_OUTLINE-BEWERTUNG.
          ADD 6 TO LPOS.
        ENDIF.
      ENDIF.

      MOVE GT_COLOR TO GS_GEN_OUTLINE-COLOR.
      CLEAR GS_COLOR.
      REFRESH GT_COLOR.
      ADD 2 TO LPOS.
*     Write out the text. It may be very long.
*      LPOS = 77.
      TEXT_POS = LPOS.
      POSITION     LPOS.
      TEXT_LG = GEN_OUTLINE-TEXT_LG.  " strlen( gen_outline-text ) .
      TEXT_COLS = COLS - TEXT_POS + 1 - 1. " -1 because of right frame

      IF TEXT_COLS < 10.
*       Only very few columns. Dont try any complicated things at all.
        MOVE GEN_OUTLINE-TEXT TO GS_GEN_OUTLINE-TEXT.
      ELSEIF TEXT_LG <= TEXT_COLS.
        MOVE GEN_OUTLINE-TEXT TO GS_GEN_OUTLINE-TEXT.
      ELSE.
*       Line wrap the text into this text columns.
        ASSIGN GEN_OUTLINE-TEXT(TEXT_LG) TO <TEXT_PTR>. " All the text.
        WRAP_AREA = TEXT_COLS / 3.
        DO.         " while TEXT_LG > 0.
          MOVE SAVE_GS_OUTLINE_DATE   TO GS_GEN_OUTLINE-DATE.
          MOVE SAVE_GS_OUTLINE_INSTID TO GS_GEN_OUTLINE-INSTID.
          MOVE SAVE_GS_OUTLINE_TIME   TO GS_GEN_OUTLINE-TIME.

          USE_COLS = TEXT_COLS .
          IF TEXT_LG < USE_COLS.
            USE_COLS = TEXT_LG.
          ENDIF.
          LOOK_COLS = TEXT_COLS + 1. "Look one char bejond break pt.
          IF TEXT_LG < LOOK_COLS.
            LOOK_COLS = TEXT_LG.
          ENDIF.
          ASSIGN <TEXT_PTR>(LOOK_COLS) TO <PTR2>.
          FILLED_COLS = STRLEN( <PTR2> ) .
          IF FILLED_COLS = USE_COLS.
*           Fine fit.
*           USE_COLS o.k.
          ELSEIF FILLED_COLS < USE_COLS.
*           White space at break point.
*           USE_COLS o.k.
          ELSE.
*           A word across the break point.
            USE_COLS2 = USE_COLS.
            DO WRAP_AREA TIMES.
              ASSIGN <TEXT_PTR>+USE_COLS2(1) TO <PTR2>.
              IF <PTR2> = ' '. EXIT. ENDIF.
              USE_COLS2 = USE_COLS2 - 1.
            ENDDO.
            IF <PTR2> = ' '.
*             I found a word boundary.
              USE_COLS = USE_COLS2.
            ELSE.
*             No word boundary found. Break the word anywhere.
            ENDIF.
          ENDIF. " word/line wrapping.
          ASSIGN <TEXT_PTR>(USE_COLS) TO <TEXT_PTR>.
*         Now write a pice of text.
          SUBTRACT 1 FROM TEXT_POS.
          IF GS_GEN_OUTLINE-TEXT IS INITIAL.
            MOVE <TEXT_PTR> TO GS_GEN_OUTLINE-TEXT.
          ELSE.
            APPEND HH_INT_USE_OUTLINE TO INT_USE_OUTLINE.
            APPEND GS_GEN_OUTLINE TO GT_GEN_OUTLINE.
            CLEAR GS_GEN_OUTLINE.
            APPEND GS_HIDE_BUFFER TO GT_HIDE_BUFFER.
            CLEAR GS_HIDE_BUFFER.
            MOVE SAVE_GS_OUTLINE_DATE   TO GS_GEN_OUTLINE-DATE.
            MOVE SAVE_GS_OUTLINE_INSTID TO GS_GEN_OUTLINE-INSTID.
            MOVE SAVE_GS_OUTLINE_TIME   TO GS_GEN_OUTLINE-TIME.
            MOVE <TEXT_PTR> TO GS_GEN_OUTLINE-TEXT.
          ENDIF.
          TEXT_LG = TEXT_LG - USE_COLS.
          IF TEXT_LG <= 0. EXIT. ENDIF.
*         There is some text left, which did not fit on this line.
*         Catch it and start over for the next line.
          ASSIGN <TEXT_PTR>+USE_COLS(TEXT_LG) TO <TEXT_PTR>.
*         Skip to next word. (Only one space because of COMPRESS.)
          ASSIGN <TEXT_PTR>(1) TO <PTR2>.
          IF <PTR2> = ' '.
            IF TEXT_LG > 1.
              TEXT_LG = TEXT_LG - 1.
              ASSIGN <TEXT_PTR>+1(TEXT_LG) TO <TEXT_PTR>.
            ELSE.
              EXIT. " Only blanks left.
            ENDIF.
          ENDIF.

        ENDDO.          " while TEXT_LG > 0.
      ENDIF. "      Line wrap the text into this text columns.

  ENDCASE.  " A_SPECIAL

* Switch all back to normal again.
*
  LV_INT = 0.
  APPEND HH_INT_USE_OUTLINE TO INT_USE_OUTLINE.
  APPEND GS_GEN_OUTLINE TO GT_GEN_OUTLINE.
  CLEAR GS_GEN_OUTLINE.
  APPEND GS_HIDE_BUFFER TO GT_HIDE_BUFFER.
  CLEAR GS_HIDE_BUFFER.

ENDFORM.                    "WRITE_DATA_LINE_ALV

*EJECT
FORM OVERLAY_WITH_OTHER_DATA USING A_OVERLAY_AREA A_SPECIAL.
  CASE A_SPECIAL.
    WHEN OWNCLOCK. " 'c',
      A_OVERLAY_AREA = OWNCLOCK_REST.
    WHEN OWNINFO.  " 'i',
      A_OVERLAY_AREA = OWNINFO_REST.
    WHEN OWNUP.    " 'u',
      A_OVERLAY_AREA = OWNUPDOWN_REST.
    WHEN OWNDOWN.  " 'd',
      A_OVERLAY_AREA = OWNUPDOWN_REST.
    WHEN OWNFILE.  " 'f'.
      A_OVERLAY_AREA = OWNFILE_REST.
    WHEN USE_DATA.
      A_OVERLAY_AREA = CUR_LINE_DATA.
  ENDCASE.
ENDFORM. " OVERLAY_WITH_OTHER_DATA.

*EJECT
FORM OVERLAY_WITH_DATETIME USING A17_LINE A17_TIME_STAMP.
************************************************************************
*
*    OVERLAY_WITH_DATETIME - ???
*
*    Input AN_ENTRY_TIME_STAMP      Format: yyyymmdd (and more)
*
*    Effect: WRITE
*
  DATA L17_STAMP(8).
  DATA L17_POS TYPE I.

  IF A17_TIME_STAMP NE NO_OV_DATE.
    L17_STAMP = A17_TIME_STAMP.
    L17_POS = SY-LINSZ.
    IF L17_POS > 80.
      L17_POS = 80.
    ENDIF.
    L17_POS = L17_POS - 8 .
    L17_POS = L17_POS - 1 . "DEB.. Only 79 out of 80 columns can be
    "DEB.. used.
    WRITE L17_STAMP+6 TO A17_LINE+L17_POS(2). ADD 2 TO L17_POS.
    WRITE '.'         TO A17_LINE+L17_POS(1). ADD 1 TO L17_POS.
    WRITE L17_STAMP+4 TO A17_LINE+L17_POS(2). ADD 2 TO L17_POS.
    WRITE '.'         TO A17_LINE+L17_POS(1). ADD 1 TO L17_POS.
    WRITE L17_STAMP+2 TO A17_LINE+L17_POS(2). ADD 2 TO L17_POS.
    L17_POS = L17_POS - 8 - 1 - 6 .
    WRITE 'Datum:;;'(106)    TO A17_LINE+L17_POS(6).
  ENDIF. "NO_OV_DATE
ENDFORM.                    "OVERLAY_WITH_DATETIME


FORM WRITE_REST_OF_ENTRY_ALV USING TEXT_LENGTH.
************************************************************************
*    WRITE_REST_OF_ENTRY - ??
*
*    Input:  TEXT_LENGTH    Columns already used. ( 9 or 16 )
*
*    Global: AN_ENTRY  (read_only)
*    Global: ENTRIESTAB-AREA&SUBID   (read_only)
*    Global: ?
*    Global: ENTRIESTAB-slgttyp   (output) ???
*
*    Effect: ??
*

  GEN_OUTLINE-FILE_NO = ENTRIESTAB-FILE_NO.
  GEN_OUTLINE-POS     = ENTRIESTAB-POS.

* Write Task type , client , user , transaction code , terminal

  GEN_OUTLINE-TASK  = ENTRIESTAB-SLGTTYP.
  GEN_OUTLINE-TSKNA = '   '.
  GEN_OUTLINE-TSKNU = '  '.
  AUX_SLGPROC = AN_ENTRY-SLGPROC.
  GEN_OUTLINE-TSKNU = AUX_SLGPROC-TASKTNO+2(3).
  CASE ENTRIESTAB-SLGTTYP(1).
    WHEN 'B'.
      GEN_OUTLINE-TSKNA = 'BTC'.
    WHEN 'D'.
      IF ENTRIESTAB-SLGTTYP = 'DP'.
        GEN_OUTLINE-TSKNA = 'DP '.
        GEN_OUTLINE-TSKNU = '  '.
      ELSE.
        GEN_OUTLINE-TSKNA = 'DIA'.
      ENDIF.
    WHEN 'E'.
      GEN_OUTLINE-TSKNA = 'ENQ'.
    WHEN 'M'.
      GEN_OUTLINE-TSKNA = 'MS '.
      GEN_OUTLINE-TSKNU = '  '.
    WHEN 'R'.
      GEN_OUTLINE-TSKNA = 'RD '.
      GEN_OUTLINE-TSKNU = '  '.
    WHEN 'S'.
      GEN_OUTLINE-TSKNA = 'SPO'.
    WHEN 'U'.
      GEN_OUTLINE-TSKNA = 'UP1'.
    WHEN 'V'.
      GEN_OUTLINE-TSKNA = 'UP2'.
    WHEN 'W'.
      GEN_OUTLINE-TSKNA = 'WRK'.
    WHEN OTHERS.
      IF ENTRIESTAB-SLGTTYP = 'sa'.
        GEN_OUTLINE-TSKNA = 'S-A'.
      ENDIF.
      GEN_OUTLINE-TSKNU = '  '.
  ENDCASE.
  GEN_OUTLINE-MAND      = AN_ENTRY-SLGMAND.
  GEN_OUTLINE-USER      = AN_ENTRY-slguser.
  GEN_OUTLINE-TRANSCODE = AN_ENTRY-slgtc.
  GEN_OUTLINE-REPNA     = AN_ENTRY-slgrepna.
  CLEAR GEN_OUTLINE-TERMINAL.
  GEN_OUTLINE-TERMINAL  = AN_ENTRY-slgltrm.


* Hide all remaining fields

  MOVE-CORRESPONDING AN_ENTRY TO HIDE_BUFFER.
  MOVE-CORRESPONDING HIDE_BUFFER TO GS_HIDE_BUFFER.
  MOVE HIDE_LINE_TYPE TO GS_HIDE_BUFFER-HIDE_LINE_TYPE.

* Do the statistics.

  IF LAYOUT-W_STATS = SAP_YES.

    MOVE: AN_ENTRY-SLGMAND  TO MAND_STAT-MAND,
          1                 TO MAND_STAT-CNT.
    COLLECT MAND_STAT.

    MOVE: AN_ENTRY-slgrepna TO REPO_STAT-REPO,
          1                 TO REPO_STAT-CNT.
    COLLECT REPO_STAT.

    MOVE: AN_ENTRY-slgtc    TO TCOD_STAT-TCOD,
          1                 TO TCOD_STAT-CNT.
    COLLECT TCOD_STAT.

    MOVE: AN_ENTRY-slguser  TO BENU_STAT-BENU,
          1                 TO BENU_STAT-CNT.
    COLLECT BENU_STAT.

  ENDIF.

*EJECT

  CASE ENTRIESTAB-slgftyp.

    WHEN RSLGTYcf.
      PERFORM WRITE_TEXT_ALV USING TEXT_LENGTH.

    WHEN RSLGTYup.
      PERFORM WRITE_TEXT_ALV USING TEXT_LENGTH.

    WHEN RSLGTYdo.
      PERFORM WRITE_TEXT_ALV USING TEXT_LENGTH.

    WHEN RSLGTYpr.
      PERFORM WRITE_TEXT_ALV USING TEXT_LENGTH.

    WHEN RSLGTY_D.
      PERFORM WRITE_TEXT_ALV USING TEXT_LENGTH.

    WHEN RSLGTY_P.
      PERFORM WRITE_TEXT_ALV USING TEXT_LENGTH.

    WHEN RSLGTY_T.
      PERFORM WRITE_TEXT_ALV USING TEXT_LENGTH.

    WHEN RSLGTYas.
      PERFORM WRITE_TEXT_ALV USING TEXT_LENGTH.

    WHEN RSLGTYen.
      PERFORM WRITE_TEXT_ALV USING TEXT_LENGTH.

    WHEN RSLGTYde.
      PERFORM WRITE_TEXT_ALV USING TEXT_LENGTH.

    WHEN RSLGTYex.
      " Enforce loading back of parameters, even if they are not
      " used in message text.
      PERFORM FIND_AND_HIDE_PARAMS
        USING AN_ENTRY-slgltrm AN_ENTRY-slgmode
              AN_ENTRY-slgdattim.
      PERFORM WRITE_TEXT_ALV USING TEXT_LENGTH.

    WHEN RSLGTYad.
      PERFORM WRITE_TEXT_ALV USING TEXT_LENGTH.

      IF LAYOUT-W_STATS = SAP_YES.
        CALL FUNCTION 'RSLG_SEL_GET_WHICHLOG_ALV'
          IMPORTING
            FILE = TA___WHICHLOG.
        IF TA___WHICHLOG = REP_ON_LOCAL.
          PERFORM DO_SNAP_STAT USING AN_ENTRY-SLGMAND
                                     AN_ENTRY-slgdattim(8)
                                     AN_ENTRY-slgdattim+8(6)
                                     CPU_ID
                                     AN_ENTRY-slguser
                                     AN_ENTRY-slgmode.
        ELSE. "RFC???
          PERFORM DO_SNAP_STAT USING AN_ENTRY-SLGMAND
                                     AN_ENTRY-slgdattim(8)
                                     AN_ENTRY-slgdattim+8(6)
                                     ENTRIESTAB-sender_id
                                     AN_ENTRY-slguser
                                     AN_ENTRY-slgmode.
        ENDIF.
      ENDIF.

    WHEN RSLGTYab.
      PERFORM WRITE_TEXT_ALV USING TEXT_LENGTH.

      MOVE AN_ENTRY-slgdata TO RSLGABDATA.
      CLEAR ABAP_INFO.
      MOVE AN_ENTRY-slgltrm TO ABAP_INFO-slgltrm.
      MOVE AN_ENTRY-slgmode TO ABAP_INFO-slgmode.
      READ TABLE ABAP_INFO.
      IF SY-SUBRC = 0. " found
        MOVE-CORRESPONDING RSLGABDATA TO ABAP_INFO.
        MOVE ENTRIESTAB-AREA        TO ABAP_INFO-first_AREA.
        MOVE ENTRIESTAB-SUBID       TO ABAP_INFO-first_SUBID.
        MODIFY ABAP_INFO INDEX SY-TABIX.
      ELSE.
        MOVE-CORRESPONDING RSLGABDATA TO ABAP_INFO.
        MOVE ENTRIESTAB-AREA        TO ABAP_INFO-first_AREA.
        MOVE ENTRIESTAB-SUBID       TO ABAP_INFO-first_SUBID.
        APPEND ABAP_INFO.
      ENDIF.

    WHEN RSLGTYax.
      PERFORM WRITE_TEXT_ALV USING TEXT_LENGTH.

      CLEAR ABAP_INFO.
      MOVE AN_ENTRY-slgltrm TO ABAP_INFO-slgltrm.
      MOVE AN_ENTRY-slgmode TO ABAP_INFO-slgmode.
      READ TABLE ABAP_INFO.
      IF SY-SUBRC = 0. " found
        MOVE-CORRESPONDING ABAP_INFO TO HIDE_ABAP_INFO.
        MOVE-CORRESPONDING HIDE_ABAP_INFO TO GS_HIDE_BUFFER.
        CLEAR HIDE_ABAP_INFO.
      ENDIF.

    WHEN RSLGTYpa.
      PERFORM WRITE_TEXT_ALV USING TEXT_LENGTH.
      " Already in SEL_CHECK :
      "                 CALL FUNCTION 'RSLG_STORE_PARAM'
      "                      EXPORTING SLGDATA     = AN_ENTRY-slgdata
      "                      DATE_TIME   = AN_ENTRY-slgdattim
      "                      EXTERN_MODE = AN_ENTRY-slgmode
      "                      TERMINAL    = AN_ENTRY-slgltrm .

    WHEN OTHERS.
      PERFORM WRITE_TEXT_ALV USING TEXT_LENGTH.

  ENDCASE.

ENDFORM. " WRITE_REST_OF_ENTRY_ALV
*EJECT

FORM WRITE_TEXT_ALV USING A11_TEXT_LENGTH.
************************************************************************
*
*    WRITE_TEXT - Write the text part of an SysLog Entry
*
*    Input:  A11_TEXT_LENGTH    Columns already used. ( 9 or 16 )
*
*    Global: AN_ENTRY  (read_only)
*    Global: ENTRIESTAB-AREA&SUBID   (read_only)
*    Global: ?
*    Global: ENTRIESTAB-slgttyp   (output) ???
*
*    Effect: Take the SysLog entry key number, look it up in table
*            "TSL01" and substitute all '$' by characters from the
*            variable part of the entry.
*
  DATA: L11_REST_LENGTH TYPE I
      , L11_CATCHED_ERRNO(6)
      , L11_CATCHED_T100_OLD(5)
      , L11_CATCHED_T100_NEW(23)
      .

  MOVE SY-LINSZ            TO   L11_REST_LENGTH.
  SUBTRACT A11_TEXT_LENGTH FROM L11_REST_LENGTH.
  SUBTRACT 25 FROM L11_REST_LENGTH. " for TASK,MAND,USER,TRANSCODE

  PERFORM USE_TABE_AND_DATA USING ENTRIESTAB-AREA
                                  ENTRIESTAB-SUBID
                                  AN_ENTRY-slgdata
                                  HIDE_TEXT HIDE_TEXT_LG
                                  AN_ENTRY-slgltrm AN_ENTRY-slgmode
                                  AN_ENTRY-slgdattim
                                  L11_CATCHED_ERRNO
                                  L11_CATCHED_T100_OLD.
  MOVE L11_CATCHED_T100_OLD(2)    TO L11_CATCHED_T100_NEW.
  MOVE L11_CATCHED_T100_OLD+2(3)  TO L11_CATCHED_T100_NEW+20.
  PERFORM PUT_ERRNO_INTO_ENTRIESTAB USING L11_CATCHED_ERRNO.
  PERFORM PUT_T100_INTO_ENTRIESTAB  USING L11_CATCHED_T100_NEW.

* * Write the first part.
  GEN_OUTLINE-TEXT    = HIDE_TEXT.
  GEN_OUTLINE-TEXT_LG = HIDE_TEXT_LG.

* * Handle truncation.
  IF HIDE_TEXT_LG > L11_REST_LENGTH.
    MOVE HIDE_TEXT TO GS_HIDE_BUFFER-HIDE_TEXT.
    MOVE HIDE_TEXT_LG TO GS_HIDE_BUFFER-HIDE_TEXT_LG.
  ELSE.
    CLEAR: HIDE_TEXT, HIDE_TEXT_LG.
    CLEAR: GS_HIDE_BUFFER-HIDE_TEXT, GS_HIDE_BUFFER-HIDE_TEXT_LG.
  ENDIF.

ENDFORM. " WRITE_TEXT_ALV

*EJECT
FORM USE_TABE_AND_DATA USING A36_AREA A36_SUBID
                             A36_DATA A36_TEXT A36_T_LG
                             A36_slgltrm A36_slgmode A36_CURTIME
                             A36_CATCHED_ERRNO A36_CATCHED_T100
                             .
************************************************************************
*
*    USE_TABE_AND_DATA - Write the text part of an SysLog Entry
*
*    Input : A36_AREA  C(2)  TSL1D key.
*    Input : A36_SUBID C(1)  additional TSL1D key.
*    Input : A36_DATA C(64)  Varaible data to replace the '$'s.
*    Output: A36_TEXT C(316) The text, made from TSL01 entry and the
*                            variable data.
*    Output: A36_T_LG P(2)   How much of 'A36_TEXT' is filled with
*                            non-blank.
*    Input : A36_slgltrm C(12) Terminal name to associate parameters.
*    Input : A36_slgmode C(1) external mode to associate parameters.
*    Input : A36_CURTIME C(16) date/time of entry.
*
*    Effect: Take the SysLog entry key number, look it up in table
*            "TSL01" and substitute all substitution symbols in the
*            message by characters from the variable part of the entry.
*            There are two substitution methods wich cannot be used
*            intermixed:
*            "old": Any '$' in the message text is replaced by one
*                   character from the variable part of the entry.
*                   The '$'s and the characters from the variable part
*                   of the entry are both used one by one from the left
*                   to the right.
*            "new": The variable part of the entry is seperated by
*                   single '&' into words. The message may contain
*                   substitution symbols like '&A', '&B', etc. to pick
*                   up those words in any order.
*                   Also the message may contain substitution symbols
*                   like '&a', '&b', etc. to pick up paramters from
*                   previous SysLog entries.
*                   As a third method '&1', '&2', etc. may pick up
*                   1, 2,... characters from the variable part as
*                   '$', '$$', would have done.
*
************************************************************************
  DATA MSG_LEN       TYPE I.
  DATA DEST_LEN      TYPE I.        " filled length of A36_TEXT
  DATA VALUE_LEN     TYPE I.        " length of VALUE
  DATA TMP_LEN       TYPE I.        " length of VALUE
  DATA WORD_OFFSET   TYPE I.
  DATA WORD_LEN      TYPE I.
  DATA PART_LEN      TYPE I.
  DATA LONG_VALUE    TYPE MSGTEXT_T.       " as long as A36_TEXT ?!
  DATA L36_TEXT      TYPE MSGTEXT_T.       " buffer for standard text
  DATA L_POS         LIKE SY-FDPOS.
  DATA L_DECODED     LIKE SY-FDPOS.
  DATA L_SKIP_PARAM  TYPE I.
  DATA WORDS(1024).                                         " 16 * 64
  DATA A_SPACE VALUE ' '.
  DATA CATCH_ERRNO           VALUE ' '.
  DATA CATCH_T100            VALUE ' '.

  FIELD-SYMBOLS: <DEST_PTR>.
  FIELD-SYMBOLS: <VALUE_PTR>.
  FIELD-SYMBOLS: <TMP_PTR>.
  FIELD-SYMBOLS: <WORDS_PTR>.
  FIELD-SYMBOLS: <MSG_PTR>.

  CALL FUNCTION 'RSLG_TAB_CACHE_ACCESS_ALV'
    EXPORTING
      AREA        = A36_AREA
      SUBID       = A36_SUBID
    IMPORTING
      CACHE_ENTRY = CUR_SYSLOGTAB.
  GEN_OUTLINE-CLASID   = CUR_SYSLOGTAB-CLASID.
  GEN_OUTLINE-DEVCLASS = CUR_SYSLOGTAB-DEVCLASS.
  GEN_OUTLINE-MONBEW   = CUR_SYSLOGTAB-MONBEW.
  GEN_OUTLINE-MONKAT   = CUR_SYSLOGTAB-MONKAT.

*   Entry found: substitute with variable data.

  MSG_LEN = STRLEN( CUR_SYSLOGTAB-TXT ).

  IF MSG_LEN > 0.

    IF CUR_SYSLOGTAB-USES_32_DO = SPACE.
*       " New method: value data may be seperated into words by '&'.
*       "             Message text contains '&<cap_letter>' to collect
*       "             the words in any order.
*       " (1) Cut value into words and store them in WORDS.
*       "
      VALUE_LEN =  VAR_PART_LG.
      DEST_LEN  = 640.
      ASSIGN A36_DATA(VALUE_LEN)    TO <VALUE_PTR>.
      ASSIGN A36_TEXT(DEST_LEN)     TO <DEST_PTR>.
      ASSIGN WORDS(VAR_PART_LG)     TO <WORDS_PTR>.
      ASSIGN CUR_SYSLOGTAB-TXT(MSG_LEN) TO <MSG_PTR>.
      WHILE <VALUE_PTR> CA '&'.
*         " contains any &. 1st at FDPOS. FDPOS counts 0,1,2,...  !
        L_POS = SY-FDPOS.
*         " Store left hand word.
        TMP_LEN = L_POS.
        IF TMP_LEN > 0.
          ASSIGN <VALUE_PTR>(TMP_LEN) TO <TMP_PTR>.
        ELSE.
          ASSIGN A_SPACE TO <TMP_PTR>.
        ENDIF.
        MOVE <TMP_PTR> TO <WORDS_PTR>.
*         " Move to next storage location.
        ASSIGN <WORDS_PTR>+VAR_PART_LG(VAR_PART_LG) TO <WORDS_PTR>.
*         " Pick up rest of value without the boundary '&'.
        VALUE_LEN  = VALUE_LEN - L_POS - 1.
        IF VALUE_LEN > 0.
          TMP_LEN = L_POS + 1.
          ASSIGN <VALUE_PTR>+TMP_LEN(VALUE_LEN) TO <VALUE_PTR>.
        ELSE.
          ASSIGN A_SPACE TO <VALUE_PTR>.
        ENDIF.
      ENDWHILE.
*       " Store last word.
      MOVE <VALUE_PTR> TO <WORDS_PTR>.
*       "

*       "--------------
*       " (2) Copy message text to output area, and during that
*       "     replace each &A,&B,..  by word 1, word 2,...
*       "     replace each &a,&b,..  by parameter a, parameter b,...
*       "     replace each &1,&2,..  by 1,2,... characters from value
*
*       " Restore access to whole value (64 characters)
      LONG_VALUE    = A36_DATA.
      ASSIGN LONG_VALUE(MSG_LEN) TO <VALUE_PTR>.
      VALUE_LEN = VAR_PART_LG.
*       " Loop throug message...
      WHILE <MSG_PTR> CA '&'.
*         " contains any '&'. 1st '&' is at FDPOS.
        L_POS = SY-FDPOS.
        L_SKIP_PARAM = 2.
*         " Copy left hand fixed part.
        TMP_LEN = L_POS.
        IF TMP_LEN > 0.
          ASSIGN <MSG_PTR>(TMP_LEN) TO <TMP_PTR>.
          MOVE <TMP_PTR> TO <DEST_PTR>.
          DEST_LEN = DEST_LEN - TMP_LEN.
          ASSIGN <DEST_PTR>+TMP_LEN(DEST_LEN) TO <DEST_PTR>.
        ENDIF.
*         " Pick up the &i.
        TMP_LEN = L_POS + 1.
        ASSIGN <MSG_PTR>+TMP_LEN(1) TO <TMP_PTR>.

        IF <TMP_PTR> = '>'.
          ASSIGN <TMP_PTR>+1(1) TO <TMP_PTR>.
          CASE <TMP_PTR>.
            WHEN 'E'.
              CATCH_ERRNO = 'X'.
              ASSIGN <TMP_PTR>+1(1) TO <TMP_PTR>.
              ADD 2 TO L_SKIP_PARAM.
            WHEN 'M'.
              CATCH_T100 = 'X'.
              ASSIGN <TMP_PTR>+1(1) TO <TMP_PTR>.
              ADD 2 TO L_SKIP_PARAM.
            WHEN OTHERS.
*               " A '&>' followed by something strange tries to ignore
*               " the '>'.
              MOVE '&' TO <DEST_PTR>.
              DEST_LEN = DEST_LEN - 1.
              ASSIGN <DEST_PTR>+1(DEST_LEN) TO <DEST_PTR>.
              MOVE '>' TO <DEST_PTR>.
              DEST_LEN = DEST_LEN - 1.
              ASSIGN <DEST_PTR>+1(DEST_LEN) TO <DEST_PTR>.
              DEST_LEN = DEST_LEN - 1.
              ADD 1 TO L_SKIP_PARAM.
          ENDCASE.
        ENDIF. " &>...

        IF 'ABCDEFGHIJKLMNOP' CA <TMP_PTR>.
*           " &A, &B,.. identify the 1st, 2nd,.. '&'-seperated word from
*           "         the 64 char value field.
          WORD_OFFSET = SY-FDPOS * VAR_PART_LG.
          ASSIGN WORDS+WORD_OFFSET(VAR_PART_LG) TO <WORDS_PTR>.
          WORD_LEN = STRLEN( <WORDS_PTR> ).
          IF WORD_LEN > 0.
            ASSIGN WORDS+WORD_OFFSET(WORD_LEN) TO <WORDS_PTR>.
            MOVE <WORDS_PTR> TO <DEST_PTR>.
            DEST_LEN = DEST_LEN - WORD_LEN.
            IF DEST_LEN < 0.
               EXIT.
            ENDIF.
            ASSIGN <DEST_PTR>+WORD_LEN(DEST_LEN) TO <DEST_PTR>.
            IF CATCH_ERRNO = 'X'.
              MOVE <WORDS_PTR> TO A36_CATCHED_ERRNO.
            ENDIF.
            IF CATCH_T100 = 'X'.
              MOVE <WORDS_PTR> TO A36_CATCHED_T100.
            ENDIF.
          ENDIF.

        ELSE. " ident not in range 'A',..,'P'
          IF 'abcdefghij' CA <TMP_PTR>.
*             " &a, &b,.. identify one of the parameters of any
*             "         preceeding parameter SysLog entries.
            L_DECODED = SY-FDPOS.
            PERFORM FIND_AND_HIDE_PARAMS
              USING A36_slgltrm A36_slgmode A36_CURTIME.
            WORD_OFFSET = L_DECODED * ( VAR_PART_LG - 2 ).
            PART_LEN = VAR_PART_LG - 2 . " 2 for overhead.
            ASSIGN HIDE_PARAMS+WORD_OFFSET(PART_LEN) TO <WORDS_PTR>.
            WORD_LEN = STRLEN( <WORDS_PTR> ).
            IF WORD_LEN > 0.
              ASSIGN HIDE_PARAMS+WORD_OFFSET(WORD_LEN) TO <WORDS_PTR>.
              MOVE <WORDS_PTR> TO <DEST_PTR>.
              DEST_LEN = DEST_LEN - WORD_LEN.
              IF DEST_LEN < 0.
                 EXIT.
              ENDIF.
              ASSIGN <DEST_PTR>+WORD_LEN(DEST_LEN) TO <DEST_PTR>.
              IF CATCH_ERRNO = 'X'.
                MOVE <WORDS_PTR> TO A36_CATCHED_ERRNO.
              ENDIF.
              IF CATCH_T100 = 'X'.
                MOVE <WORDS_PTR> TO A36_CATCHED_T100.
              ENDIF.
            ENDIF.

          ELSE. " ident not in range 'A',..,'P' nor in 'a',..,'j'
            IF '123456789' CA <TMP_PTR>.
*               " &1, &2,.. identify one to nine characters from the
*               "           64 char value field, taken left to right.
              WORD_LEN = SY-FDPOS + 1 .
*               " Copy part of value field.
              MOVE <VALUE_PTR> TO <DEST_PTR>(WORD_LEN).
              IF CATCH_ERRNO = 'X'.
                ASSIGN <VALUE_PTR>(WORD_LEN) TO <VALUE_PTR>.
                MOVE <VALUE_PTR> TO A36_CATCHED_ERRNO.
              ENDIF.
              IF CATCH_T100 = 'X'.
                ASSIGN <VALUE_PTR>(WORD_LEN) TO <VALUE_PTR>.
                MOVE <VALUE_PTR> TO A36_CATCHED_T100.
              ENDIF.
*               " Pick up the rest of value behind that word.
              VALUE_LEN = VALUE_LEN - WORD_LEN.
              IF VALUE_LEN > 0.
                ASSIGN <VALUE_PTR>+WORD_LEN(VALUE_LEN) TO <VALUE_PTR>.
              ELSE.
                ASSIGN '???????????????' TO <VALUE_PTR>.
              ENDIF.
*               " Pick up the rest of destination field.
              DEST_LEN = DEST_LEN - WORD_LEN.
              ASSIGN <DEST_PTR>+WORD_LEN(DEST_LEN) TO <DEST_PTR>.

            ELSE. " ident not in ranges 'A'..'P' , 'a'..'j' , '1'..'9'
*               " A '&' followed by something strange is not substituted
              MOVE '&' TO <DEST_PTR>.
              DEST_LEN = DEST_LEN - 1.
              ASSIGN <DEST_PTR>+1(DEST_LEN) TO <DEST_PTR>.
              MOVE <TMP_PTR> TO <DEST_PTR>.
              DEST_LEN = DEST_LEN - 1.
              ASSIGN <DEST_PTR>+1(DEST_LEN) TO <DEST_PTR>.
            ENDIF.
          ENDIF.
        ENDIF.
        CLEAR: CATCH_ERRNO, CATCH_T100.
*         " Pick up rest of message without the &i.
        MSG_LEN = MSG_LEN - L_POS - L_SKIP_PARAM.
        IF MSG_LEN > 0.
          TMP_LEN = L_POS + L_SKIP_PARAM.
          ASSIGN <MSG_PTR>+TMP_LEN(MSG_LEN) TO <MSG_PTR>.
        ELSE.
          ASSIGN A_SPACE TO <MSG_PTR>.
        ENDIF.
      ENDWHILE.
*       " Copy last fixed part.
      MOVE <MSG_PTR> TO <DEST_PTR>.

    ELSE.
*       " Old method: replace each '$' by one value character from left
*       "             to right
*       " (1) Copy whole message
      LONG_VALUE    = A36_DATA.
      ASSIGN LONG_VALUE(MSG_LEN) TO <VALUE_PTR>.
      A36_TEXT = CUR_SYSLOGTAB-TXT.
      ASSIGN A36_TEXT(MSG_LEN) TO <DEST_PTR>.
*       " (2) Look for any $ and replace them.
      WHILE <DEST_PTR> CA '$'.
*         " contains any $. 1st at FDPOS.
        L_POS = SY-FDPOS.
*         " Now look at rest of msg, starting with 1st $
        MSG_LEN = MSG_LEN - L_POS.
        ASSIGN <DEST_PTR>+SY-FDPOS(MSG_LEN) TO <DEST_PTR>.
        IF <DEST_PTR> CO '$'.
*           " contains only dollars.
*           " Replace them all.
          MOVE <VALUE_PTR> TO <DEST_PTR>.
          EXIT.
        ELSE.
*           " contains not only dollars. 1st other char at FDPOS.
          L_POS = SY-FDPOS.
          MSG_LEN = MSG_LEN - L_POS.
*           " Replace next group of dollars.
          MOVE  <VALUE_PTR> TO <DEST_PTR>(L_POS).
*           " Pick up the rest of msg behind that group.
          ASSIGN <DEST_PTR>+L_POS(MSG_LEN) TO <DEST_PTR>.
*           " Pick up the rest of value behind that group.
          ASSIGN <VALUE_PTR>+L_POS(MSG_LEN) TO <VALUE_PTR>.
        ENDIF.
      ENDWHILE.
    ENDIF.
    CONDENSE A36_TEXT.

  ELSE.
*     Entry has empty text: set standard text.
    MOVE 'empty:TSL1T('(241)          TO L36_TEXT.
    MOVE              SY-LANGU        TO L36_TEXT+12.
    MOVE              ','             TO L36_TEXT+13.
    MOVE                A36_AREA      TO L36_TEXT+14.
    MOVE                  A36_SUBID   TO L36_TEXT+16.
    MOVE                  '):'        TO L36_TEXT+17.
    MOVE                     A36_DATA TO L36_TEXT+19.
    MOVE                     L36_TEXT TO A36_TEXT.
  ENDIF.

* Get the actual length of the string.
  A36_T_LG = STRLEN( A36_TEXT ).

ENDFORM.                    "USE_TABE_AND_DATA


*EJECT
FORM FIND_AND_HIDE_PARAMS USING A_slgltrm A_slgmode A_CURTIME.
************************************************************************
*
*    FIND_AND_HIDE_PARAMS - ??
*
*    Input:  A_slgltrm
*    Input:  A_slgmode
*    Input:  A_CURTIME  TYPE C(16)
*
* Sorry, I cannot hide an internal table.

  CALL FUNCTION 'RSLG_FIND_PARAMS'
    EXPORTING
      DATE_TIME   = A_CURTIME
      EXTERN_MODE = A_slgmode
      TERMINAL    = A_slgltrm
    IMPORTING
      PARAM_ARRAY = HIDE_PARAMS
    EXCEPTIONS
      NOT_FOUND   = 1.
  IF SY-SUBRC = 0.
*    HIDE HIDE_PARAMS.
    MOVE HIDE_PARAMS TO GS_HIDE_BUFFER-HIDE_PARAMS.
  ELSEIF SY-SUBRC = 1.
    CLEAR HIDE_PARAMS.
    CLEAR GS_HIDE_BUFFER-HIDE_PARAMS.
  ENDIF.

ENDFORM. " FIND_AND_HIDE_PARAMS

*EJECT
FORM PUT_ERRNO_INTO_ENTRIESTAB USING A47_NEW_ERRNO.
  DATA L47_NEW_ERRNO(6).
  IF ENTRIESTAB-ERRNO IS INITIAL AND NOT A47_NEW_ERRNO IS INITIAL.
    L47_NEW_ERRNO = A47_NEW_ERRNO.
    CONDENSE L47_NEW_ERRNO NO-GAPS.
    IF L47_NEW_ERRNO CN '0'.
      SHIFT L47_NEW_ERRNO LEFT BY SY-FDPOS PLACES.
    ENDIF.
    IF L47_NEW_ERRNO CO '0123456789-+ '.
      ENTRIESTAB-ERRNO = L47_NEW_ERRNO.
      MODIFY ENTRIESTAB INDEX ENTRIESTAB_IX.
    ELSE.
      "sorry.
      "DEB: break-point.
    ENDIF.
  ENDIF.
ENDFORM.                    "PUT_ERRNO_INTO_ENTRIESTAB



*&--------------------------------------------------------------------*
*&      Form  PUT_T100_INTO_ENTRIESTAB
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*      -->A48_NEW_T10text
*---------------------------------------------------------------------*
FORM PUT_T100_INTO_ENTRIESTAB USING A48_NEW_T100.
  DATA L48_NEW_T100(23).
  IF ENTRIESTAB-T100ARBGB IS INITIAL AND NOT A48_NEW_T100 IS INITIAL.
    L48_NEW_T100 = A48_NEW_T100.
    ENTRIESTAB-T100ARBGB = L48_NEW_T100+0(20).
    ENTRIESTAB-T100MSGNR = L48_NEW_T100+20(3).
    MODIFY ENTRIESTAB INDEX ENTRIESTAB_IX.
  ENDIF.
ENDFORM.                    "PUT_T100_INTO_ENTRIESTAB

*EJECT
FORM INIT_INTERN_TAB.
************************************************************************
* Vorbereitung der Caches fuer externe Tabellen.
*----------------------------------------------------------------------
*
*    Output: CLASSTAB
*
*----------------------------------------------------------------------

  ADD 1 TO INIT_TABS_CNT.

  IF INIT_TABS_CNT = 1.

    CLEAR: TSL2T.
    REFRESH CLASSTAB FROM TABLE TSL2T.

    CALL FUNCTION 'RSLG_INIT_TAB_CACHES'
      EXPORTING
        CLEAR_ALL      = 'X'
        NEEDS_COUNTING = 'X'. " ??

  ELSE.

    CALL FUNCTION 'RSLG_INIT_TAB_CACHES'
      EXPORTING
        ZERO_COUNTERS  = 'X'
        NEEDS_COUNTING = 'X'.

  ENDIF.

  CALL FUNCTION 'RSLG_INIT_PARAM_STORE'
    .

  REFRESH CONTENTS.
  REFRESH INST_STAT.
  REFRESH MAND_STAT.
  REFRESH REPO_STAT.
  REFRESH TCOD_STAT.
  REFRESH BENU_STAT.
  REFRESH ABAP_INFO.
  PERFORM CLEAR_SNAP_STAT.
  REFRESH LINE.

ENDFORM. " INIT_INTERN_TAB.

FORM INIT_INTERN_TAB_ALV.
************************************************************************
* Vorbereitung der Caches fuer externe Tabellen.
*----------------------------------------------------------------------
*    Output: CLASSTAB
*----------------------------------------------------------------------

  ADD 1 TO INIT_TABS_CNT.

  IF INIT_TABS_CNT = 1.

    CLEAR: TSL2T.
    REFRESH CLASSTAB FROM TABLE TSL2T.
    CALL FUNCTION 'RSLG_INIT_TAB_CACHES_ALV'
      EXPORTING
        CLEAR_ALL      = 'X'
        NEEDS_COUNTING = 'X'.

  ELSE.
    CALL FUNCTION 'RSLG_INIT_TAB_CACHES_ALV'
      EXPORTING
        NEEDS_COUNTING = 'X'
        ZERO_COUNTERS  = 'X'.
  ENDIF.

  CALL FUNCTION 'RSLG_INIT_PARAM_STORE' .

  REFRESH CONTENTS.
  REFRESH INST_STAT.
  REFRESH MAND_STAT.
  REFRESH REPO_STAT.
  REFRESH TCOD_STAT.
  REFRESH BENU_STAT.
  REFRESH ABAP_INFO.
  PERFORM CLEAR_SNAP_STAT.
  REFRESH LINE.

ENDFORM. " INIT_INTERN_TAB_ALV.

*EJECT
FORM WRITE_DATE_OF_ENTRY USING A12_A_TIME_STAMP A12_DATE.
************************************************************************
*
*    WRITE_DATE_OF_ENTRY - Write the date of a SysLog entry.
*
*    Input  A12_A_TIME_STAMP      Format: yyyymmddhhmmss00
*    Output A12_DATE              Format: YYYY.MM.DD
*
  DATA L12_STAMP(8).
  DATA L12_D TYPE D.

  L12_STAMP = A12_A_TIME_STAMP.
  L12_D     = L12_STAMP.
  WRITE L12_D to A12_DATE.

ENDFORM.                    "WRITE_DATE_OF_ENTRY

*EJECT
FORM WRITE_TIME_OF_ENTRY USING A12_A_TIME_STAMP A12_TIME.
************************************************************************
*
*    WRITE_TIME_OF_ENTRY - Write the time of a SysLog entry.
*
*    Input  A12_A_TIME_STAMP      Format: yyyymmddhhmmss00
*    Output A12_TIME              Format: hh:mm:ss
*
  DATA L12_STAMP(14).
  DATA L12_TIME(8).


  L12_STAMP  = A12_A_TIME_STAMP.
  L12_TIME+0 = L12_STAMP+8.
  L12_TIME+2 = ':'.
  L12_TIME+3 = L12_STAMP+10.
  L12_TIME+5 = ':'.
  L12_TIME+6 = L12_STAMP+12.
  A12_TIME   = L12_TIME.
ENDFORM.                    "WRITE_TIME_OF_ENTRY

FORM WRITE_INST_STAT_ALV USING A_LINES TYPE I.
************************************************************************
*    WRITE_INST_STAT - Write the statistics about instances
*
*    Global: INSTSTAT      (read_only)
*    Global: PAGE_TYPE
*    Global: CONTENTS       (APPEND)
*    Global: RECORDCNT-GOOD  (read_only)
*    Global: ACCU
*    Global: TAB_LINES
*
*    Effect: NEW-PAGE,
*            WRITE
*
  DATA: L_LINES TYPE I
      , LIMIT   TYPE I VALUE 10 "%
      .

  DESCRIBE TABLE INST_STAT LINES L_LINES.
  IF L_LINES > 0.
    PAGE_TYPE                = 'S'.
    HIDE_LINE_TYPE           = '-'.
    CONTENTS_NEXT_START_PAGE = SY-PAGNO.
    NEW-PAGE NO-HEADING NO-TITLE.
    ADD 1 TO CONTENTS_NEXT_START_PAGE.
    " SY-PAGNO will be incremented not before the first WRITE.

    MOVE: CONTENTS_NEXT_START_PAGE TO CONTENTS-START_PAGE,
          'instance statistics'(076) TO CONTENTS-NAME,
          SPACE                      TO CONTENTS-START_TIME,
          SPACE                      TO CONTENTS-END_TIME.

    SORT INST_STAT DESCENDING BY CNT.
    " Limit? Twice as oft than others
    LIMIT = 200 DIV L_LINES + 1 .
    TAB_LINES = 7.
    LOOP AT INST_STAT.
*   * Table shall show only the most often entries.
      ACCU = INST_STAT-CNT.
      MULTIPLY ACCU BY 100.
      DIVIDE ACCU BY RECORDCNT-GOOD.
      " As high scores are bad, use color 6 (too low)
      MOVE INST_STAT-INST TO GS_INST-INST.
      MOVE INST_STAT-CNT  TO GS_INST-CNT.
      MOVE ACCU           TO GS_INST-ACCU.
      MOVE PAGE_TYPE TO GS_INST-HIDE_LINE_TYPE.
      APPEND GS_INST TO GT_INST.
      CLEAR GS_INST.
      CONTENTS_CHAPTER_EMPTY = SAP_NO.
    ENDLOOP.

    IF CONTENTS_CHAPTER_EMPTY = SAP_NO.
      CONTENTS-END_PAGE = SY-PAGNO.
      APPEND CONTENTS.
    ENDIF.
    CONTENTS_CHAPTER_EMPTY = SAP_YES.
  ENDIF.
ENDFORM. "WRITE_INST_STAT_ALV

*&--------------------------------------------------------------------*
*&      Form  WRITE_MAND_STAT_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*      -->A_LINES    text
*---------------------------------------------------------------------*
FORM WRITE_MAND_STAT_ALV USING A_LINES TYPE I.
************************************************************************
*    WRITE_MAND_STAT - Write the statistics about DBMS accesses
*
*    Global: MAND_STAT      (read_only)
*    Global: PAGE_TYPE
*    Global: CONTENTS       (APPEND)
*    Global: RECORDCNT-GOOD  (read_only)
*    Global: ACCU
*    Global: TAB_LINES
*
*    Effect: NEW-PAGE,
*            WRITE
*
  DATA: L_LINES TYPE I
      , LIMIT   TYPE I VALUE 10 "%
      .

  DESCRIBE TABLE MAND_STAT LINES L_LINES.
  IF L_LINES > 0.
    PAGE_TYPE                = 'M'.
    HIDE_LINE_TYPE           = '-'.
    CONTENTS_NEXT_START_PAGE = SY-PAGNO.
    NEW-PAGE NO-HEADING NO-TITLE.
    ADD 1 TO CONTENTS_NEXT_START_PAGE.
    " SY-PAGNO will be incremented not before the first WRITE.

    MOVE: CONTENTS_NEXT_START_PAGE TO CONTENTS-START_PAGE,
          'client statistics'(065) TO CONTENTS-NAME,
          SPACE                    TO CONTENTS-START_TIME,
          SPACE                    TO CONTENTS-END_TIME.

    SORT MAND_STAT DESCENDING BY CNT.
    " Limit? Twice as oft than others
    LIMIT = 200 DIV L_LINES + 1 .
    TAB_LINES = 6.
    LOOP AT MAND_STAT.
*   * Table shall show only the most often entries.
      ADD 1 TO TAB_LINES.
      ACCU = MAND_STAT-CNT.
      MULTIPLY ACCU BY 100.
      DIVIDE ACCU BY RECORDCNT-GOOD.
      " As high scores are bad, use color 6 (too low)
      MOVE MAND_STAT-MAND TO GS_MAND-MAND.
      MOVE MAND_STAT-CNT  TO GS_MAND-CNT.
      MOVE ACCU           TO GS_MAND-ACCU.
      MOVE PAGE_TYPE TO GS_MAND-HIDE_LINE_TYPE.
      APPEND GS_MAND TO GT_MAND.
      CLEAR GS_MAND.
      CONTENTS_CHAPTER_EMPTY = SAP_NO.
    ENDLOOP.

    IF CONTENTS_CHAPTER_EMPTY = SAP_NO.
      CONTENTS-END_PAGE = SY-PAGNO.
      APPEND CONTENTS.
    ENDIF.
    CONTENTS_CHAPTER_EMPTY = SAP_YES.
  ENDIF.
ENDFORM. "WRITE_MAND_STAT_ALV

*&--------------------------------------------------------------------*
*&      Form  WRITE_TCOD_STAT_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*      -->A_LINES    text
*---------------------------------------------------------------------*
FORM WRITE_TCOD_STAT_ALV USING A_LINES TYPE I.
************************************************************************
*    WRITE_TCOD_STAT - Write the statistics about reports.
*
*    Global: TCOD_STAT      (read_only)
*    Global: PAGE_TYPE
*    Global: CONTENTS       (APPEND)
*    Global: RECORDCNT-GOOD  (read_only)
*    Global: ACCU
*    Global: TAB_LINES
*
*    Effect: NEW-PAGE,
*            WRITE
*
  DATA: L_LINES TYPE I
      , LIMIT   TYPE I
      .

  DESCRIBE TABLE TCOD_STAT LINES L_LINES.
  IF L_LINES > 0.
    PAGE_TYPE                = 'T'.
    HIDE_LINE_TYPE           = '-'.
    CONTENTS_NEXT_START_PAGE = SY-PAGNO.
    NEW-PAGE NO-HEADING NO-TITLE.
    ADD 1 TO CONTENTS_NEXT_START_PAGE.
    " SY-PAGNO will be incremented not before the first WRITE.

    MOVE: CONTENTS_NEXT_START_PAGE TO CONTENTS-START_PAGE,
          'transaction stat.'(063) TO CONTENTS-NAME,
          SPACE                    TO CONTENTS-START_TIME,
          SPACE                    TO CONTENTS-END_TIME.

    SORT TCOD_STAT DESCENDING BY CNT.
    " Limit? Twice as oft than others
    LIMIT = 200 DIV L_LINES + 1 .
    TAB_LINES = 6.
    LOOP AT TCOD_STAT.
*   * Table shall show only the most often entries.

      ACCU = TCOD_STAT-CNT.
      MULTIPLY ACCU BY 100.
      DIVIDE ACCU BY RECORDCNT-GOOD.
      " As high scores are bad, use color 6 (too low)
      MOVE TCOD_STAT-TCOD TO GS_TCOD-TCOD.
      MOVE TCOD_STAT-CNT  TO GS_TCOD-CNT.
      MOVE ACCU           TO GS_TCOD-ACCU.
      MOVE PAGE_TYPE TO GS_TCOD-HIDE_LINE_TYPE.
      APPEND GS_TCOD TO GT_TCOD.
      CLEAR GS_TCOD.
      CONTENTS_CHAPTER_EMPTY = SAP_NO.
    ENDLOOP.

    IF CONTENTS_CHAPTER_EMPTY = SAP_NO.
      CONTENTS-END_PAGE = SY-PAGNO.
      APPEND CONTENTS.
    ENDIF.
    CONTENTS_CHAPTER_EMPTY = SAP_YES.
  ENDIF.
ENDFORM.                    "WRITE_TCOD_STAT_ALV

*&--------------------------------------------------------------------*
*&      Form  WRITE_REPO_STAT_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*      -->A_LINES    text
*---------------------------------------------------------------------*
FORM WRITE_REPO_STAT_ALV USING A_LINES TYPE I.
************************************************************************
*
*    WRITE_REPO_STAT - Write the statistics about reports.
*
*    Global: REPO_STAT      (read_only)
*    Global: PAGE_TYPE
*    Global: CONTENTS       (APPEND)
*    Global: RECORDCNT-GOOD  (read_only)
*    Global: ACCU
*    Global: TAB_LINES
*
*    Effect: NEW-PAGE,
*            WRITE
*
  DATA: L_LINES TYPE I
      , LIMIT   TYPE I
      .

  DESCRIBE TABLE REPO_STAT LINES L_LINES.
  IF L_LINES > 0.
    PAGE_TYPE                = 'R'.
    HIDE_LINE_TYPE           = '-'.
    CONTENTS_NEXT_START_PAGE = SY-PAGNO.
    NEW-PAGE NO-HEADING NO-TITLE.
    ADD 1 TO CONTENTS_NEXT_START_PAGE.
    " SY-PAGNO will be incremented not before the first WRITE.

    MOVE: CONTENTS_NEXT_START_PAGE TO CONTENTS-START_PAGE,
          'report statistics'(093) TO CONTENTS-NAME,
          SPACE                    TO CONTENTS-START_TIME,
          SPACE                    TO CONTENTS-END_TIME.

    SORT REPO_STAT DESCENDING BY CNT.
    " Limit? Twice as oft than others
    LIMIT = 200 DIV L_LINES + 1 .
    TAB_LINES = 6.
    LOOP AT REPO_STAT.
*   * Table shall show only the most often entries.
      ACCU = REPO_STAT-CNT.
      MULTIPLY ACCU BY 100.
      DIVIDE ACCU BY RECORDCNT-GOOD.
      " As high scores are bad, use color 6 (too low)
      MOVE REPO_STAT-REPO TO GS_REPO-REPO.
      MOVE REPO_STAT-CNT  TO GS_REPO-CNT.
      MOVE ACCU           TO GS_REPO-ACCU.
      MOVE PAGE_TYPE TO GS_REPO-HIDE_LINE_TYPE.
      APPEND GS_REPO TO GT_REPO.
      CLEAR GS_REPO.

      CONTENTS_CHAPTER_EMPTY = SAP_NO.
    ENDLOOP.

    IF CONTENTS_CHAPTER_EMPTY = SAP_NO.
      CONTENTS-END_PAGE = SY-PAGNO.
      APPEND CONTENTS.
    ENDIF.
    CONTENTS_CHAPTER_EMPTY = SAP_YES.
  ENDIF.
ENDFORM.                    "WRITE_REPO_STAT_ALV

*&--------------------------------------------------------------------*
*&      Form  WRITE_BENU_STAT_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*      -->A_LINES    text
*---------------------------------------------------------------------*
FORM WRITE_BENU_STAT_ALV USING A_LINES TYPE I.
************************************************************************
*    WRITE_BENU_STAT - Write the statistics about DBMS accesses
*
*    Global: BENU_STAT      (read_only)
*    Global: PAGE_TYPE
*    Global: CONTENTS       (APPEND)
*    Global: RECORDCNT-GOOD  (read_only)
*    Global: ACCU
*    Global: TAB_LINES
*
*    Effect: NEW-PAGE,
*            WRITE
*
  DATA: L_LINES TYPE I
      , LIMIT   TYPE I
      .

  DESCRIBE TABLE BENU_STAT LINES L_LINES.
  IF L_LINES > 0.
    PAGE_TYPE                = 'B'.
    HIDE_LINE_TYPE           = '-'.
    CONTENTS_NEXT_START_PAGE = SY-PAGNO.
    NEW-PAGE NO-HEADING NO-TITLE.
    ADD 1 TO CONTENTS_NEXT_START_PAGE.
    " SY-PAGNO will be incremented not before the first WRITE.

    MOVE: CONTENTS_NEXT_START_PAGE TO CONTENTS-START_PAGE,
          'user statistics'(060)   TO CONTENTS-NAME,
          SPACE                    TO CONTENTS-START_TIME,
          SPACE                    TO CONTENTS-END_TIME.

    SORT BENU_STAT DESCENDING BY CNT.
    " Limit? Twice as oft than others
    LIMIT = 200 DIV L_LINES + 1 .
    TAB_LINES = 6.
    LOOP AT BENU_STAT.
*   * Table shall show only the most often entries.
      ACCU = BENU_STAT-CNT.
      MULTIPLY ACCU BY 100.
      DIVIDE ACCU BY RECORDCNT-GOOD.
      " As high scores are bad, use color 6 (too low)
      MOVE BENU_STAT-BENU TO GS_BENU-BENU.
      MOVE BENU_STAT-CNT  TO GS_BENU-CNT.
      MOVE ACCU           TO GS_BENU-ACCU.
      MOVE PAGE_TYPE TO GS_BENU-HIDE_LINE_TYPE.
      APPEND GS_BENU TO GT_BENU.
      CLEAR GS_BENU.
      CONTENTS_CHAPTER_EMPTY = SAP_NO.
    ENDLOOP.

    IF CONTENTS_CHAPTER_EMPTY = SAP_NO.
      CONTENTS-END_PAGE = SY-PAGNO.
      APPEND CONTENTS.
    ENDIF.
    CONTENTS_CHAPTER_EMPTY = SAP_YES.
  ENDIF.
ENDFORM.                    "WRITE_BENU_STAT_ALV

*&--------------------------------------------------------------------*
*&      Form  WRITE_MSG_STAT_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*      -->A_LINES    text
*---------------------------------------------------------------------*
FORM WRITE_MSG_STAT_ALV USING A_LINES.
************************************************************************
*    WRITE_MSG_STAT - Write the statistics about TSL1D/T messages
*
*    Global: BENU_STAT      (read_only)
*    Global: PAGE_TYPE
*    Global: CONTENTS       (APPEND)
*    Global: RECORDCNT-GOOD  (read_only)
*
*    Effect: NEW-PAGE,
*            WRITE
*
  DATA: LIMIT_LINES TYPE I
      , ALL_DONE
      .

  IF LAYOUT-W_STATS = SAP_YES  AND  RECORDCNT-GOOD > 0.
    PAGE_TYPE                = 'I'.
    HIDE_LINE_TYPE           = '-'.
    CONTENTS_NEXT_START_PAGE = SY-PAGNO.
    NEW-PAGE NO-HEADING NO-TITLE.
    ADD 1 TO CONTENTS_NEXT_START_PAGE.
    " SY-PAGNO will be incremented not before the first WRITE.

    MOVE: CONTENTS_NEXT_START_PAGE  TO CONTENTS-START_PAGE,
          'message statistics'(270) TO CONTENTS-NAME,
          SPACE                     TO CONTENTS-START_TIME,
          SPACE                     TO CONTENTS-END_TIME.

    LIMIT_LINES = A_LINES - 6 . " for title,...

    CONTENTS_CHAPTER_EMPTY = SAP_NO. " I hope it will write a line

    CALL FUNCTION 'RSLG_WRITE_TAB_CACHE_STAT_ALV'
      EXPORTING
        MAX_LINES         = LIMIT_LINES
        SCALE_NUMBER      = RECORDCNT-GOOD
      IMPORTING
        ALL_LINES_WRITTEN = ALL_DONE
      TABLES
        GT_SL03_SYSLOGTAB = GT_RSLGTCACHE
      EXCEPTIONS
        BAD_PARAMTERS     = 1
        OTHERS            = 2.
    IF SY-SUBRC <> 0.
      MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
              WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
    ENDIF.

    LOOP AT GT_RSLGTCACHE INTO GS_RSLGTCACHE.
      ACCU = GS_RSLGTCACHE-COUNTER.
      MULTIPLY ACCU BY 100.
      DIVIDE ACCU BY RECORDCNT-GOOD.

      MOVE GS_RSLGTCACHE-AREA TO GS_MSG-AREA.
      MOVE GS_RSLGTCACHE-COUNTER TO GS_MSG-COUNTER.
      MOVE ACCU  TO GS_MSG-ACCU.
      MOVE PAGE_TYPE TO GS_MSG-HIDE_LINE_TYPE.
      MOVE GS_RSLGTCACHE-TXT TO GS_MSG-TXT.
      APPEND GS_MSG TO GT_MSG.
      CLEAR GS_MSG.
    ENDLOOP.

    IF CONTENTS_CHAPTER_EMPTY = SAP_NO.
      CONTENTS-END_PAGE = SY-PAGNO.
      APPEND CONTENTS.
    ENDIF.
    CONTENTS_CHAPTER_EMPTY = SAP_YES.

  ENDIF.
ENDFORM.                    "WRITE_MSG_STAT_ALV

*EJECT

FORM WRITE_DYNPRO_TITLE.
***********************************************************************

*
*    WRITE_DYNPRO_TITLE - Write a title for explanations about records
*                       generated by the collecting daemon itself.
*
*    Effect: WRITE
*
  " Normal header written by ABAP list processor is enough.
ENDFORM.                    "WRITE_DYNPRO_TITLE

*EJECT

FORM WRITE_RECORDCNT_ALV.
*-----------------------------------------------------------------------
* write all the record counters.

  DATA: L_IX TYPE I VALUE 0
      , BEGIN OF L_CNT1.
          INCLUDE STRUCTURE RSLGRECCNT.
  DATA: END   OF L_CNT1
      , BEGIN OF L_CNT2.
          INCLUDE STRUCTURE RSLGRECCNT.
  DATA: END   OF L_CNT2
      .

  CLEAR L_CNT1.
  LOOP AT REC_CNTS.
    IF REC_CNTS-ERRRC = 0.
      IF REC_CNTS-KIND = 'R'.
        ADD 1 TO L_IX.
        ADD-CORRESPONDING REC_CNTS TO L_CNT1.
      ELSEIF REC_CNTS-KIND = 'P'.
        MOVE-CORRESPONDING REC_CNTS TO L_CNT2.
      ENDIF.
    ELSE.
      PERFORM WRITE_RFC_ERRORMSG_ALV.
    ENDIF.
  ENDLOOP.
  IF L_CNT1 = L_CNT2.
    PERFORM WRITE_RECORDCNT_2_ALV USING 'P' ' ' L_CNT2.
  ELSE.
    IF L_IX <= 1.
      PERFORM WRITE_RECORDCNT_2_ALV USING 'R' 'Reading:'(600) L_CNT1.
    ELSE.
  PERFORM WRITE_RECORDCNT_2_ALV USING 'R' 'Sum of reading:'(601) L_CNT1.
      MOVE '<F2> here for list for each instance.'(602) TO GS_END-LINE.
      APPEND GS_END TO GT_END.
      HIDE_LINE_TYPE = 'L'.
      MOVE HIDE_LINE_TYPE TO GS_HIDE_BUFFER-HIDE_LINE_TYPE.
    ENDIF.
   PERFORM WRITE_RECORDCNT_2_ALV USING 'P' 'During rescan:'(234) L_CNT2.
  ENDIF.

ENDFORM. "WRITE_RECORDCNT_ALV
*EJECT

FORM WRITE_RECORDCNT_2_ALV USING A_KIND A_RFCDEST
                            A_CNTS STRUCTURE RSLGRECCNT.
* write a set of record counters.

  IF A_KIND = 'R'.
    CLEAR GS_END.
    MOVE A_RFCDEST TO GS_END.
    APPEND GS_END TO GT_END.

  ELSEIF A_KIND = 'P'.

    CLEAR GS_END.
    MOVE 'During rescan:'(234) TO GS_END.
    APPEND GS_END TO GT_END.

  ENDIF.
  CLEAR: GS_END, GV_LINE.
  CONCATENATE 'Number of records read.........'(220)  A_CNTS-TOTAL
                                   INTO GV_LINE SEPARATED BY SPACE.
  MOVE GV_LINE TO GS_END.
  APPEND GS_END TO GT_END.

  CLEAR: GS_END, GV_LINE.
  CONCATENATE 'Number of records selected.....'(221) A_CNTS-GOOD
                                   INTO GV_LINE SEPARATED BY SPACE.
  MOVE GV_LINE TO GS_END.
  APPEND GS_END TO GT_END.

  IF A_CNTS-OLD_FILE > 0.
    CLEAR: GS_END, GV_LINE.
    CONCATENATE 'too old files skipped.....'(223) A_CNTS-OLD_FILE
                               INTO GV_LINE SEPARATED BY SPACE.
    MOVE GV_LINE TO GS_END.
    APPEND GS_END TO GT_END.

  ENDIF.
  IF A_CNTS-WRO_START > 0.
    CLEAR: GS_END, GV_LINE.
    CONCATENATE 'records before pos. skipped....'(451) A_CNTS-WRO_START
                               INTO GV_LINE SEPARATED BY SPACE.
    MOVE GV_LINE TO GS_END.
    APPEND GS_END TO GT_END.

  ENDIF.
  IF A_CNTS-WRO_STOP > 0.
    CLEAR: GS_END, GV_LINE.
    CONCATENATE 'records behind pos. skipped....'(452)  A_CNTS-WRO_STOP
                               INTO GV_LINE SEPARATED BY SPACE.
    MOVE GV_LINE TO GS_END.
    APPEND GS_END TO GT_END.

  ENDIF.
  IF A_CNTS-WRO_BEGIN > 0.
    CLEAR: GS_END, GV_LINE.
   CONCATENATE 'too old    records skipped.....'(224)  A_CNTS-WRO_BEGIN
                                       INTO GV_LINE SEPARATED BY SPACE.
    MOVE GV_LINE TO GS_END.
    APPEND GS_END TO GT_END.
  ENDIF.
  IF A_CNTS-WRO_END > 0.
    CLEAR: GS_END, GV_LINE.
    CONCATENATE 'too young  records skipped.....'(225)  A_CNTS-WRO_END
                                        INTO GV_LINE SEPARATED BY SPACE.
    MOVE GV_LINE TO GS_END.
    APPEND GS_END TO GT_END.

  ENDIF.
  IF A_CNTS-WRO_FTYP > 0.
    CLEAR: GS_END, GV_LINE.
    CONCATENATE 'other FTYP records skipped.....'(226)  A_CNTS-WRO_FTYP
                                        INTO GV_LINE SEPARATED BY SPACE.
    MOVE GV_LINE TO GS_END.
    APPEND GS_END TO GT_END.

  ENDIF.
  IF A_CNTS-WRO_DEVC > 0.
    CLEAR: GS_END, GV_LINE.
    CONCATENATE 'other  devclass  rec skipped...'(230)  A_CNTS-WRO_DEVC
                                        INTO GV_LINE SEPARATED BY SPACE.
    MOVE GV_LINE TO GS_END.
    APPEND GS_END TO GT_END.
  ENDIF.
  IF A_CNTS-WRO_CLASID > 0.
    CLEAR: GS_END, GV_LINE.
   CONCATENATE 'other clasid records skipped...'(231) A_CNTS-WRO_CLASID
                                       INTO GV_LINE SEPARATED BY SPACE.
    MOVE GV_LINE TO GS_END.
    APPEND GS_END TO GT_END.

  ENDIF.
  IF A_CNTS-WRO_TASK > 0.
    CLEAR: GS_END, GV_LINE.
    CONCATENATE 'other task records skipped.....'(227) A_CNTS-WRO_TASK
                                        INTO GV_LINE SEPARATED BY SPACE.
    MOVE GV_LINE TO GS_END.
    APPEND GS_END TO GT_END.
  ENDIF.
  IF A_CNTS-WRO_TERM > 0.
    CLEAR: GS_END, GV_LINE.
    CONCATENATE 'other terminal rec skipped.....'(228) A_CNTS-WRO_TERM
                                        INTO GV_LINE SEPARATED BY SPACE.
    MOVE GV_LINE TO GS_END.
    APPEND GS_END TO GT_END.
  ENDIF.
  IF A_CNTS-WRO_USER > 0.
    CLEAR: GS_END, GV_LINE.
    CONCATENATE 'other user rec skipped.........'(233) A_CNTS-WRO_USER
                                        INTO GV_LINE SEPARATED BY SPACE.
    MOVE GV_LINE TO GS_END.
    APPEND GS_END TO GT_END.
  ENDIF.
  IF A_CNTS-WRO_TCODE > 0.
    CLEAR: GS_END, GV_LINE.
    CONCATENATE 'other transact.code skipped....'(237) A_CNTS-WRO_TCODE
                                        INTO GV_LINE SEPARATED BY SPACE.
    MOVE GV_LINE TO GS_END.
    APPEND GS_END TO GT_END.
  ENDIF.
  IF A_CNTS-WRO_REPNA > 0.
    CLEAR: GS_END, GV_LINE.
    CONCATENATE 'other program name skipped.....'(238) A_CNTS-WRO_REPNA
                                        INTO GV_LINE SEPARATED BY SPACE.
    MOVE GV_LINE TO GS_END.
    APPEND GS_END TO GT_END.
  ENDIF.
  IF A_CNTS-WRO_TABE > 0.
    CLEAR: GS_END, GV_LINE.
    CONCATENATE 'ignored message rec skipped....'(236)  A_CNTS-WRO_TABE
                                        INTO GV_LINE SEPARATED BY SPACE.
    MOVE GV_LINE TO GS_END.
    APPEND GS_END TO GT_END.
  ENDIF.
  IF A_CNTS-WRO_INST > 0.
    CLEAR: GS_END, GV_LINE.
    CONCATENATE 'other sender rec.  skipped.....'(229)  A_CNTS-WRO_INST
                                        INTO GV_LINE SEPARATED BY SPACE.
    MOVE GV_LINE TO GS_END.
    APPEND GS_END TO GT_END.

  ENDIF.
  IF A_CNTS-INTERN_SKP > 0.
    CLEAR: GS_END, GV_LINE.
    CONCATENATE  'Info-Saetze unterdrueckt.......'(232)
                     A_CNTS-INTERN_SKP INTO GV_LINE SEPARATED BY SPACE.
    MOVE GV_LINE TO GS_END.
    APPEND GS_END TO GT_END.
  ENDIF.
  IF A_CNTS-WRO_PARARE > 0.
    CLEAR: GS_END, GV_LINE.
    CONCATENATE  'Parameter-Saetze unterdrueckt..'(235)
                    A_CNTS-WRO_PARARE INTO GV_LINE SEPARATED BY SPACE.
    MOVE GV_LINE TO GS_END.
    APPEND GS_END TO GT_END.

  ENDIF.

  IF A_KIND = 'R'.
    " nothing here.
  ELSEIF A_KIND = 'P'.

    CLEAR: GS_END, GV_LINE.
    CONCATENATE  'Number of records printed......'(222)
                    A_CNTS-PRINTED INTO GV_LINE SEPARATED BY SPACE.
    MOVE GV_LINE TO GS_END.
    APPEND GS_END TO GT_END.
  ENDIF.

ENDFORM. "WRITE_RECORDCNT_2_ALV
*EJECT


FORM WRITE_RFC_ERRORMSG_ALV.

  CASE REC_CNTS-ERRRC.
    WHEN 1.
      CLEAR: GS_END, GV_LINE.
    CONCATENATE REC_CNTS-RFCDEST 'RFC error'(610) REC_CNTS-ERRMESS INTO
                                            GV_LINE SEPARATED BY SPACE.
      MOVE GV_LINE TO GS_END-LINE.
      APPEND GS_END TO GT_END.
    WHEN 2.
      CLEAR: GS_END, GV_LINE.
    CONCATENATE REC_CNTS-RFCDEST 'RFC system failure'(611) INTO GV_LINE
                                                    SEPARATED BY SPACE.
      MOVE GV_LINE TO GS_END-LINE.
      APPEND GS_END TO GT_END.

    WHEN 3.
      CLEAR: GS_END, GV_LINE.
     CONCATENATE REC_CNTS-RFCDEST 'RFC communication failure'(612) INTO
                                            GV_LINE SEPARATED BY SPACE.
      MOVE GV_LINE TO GS_END-LINE.
      APPEND GS_END TO GT_END.
    WHEN 4.
      CLEAR: GS_END, GV_LINE.
     CONCATENATE REC_CNTS-RFCDEST 'no active RFC destination'(613) INTO
                                            GV_LINE SEPARATED BY SPACE.
      MOVE GV_LINE TO GS_END-LINE.
      APPEND GS_END TO GT_END.
  ENDCASE.
ENDFORM.                    "WRITE_RFC_ERRORMSG_ALV


*EJECT
FORM CLEAR_ALL_HIDDEN.
  CLEAR HIDE_C_BUFFER.
  CLEAR HIDE_BUFFER.
  CLEAR: HIDE_TEXT, HIDE_TEXT_LG.
  CLEAR HIDE_ABAP_INFO.
  CLEAR HIDE_PARAMS.
ENDFORM.                    "CLEAR_ALL_HIDDEN


FORM WRITE_DOCUTITLE_ALV USING A_TITLE.
*----===============
* Write one titleline for documentation.
*
  IF A_TITLE >< SPACE.
    MOVE A_TITLE TO GS_DOC-LINE.
    APPEND GS_DOC TO GT_DOC.
    CLEAR: GS_DOC, GV_LINE.
  ENDIF.
ENDFORM.                    "WRITE_DOCUTITLE_ALV

*&--------------------------------------------------------------------*
*&      Form  WRITE_DOCULINE_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*      -->A_LINE     text
*      -->A_LOOK_DOCUtext
*---------------------------------------------------------------------*
FORM WRITE_DOCULINE_ALV USING A_LINE A_LOOK_DOCU.
*----==============
* Write one line of raw documentation.
* Remove formating commands like <ZH>, </>,...
* Set a_look_docu, if something like <DS:...> was seen.
* Never clear a_look_docu.
*
  DATA: LL(132)
      , POS1 TYPE I
      , POS2 TYPE I
      , RESTLEN TYPE I
      , NLEN TYPE I
      .
  FIELD-SYMBOLS: <LP>
              , <RP>
              .
  LL = A_LINE.
  RESTLEN = STRLEN( LL ).
  IF RESTLEN > 0.
    ASSIGN LL(RESTLEN) TO <LP>.
    WHILE RESTLEN > 0.
      IF <LP> CA '<'.
        POS1 = SY-FDPOS.
        POS2 = POS1 + 2.        " Look for   </> ,...
        NLEN = RESTLEN - 3.
        IF RESTLEN >= 3.
          ASSIGN <LP>+POS2(1) TO <RP>.
          IF <RP> = '>'.
            RESTLEN = RESTLEN - POS1.
            ASSIGN <LP>+POS1(RESTLEN) TO <LP>.
            SHIFT <LP> LEFT BY 3 PLACES.
            RESTLEN = RESTLEN - 3.
          ELSEIF RESTLEN >= 4.
            POS2 = POS1 + 3.        " Look for   <ZH> ,...
            ASSIGN <LP>+POS2(1) TO <RP>.
            IF <RP> = '>'.
              RESTLEN = RESTLEN - POS1.
              ASSIGN <LP>+POS1(RESTLEN) TO <LP>.
              SHIFT <LP> LEFT BY 4 PLACES.
              RESTLEN = RESTLEN - 4.
            ELSE.
              IF <RP> = ':'.         " Look for <DS:.......>
                A_LOOK_DOCU = 'X'.
              ENDIF.
*             Skip behind that unusable '<'.
              ADD 1 TO POS1.
              RESTLEN = RESTLEN - POS1.
              ASSIGN <LP>+POS1(RESTLEN) TO <LP>.
            ENDIF.
          ELSE.
            EXIT. "from WHILE loop. Too close to end.
          ENDIF.
        ELSE.
          EXIT. "from WHILE loop. Too close to end.
        ENDIF.
      ELSE.
        EXIT. " No (more) '<'.
      ENDIF.
    ENDWHILE.
  ENDIF.
  MOVE LL TO GS_DOC-LINE.
  APPEND GS_DOC TO GT_DOC.
  CLEAR: GS_DOC, GV_LINE.

ENDFORM.                    "WRITE_DOCULINE_ALV

*&--------------------------------------------------------------------*
*&      Form  WRITE_DOCU_COMPLEX_ALV
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*      -->A_COMPLEX_Dtext
*---------------------------------------------------------------------*
FORM WRITE_DOCU_COMPLEX_ALV USING A_COMPLEX_DOCU.
  IF A_COMPLEX_DOCU >< SPACE.
    MOVE 'Eine Doku-Aufbereitung zeigt mehr       ;;'(680)
                                           TO GS_DOC-LINE.
    APPEND GS_DOC TO GT_DOC.
    CLEAR: GS_DOC, GV_LINE.
  ENDIF.
ENDFORM.                    "WRITE_DOCU_COMPLEX_ALV


*EJECT
FORM EXPLAIN_TASK_TYPE USING A_TT A_TEXT.
*----=================-------------------
*
*    EXPLAIN_TASK_TYPE  -  Convert a short id of a SAP process into
*                          a longer description.
*
*    Input : A_TT      that short id
*
*    Output: A_TEXT    a description
*

  DATA: L_TT(2)
      , L_TT_1
      , L_TT_2
      , L_TEXT(120)
      .

* Copy to local variable to allow access of parts.
* And convert to upper case, because the compares in SEL_CHECK are not
* case sensitive.
  L_TT      = A_TT.
  L_TT_1 = L_TT(1).
  TRANSLATE L_TT_1 TO UPPER CASE.
  L_TT_2 = L_TT+1(1).

* Set default answer.
  L_TEXT    = 'Taskart'(410).
  L_TEXT+70 = '"'.
  L_TEXT+71 = L_TT.
  L_TEXT+73 = '"'.
*418 wiederbelegbar!

  CASE L_TT_1.
    WHEN ' '.
      CASE L_TT_2.
        WHEN ' '.
          L_TEXT = SPACE.  " all space: no selection criteria given.
      ENDCASE.
    WHEN 'B'.
      L_TEXT    = 'BTC Hintergrundbearbeiter'(423).
      L_TEXT+70 = 'Nr.'(420). L_TEXT+110 = AUX_SLGPROC-TASKTNO+2(3).
    WHEN 'D'.
      IF L_TT_2 = 'p'.
        L_TEXT = 'Dispatcher'(412).
      ELSEIF L_TT_2 = 'P'.
        L_TEXT = 'Dispatcher'(412).
      ELSE.
        L_TEXT    = 'DIA Dialog-Arbeitsprozess'(413).
        L_TEXT+70 = 'Nr.'(420). L_TEXT+110 = AUX_SLGPROC-TASKTNO+2(3).
      ENDIF.
    WHEN 'E'.
      L_TEXT    = 'ENQ Sperrverwalter'(422).
      L_TEXT+70 = 'Nr.'(420). L_TEXT+110 = AUX_SLGPROC-TASKTNO+2(3).
    WHEN 'M'.
      CASE L_TT_2.
        WHEN 's'.
          L_TEXT = 'message server'(416).
        WHEN 'S'.
          L_TEXT = 'message server'(416).
          "Default already set.
      ENDCASE.
    WHEN 'R'.
      IF A_TT = 'RD'.
        L_TEXT = 'Gateway'(424).
      ENDIF.
    WHEN 'S'.
      IF A_TT = 'sa'.
        L_TEXT = 'S-A Stand-alone Programm'(415).
      ELSE.
        L_TEXT    = 'Ausgabeaufbereiter'(414).
        L_TEXT+70 = 'Nr.'(420). L_TEXT+110 = AUX_SLGPROC-TASKTNO+2(3).
      ENDIF.
    WHEN 'T'.
      CASE L_TT_2.
        WHEN 'T'.
          L_TEXT = 'schlecht initialisiertes Stand-alone Programm'(419).
          "Default already set.
      ENDCASE.
    WHEN 'U'.
      L_TEXT    = 'UPD V1-Verbucher'(417).
      L_TEXT+70 = 'Nr.'(420). L_TEXT+110 = AUX_SLGPROC-TASKTNO+2(3).
    WHEN 'V'.
      L_TEXT    = 'UP2 V2-Verbucher'(418).
      L_TEXT+70 = 'Nr.'(420). L_TEXT+110 = AUX_SLGPROC-TASKTNO+2(3).
    WHEN 'W'.
      L_TEXT    = 'Arbeitsprozess'(421).
      L_TEXT+70 = 'Nr.'(420). L_TEXT+110 = AUX_SLGPROC-TASKTNO+2(3).
  ENDCASE.
  CONDENSE L_TEXT.
  A_TEXT = L_TEXT.

ENDFORM. "EXPLAIN_TASK_TYPE

*&--------------------------------------------------------------------*
*&      Form  EXPLAIN_TASK_NUMBER
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*      -->A_NICE1    text
*      -->A_NICE2    text
*      -->A_RAW      text
*---------------------------------------------------------------------*
FORM EXPLAIN_TASK_NUMBER USING A_NICE1 A_NICE2 A_RAW.
  DATA L_RAW(1).

  A_NICE1 = 'Nr.'(420).
  L_RAW = A_RAW.
  TRANSLATE L_RAW TO LOWER CASE.
  CASE L_RAW.
    WHEN '0'. A_NICE2 = '0'.
    WHEN '1'. A_NICE2 = '1'.
    WHEN '2'. A_NICE2 = '2'.
    WHEN '3'. A_NICE2 = '3'.
    WHEN '4'. A_NICE2 = '4'.
    WHEN '5'. A_NICE2 = '5'.
    WHEN '6'. A_NICE2 = '6'.
    WHEN '7'. A_NICE2 = '7'.
    WHEN '8'. A_NICE2 = '8'.
    WHEN '9'. A_NICE2 = '9'.
    WHEN 'a'. A_NICE2 = '10'.
    WHEN 'b'. A_NICE2 = '11'.
    WHEN 'c'. A_NICE2 = '12'.
    WHEN 'd'. A_NICE2 = '13'.
    WHEN 'e'. A_NICE2 = '14'.
    WHEN 'f'. A_NICE2 = '15'.
    WHEN 'g'. A_NICE2 = '16'.
    WHEN 'h'. A_NICE2 = '17'.
    WHEN 'i'. A_NICE2 = '18'.
    WHEN 'j'. A_NICE2 = '19'.                           "#EC NO_M_RISC3
    WHEN 'k'. A_NICE2 = '20'.                           "#EC NO_M_RISC3
    WHEN 'l'. A_NICE2 = '21'.
    WHEN 'm'. A_NICE2 = '22'.
    WHEN 'n'. A_NICE2 = '23'.
    WHEN 'o'. A_NICE2 = '24'.
    WHEN 'p'. A_NICE2 = '25'.
    WHEN 'q'. A_NICE2 = '26'.
    WHEN 'r'. A_NICE2 = '27'.
    WHEN 's'. A_NICE2 = '28'.
    WHEN 't'. A_NICE2 = '29'.
    WHEN 'u'. A_NICE2 = '30'.
    WHEN 'v'. A_NICE2 = '31'.
    WHEN 'w'. A_NICE2 = '32'.
    WHEN 'x'. A_NICE2 = '33'.
    WHEN 'y'. A_NICE2 = '34'.
    WHEN 'z'. A_NICE2 = '35'.
    WHEN '*'. A_NICE1 = '<generisch>'(570). A_NICE2 = SPACE.
    WHEN OTHERS. A_NICE2 = A_RAW.
  ENDCASE.

ENDFORM. " EXPLAIN_TASK_NUMBER

*EJECT
FORM SHOW_CLOCKS.

  DATA: LD    TYPE D
      , LT    TYPE T
      , L_UZE TYPE T
      , LTMIN TYPE T
      , LTMAX TYPE T
      , LS    LIKE RSLGTYPE-TIME
      .
  DATA: LV_DATE(10).
  L_UZE = SY-UZEIT.
  CALL 'C_GET_SYSLOG_POS' ID 'CLCK' FIELD LS.
  LD = LS+0(8).
  LT = LS+8(6).
  LTMIN = LT - 600. " 10 minutes
  LTMAX = LT + 600. " 10 minutes
  REFRESH GT_CLOCK.
  IF LTMIN > L_UZE OR L_UZE > LTMAX.
     MOVE 'Die Uhrem im Netz muessen ueberprueft werden!'(560) TO
                                                  GS_CLOCK-LINE.
    APPEND GS_CLOCK TO GT_CLOCK.
    CLEAR GS_CLOCK.
    APPEND GS_CLOCK TO GT_CLOCK.
  ENDIF.

  PERFORM DYNPRO_TO_LIST_ALV USING 'BACK'.

  MOVE 'Die Anwendungstransaktionen benutzen die Uhr des '(530) TO
                                                GS_CLOCK-LINE.
  APPEND GS_CLOCK TO GT_CLOCK.
  CLEAR GS_CLOCK.

  MOVE 'ABAP-Prozessors, die sich wiederum aus der Uhr des '(531) TO
                                                GS_CLOCK-LINE.
  APPEND GS_CLOCK TO GT_CLOCK.
  CLEAR GS_CLOCK.

  MOVE 'Datenbank-Verwaltungssystems auf dem Datanbank-Server '(532)
                                              TO  GS_CLOCK-LINE.
  APPEND GS_CLOCK TO GT_CLOCK.
  CLEAR GS_CLOCK.

  MOVE 'ableitet.'(533) TO GS_CLOCK-LINE.
  APPEND GS_CLOCK TO GT_CLOCK.
  CLEAR GS_CLOCK.

  CONCATENATE 'Diese Uhr zeigt jetzt'(535) L_UZE 'an.'(536) INTO
                                GS_CLOCK-LINE SEPARATED BY SPACE.
  APPEND GS_CLOCK TO GT_CLOCK.
  CLEAR GS_CLOCK.

  WRITE SY-DATUM DD/MM/YYYY TO LV_DATE.
  CONCATENATE 'Dabei ist das Datum'(537) LV_DATE '.'(538) INTO
                              GS_CLOCK-LINE SEPARATED BY SPACE.
  APPEND GS_CLOCK TO GT_CLOCK.
  CLEAR GS_CLOCK.
  APPEND GS_CLOCK TO GT_CLOCK.

  MOVE 'Das SysLog-System benutzt - wie alle Kernal-Schichten '(540)
                                             TO  GS_CLOCK-LINE.
  APPEND GS_CLOCK TO GT_CLOCK.
  CLEAR GS_CLOCK.

 MOVE 'unterhalb des ABAP-Prozessors - die Uhr des Betriebssystems'(541)
                                               TO GS_CLOCK-LINE.
  APPEND GS_CLOCK TO GT_CLOCK.
  CLEAR GS_CLOCK.

  MOVE 'auf dem eigenen Rechner.'(543) TO GS_CLOCK-LINE.
  APPEND GS_CLOCK TO GT_CLOCK.
  CLEAR GS_CLOCK.

  CONCATENATE 'Diese Uhr zeigt jetzt'(535) LT 'an.'(536)
                   INTO GS_CLOCK-LINE SEPARATED BY SPACE.
  APPEND GS_CLOCK TO GT_CLOCK.
  CLEAR GS_CLOCK.

  WRITE LD DD/MM/YYYY TO LV_DATE.
  CONCATENATE 'Dabei ist das Datum'(537) LV_DATE '.'(538) INTO
                              GS_CLOCK-LINE SEPARATED BY SPACE.
  APPEND GS_CLOCK TO GT_CLOCK.
  CLEAR GS_CLOCK.
  APPEND GS_CLOCK TO GT_CLOCK.
  IF COLLECT_HOST = I_AM_HOST.
    MOVE 'Diese Uhr wird auch fuer das zentrale SysLog benutzt.'(550)
                                               TO  GS_CLOCK-LINE.
    APPEND GS_CLOCK TO GT_CLOCK.
    CLEAR GS_CLOCK.

   MOVE 'Die Uhrzeiten der Eintraege von anderen Rechnern werden '(552)
                                               TO  GS_CLOCK-LINE.
    APPEND GS_CLOCK TO GT_CLOCK.
    CLEAR GS_CLOCK.

    MOVE 'auf diese Uhr umgerechnet.'(553) TO  GS_CLOCK-LINE.
    APPEND GS_CLOCK TO GT_CLOCK.
    CLEAR GS_CLOCK.

  ELSEIF COLLECT_HOST = NO_HOST.
    " Do not mention it.
  ELSE.
    MOVE 'Fuer das zentrale SysLog'(556) TO  GS_CLOCK-LINE.
    APPEND GS_CLOCK TO GT_CLOCK.
    CLEAR GS_CLOCK.

    CONCATENATE 'wird die SysLog-Uhr des Rechners'(557) COLLECT_HOST
              'benutzt.'(558) INTO  GS_CLOCK-LINE SEPARATED BY SPACE.
    APPEND GS_CLOCK TO GT_CLOCK.
    CLEAR GS_CLOCK.

   MOVE 'Die Uhrzeiten der Eintraege von anderen Rechnern werden '(552)
                                               TO  GS_CLOCK-LINE.
    APPEND GS_CLOCK TO GT_CLOCK.
    CLEAR GS_CLOCK.

    MOVE 'auf diese Uhr umgerechnet.'(553) TO  GS_CLOCK-LINE.
    APPEND GS_CLOCK TO GT_CLOCK.
    CLEAR GS_CLOCK.
  ENDIF.

  PERFORM SHOW_CLOCKS_ALV.

ENDFORM. " SHOW_CLOCKS

*EJECT
FORM SHOW_DAEMON_MSG.
  CALL SCREEN 2040 STARTING AT 5 5.
ENDFORM. "SHOW_DAEMON_MSG.

*EJECT
FORM SHOW_SAPPARAMS.

  DATA: BEGIN OF PAR_SEL2 OCCURS 10.
          INCLUDE STRUCTURE RSLGPARTAB.
  DATA: END OF PAR_SEL2
      .
  PAR_SEL2-PARAMNAME  = 'rslg/'.
  PAR_SEL2-GENERICLEN =      5 .
  APPEND PAR_SEL2.

  PERFORM DYNPRO_TO_LIST_ALV USING 'BACK'.

  CALL FUNCTION 'RSLG_SHOW_SAPPARAM_ALV'
                TABLES     NAMEPATTERN = PAR_SEL2.
 ENDFORM. " SHOW_SAPPARAMS

*EJECT
FORM SHOW_PERMISSIONS.

  PERFORM DYNPRO_TO_LIST_ALV USING 'BACK'.

  PERFORM EXPLAIN_PERMISSIONS. "both

* PERFORM LIST_TO_DYNPRO.

ENDFORM. " SHOW_PERMISSIONS



*&--------------------------------------------------------------------*
*&      Form  EXPLAIN_PERMISSIONS
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM EXPLAIN_PERMISSIONS.
  REFRESH: GT_AUTH_TOP, GT_AUTH.
  IF MAY_WORK = 'X'.
    MOVE 'Sie duerfen das SysLog analysieren.'(510) TO GS_AUTH_TOP-LINE.
    APPEND GS_AUTH_TOP TO GT_AUTH_TOP.
    CLEAR GS_AUTH_TOP.
    MOVE 'Sie duerfen das SysLog nicht analysieren.'(511) TO
                                            GS_AUTH_TOP-LINE.
    APPEND GS_AUTH_TOP TO GT_AUTH_TOP.
    CLEAR GS_AUTH_TOP.
  ENDIF.
  CONCATENATE 'Fuer die Bedienung dieser Transaktion sind'(512)
               'folgende Berechtigungen bedeutsam:'(513) INTO
                          GS_AUTH_TOP-LINE SEPARATED BY SPACE..
  APPEND GS_AUTH_TOP TO GT_AUTH_TOP.
  CLEAR GS_AUTH_TOP.

  MOVE 'Pruefung:'(514) TO GS_AUTH-FIELD1.
  MOVE 'S_ADMIN_FCD-S_ADMIN_FCD = SM21' TO GS_AUTH-FIELD2.

  IF MAY_WORK = 'X'.
    MOVE 'positiv'(515) TO GS_AUTH-FIELD3.
  ELSE.
    MOVE 'negativ'(516) TO GS_AUTH-FIELD3.
  ENDIF.
  APPEND GS_AUTH TO GT_AUTH.
  CLEAR GS_AUTH.
  MOVE 'Berechtigung:'(517) TO GS_AUTH-FIELD1.
  MOVE 'S_ADMI_ALL'         TO GS_AUTH-FIELD2.
  APPEND GS_AUTH TO GT_AUTH.
  CLEAR GS_AUTH.
  MOVE 'S_ADMI_SLOG'        TO GS_AUTH-FIELD2.
  APPEND GS_AUTH TO GT_AUTH.
  CLEAR GS_AUTH.
  MOVE 'und vielleicht andere.'(518) TO GS_AUTH-FIELD2.
  APPEND GS_AUTH TO GT_AUTH.
  CLEAR GS_AUTH.
  MOVE 'Profile:'(519) TO GS_AUTH-FIELD1.
  MOVE 'SAP_ALL'       TO GS_AUTH-FIELD2.
  APPEND GS_AUTH TO GT_AUTH.
  CLEAR GS_AUTH.
  MOVE 'S_ADMI_ALL'        TO GS_AUTH-FIELD2.
  APPEND GS_AUTH TO GT_AUTH.
  CLEAR GS_AUTH.
  MOVE 'und vielleicht andere.'(518) TO GS_AUTH-FIELD2.
  APPEND GS_AUTH TO GT_AUTH.
  CLEAR GS_AUTH.

  PERFORM EXPLAIN_PERMISSIONS_ALV.
ENDFORM.                    "EXPLAIN_PERMISSIONS


*&--------------------------------------------------------------------*
*&      Form  SET_SURPRESS_POPUPS
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM SET_SURPRESS_POPUPS. "will be called by RSLG0000, RSLG0001,...
  SURPRESS_POPUPS = 'X'.
ENDFORM.                    "SET_SURPRESS_POPUPS


*&--------------------------------------------------------------------*
*&      Form  EXPLAIN_NEW_TASK_TYPE
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*      -->A_TT       text
*      -->A_TEXT     text
*---------------------------------------------------------------------*
FORM EXPLAIN_NEW_TASK_TYPE USING A_TT A_TEXT.
*----=================-------------------
*
* EXPLAIN__NEW_TASK_TYPE  -  Convert a short id of a SAP process into
*                            a longer description.
*
* Input : A_TT      that short id
*
* Output: A_TEXT    a description
*

  DATA: L_TT(3)
      , L_TT_1
      , L_TT_2
      , L_TEXT(120)
      .

* Copy to local variable to allow access of parts.
* And convert to upper case, because the compares in SEL_CHECK are not
* case sensitive.
  L_TT      = A_TT.
  L_TT_1 = L_TT(1).
  TRANSLATE L_TT_1 TO UPPER CASE.
  L_TT_2 = L_TT+1(1).

* Set default answer.
  L_TEXT    = 'Taskart'(410).
  L_TEXT+70 = '"'.
  L_TEXT+71 = L_TT.
  L_TEXT+73 = '"'.
*418 wiederbelegbar!

  CASE L_TT.

    WHEN '   '.
      L_TEXT = SPACE.  " all space: no selection criteria given.

    WHEN 'BTC'.
      L_TEXT  = 'BTC Hintergrundbearbeiter'(423).

    WHEN 'DIA'.
      L_TEXT  = 'DIA Dialog-Arbeitsprozess'(413).

    WHEN 'ENQ'.
      L_TEXT  = 'ENQ Sperrverwalter'(422).

    WHEN 'MS ' .
      L_TEXT  = 'message server'(416).

    WHEN 'RD '.
      L_TEXT  = 'Gateway'(424).

    WHEN 'DP '.
      L_TEXT = 'Dispatcher'(412).

    WHEN 'S-A' OR 'SA '.
      L_TEXT = 'S-A Stand-alone Programm'(415).

    WHEN 'SPO'.
      L_TEXT = 'Ausgabeaufbereiter'(414).

    WHEN 'TT '.
      L_TEXT = 'schlecht initialisiertes Stand-alone Programm'(419).

    WHEN 'WRK'.
      L_TEXT  = 'Arbeitsprozess'(421).

    WHEN 'UP1'.
      L_TEXT  = 'UPD V1-Verbucher'(417).

    WHEN 'UP2'.
      L_TEXT  = 'UP2 V2-Verbucher'(418).

  ENDCASE.

  CONDENSE L_TEXT.
  A_TEXT = L_TEXT.

ENDFORM. "EXPLAIN_NEW_TASK_TYPE

* ABAP/4 SNAP processing:
* -----------------------
*
INCLUDE MSM21F36_ALV.

**** end of report fraction: FORMs
*                                                                      *
** ---------------------- end of MSAPSM21 --------------------------- *

*&---------------------------------------------------------------------*
*&      Form  OUTPUT_ALV
*&---------------------------------------------------------------------*
*    THIS SUBROUTINE DISPLAYS ALL ALV
*----------------------------------------------------------------------*
FORM OUTPUT_ALV .
* When the report is run from RSLG0000
  CONSTANTS:  LC_ITABLE  TYPE DD02L-TABNAME VALUE 'GT_TOP',
              LC_SNAME    TYPE DD02L-TABNAME VALUE 'KERNELSTAT'.
  DATA: LS_TOP TYPE YT_TOP.


*initalize...
GV_LIST_COUNTER = 1.
GV_REPID = SY-REPID.

REFRESH GT_FIELDCAT.

REFRESH GT_COLOR.
GS_COLOR-FNAME = 'LINE'.
GS_COLOR-COLOR-COL = COL_HEADING.
GS_COLOR-COLOR-INT = 1.
GS_COLOR-COLOR-INV = 0.
APPEND GS_COLOR TO GT_COLOR.
MOVE GT_COLOR TO GS_DOC-COLOR.

READ TABLE GT_TOP INTO LS_TOP INDEX 1.
LS_TOP-COLOR = GT_COLOR.
MODIFY GT_TOP FROM LS_TOP INDEX 1.
CLEAR GS_COLOR.
REFRESH GT_COLOR.
CLEAR: GS_DOC, GV_LINE.

 CLEAR PAGE_TYPE.
*This is the perform to set the print option
  PERFORM SET_GT_PRINT CHANGING GT_PRINT.
*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_ITABLE LC_SNAME
                                  CHANGING  GT_FIELDCAT .

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD CHANGING GT_EVENTS[].

* This is the perofrm to set the layout properties
  PERFORM LAYOUT_BUILD CHANGING GS_LAYOUT.
  GS_LAYOUT-MIN_LINESIZE = GV_DEFAULT_LINESIZE.
  GS_LAYOUT-MAX_LINESIZE = GV_DEFAULT_LINESIZE.
  GS_LAYOUT-NO_COLHEAD       = GC_X.
  GS_LAYOUT-coltab_fieldname = 'COLOR'.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM       = GV_REPID
      I_CALLBACK_PF_STATUS_SET = 'LIST_ALV'
      I_CALLBACK_USER_COMMAND  = 'USER_SYSTEM_LOG'
      I_STRUCTURE_NAME         = LC_SNAME
      IS_LAYOUT                = GS_LAYOUT
      IS_PRINT                 = GT_PRINT
*     IT_SORT                  = GT_SORT
      IT_FIELDCAT              = GT_FIELDCAT[]
      IT_EVENTS                = GT_EVENTS
    TABLES
      T_OUTTAB                 = GT_TOP
    EXCEPTIONS
      PROGRAM_ERROR            = 1
      OTHERS                   = 2.
  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM.                    " OUTPUT_ALV

*&---------------------------------------------------------------------*
*&      Form  INST_ALV
*&---------------------------------------------------------------------*
*       DISPLAYS INSTANT STATSTICS
*----------------------------------------------------------------------*
FORM INST_ALV .

  CONSTANTS:  LC_ITABLE  TYPE DD02L-TABNAME VALUE 'GT_INST',
              LC_SNAME   TYPE DD02L-TABNAME VALUE 'IBD_SAPMSM2102_ALV'.

  PAGE_TYPE                = 'S'.
  ADD 1 TO GV_LIST_COUNTER.
  GV_LIST_COUNTER  =  GV_H_LIST_COUNTER  = GV_LIST_COUNTER.
  REFRESH GT_FIELDCAT.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_ITABLE LC_SNAME
                                  CHANGING  GT_FIELDCAT .

  LOOP AT GT_FIELDCAT INTO GS_FIELDCAT.

    GS_FIELDCAT-TECH = GC_X.

    IF GS_FIELDCAT-FIELDNAME = 'INST'.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'CNT'.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'ACCU'.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    MODIFY GT_FIELDCAT FROM GS_FIELDCAT.
    CLEAR GS_FIELDCAT.

  ENDLOOP.

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD CHANGING GT_EVENTS[].

* This is the perofrm to set the layout properties
  PERFORM LAYOUT_BUILD CHANGING GS_LAYOUT.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM       = GV_REPID
      I_CALLBACK_PF_STATUS_SET = 'LIST_ALV'
      I_CALLBACK_USER_COMMAND  = 'USER_SYSTEM_LOG'
      I_STRUCTURE_NAME         = LC_SNAME
      IS_LAYOUT                = GS_LAYOUT
      IT_FIELDCAT              = GT_FIELDCAT
      I_SAVE                   = GC_X
      IT_EVENTS                = GT_EVENTS
    TABLES
      T_OUTTAB                 = GT_INST
    EXCEPTIONS
      PROGRAM_ERROR            = 1
      OTHERS                   = 2.
  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM.                    " INST_ALV

*&---------------------------------------------------------------------*
*&      Form  MAND_ALV
*&---------------------------------------------------------------------*
*      DISPLAYS CLIENT STATISTICS
*----------------------------------------------------------------------*
FORM MAND_ALV .

  CONSTANTS:  LC_ITABLE  TYPE DD02L-TABNAME VALUE 'GT_MAND',
              LC_SNAME   TYPE DD02L-TABNAME VALUE 'IBD_SAPMSM2102_ALV'.

  PAGE_TYPE                = 'M'.
  ADD 1 TO GV_LIST_COUNTER.
  GV_H_LIST_COUNTER  =  GV_LIST_COUNTER.
  REFRESH GT_FIELDCAT.
*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_ITABLE LC_SNAME
                                  CHANGING  GT_FIELDCAT .

  LOOP AT GT_FIELDCAT INTO GS_FIELDCAT.

    GS_FIELDCAT-TECH = GC_X.

    IF GS_FIELDCAT-FIELDNAME = 'MAND'.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'CNT'.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'ACCU'.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    MODIFY GT_FIELDCAT FROM GS_FIELDCAT.
    CLEAR GS_FIELDCAT.

  ENDLOOP.

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD CHANGING GT_EVENTS[].

* This is the perofrm to set the layout properties
  PERFORM LAYOUT_BUILD CHANGING GS_LAYOUT.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM       = GV_REPID
      I_CALLBACK_PF_STATUS_SET = 'LIST_ALV'
      I_CALLBACK_USER_COMMAND  = 'USER_SYSTEM_LOG'
      I_STRUCTURE_NAME         = LC_SNAME
      IS_LAYOUT                = GS_LAYOUT
      IT_FIELDCAT              = GT_FIELDCAT
      I_SAVE                   = GC_X
      IT_EVENTS                = GT_EVENTS
    TABLES
      T_OUTTAB                 = GT_MAND
    EXCEPTIONS
      PROGRAM_ERROR            = 1
      OTHERS                   = 2.
  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM.                    " MAND_ALV

*&---------------------------------------------------------------------*
*&      Form  REPO_ALV
*&---------------------------------------------------------------------*
*      DISPLAYS REPORT STATISTICS
*----------------------------------------------------------------------*
FORM REPO_ALV .

  CONSTANTS:  LC_ITABLE  TYPE DD02L-TABNAME VALUE 'GT_REPO',
              LC_SNAME   TYPE DD02L-TABNAME VALUE 'IBD_SAPMSM2102_ALV'.

  PAGE_TYPE                = 'R'.
  ADD 1 TO GV_LIST_COUNTER.
  GV_H_LIST_COUNTER  =  GV_LIST_COUNTER.
  REFRESH GT_FIELDCAT.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_ITABLE LC_SNAME
                                  CHANGING  GT_FIELDCAT .

  LOOP AT GT_FIELDCAT INTO GS_FIELDCAT.

    GS_FIELDCAT-TECH = GC_X.

    IF GS_FIELDCAT-FIELDNAME = 'REPO'.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'CNT'.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'ACCU'.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    MODIFY GT_FIELDCAT FROM GS_FIELDCAT.
    CLEAR GS_FIELDCAT.

  ENDLOOP.

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD CHANGING GT_EVENTS[].

* This is the perofrm to set the layout properties
  PERFORM LAYOUT_BUILD CHANGING GS_LAYOUT.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM       = GV_REPID
      I_CALLBACK_PF_STATUS_SET = 'LIST_ALV'
      I_CALLBACK_USER_COMMAND  = 'USER_SYSTEM_LOG'
      I_STRUCTURE_NAME         = LC_SNAME
      IS_LAYOUT                = GS_LAYOUT
      IT_FIELDCAT              = GT_FIELDCAT
      I_SAVE                   = GC_X
      IT_EVENTS                = GT_EVENTS
    TABLES
      T_OUTTAB                 = GT_REPO
    EXCEPTIONS
      PROGRAM_ERROR            = 1
      OTHERS                   = 2.
  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM.                    " REPO_ALV

*&---------------------------------------------------------------------*
*&      Form  TCOD_ALV
*&---------------------------------------------------------------------*
*       DISPLAYS TRANSACTIONS STATISTICS
*----------------------------------------------------------------------*
FORM TCOD_ALV .

  CONSTANTS:  LC_ITABLE  TYPE DD02L-TABNAME VALUE 'GT_TCOD',
              LC_SNAME   TYPE DD02L-TABNAME VALUE 'IBD_SAPMSM2102_ALV'.

  PAGE_TYPE                = 'T'.
  ADD 1 TO GV_LIST_COUNTER.
  GV_H_LIST_COUNTER  =  GV_LIST_COUNTER.
  REFRESH GT_FIELDCAT.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_ITABLE LC_SNAME
                                  CHANGING  GT_FIELDCAT .

  LOOP AT GT_FIELDCAT INTO GS_FIELDCAT.

    GS_FIELDCAT-TECH = GC_X.

    IF GS_FIELDCAT-FIELDNAME = 'TCOD'.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'CNT'.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'ACCU'.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    MODIFY GT_FIELDCAT FROM GS_FIELDCAT.
    CLEAR GS_FIELDCAT.

  ENDLOOP.

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD CHANGING GT_EVENTS[].

* This is the perofrm to set the layout properties
  PERFORM LAYOUT_BUILD CHANGING GS_LAYOUT.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM       = GV_REPID
      I_CALLBACK_PF_STATUS_SET = 'LIST_ALV'
      I_CALLBACK_USER_COMMAND  = 'USER_SYSTEM_LOG'
      I_STRUCTURE_NAME         = LC_SNAME
      IS_LAYOUT                = GS_LAYOUT
      IT_FIELDCAT              = GT_FIELDCAT
      I_SAVE                   = GC_X
      IT_EVENTS                = GT_EVENTS
    TABLES
      T_OUTTAB                 = GT_TCOD
    EXCEPTIONS
      PROGRAM_ERROR            = 1
      OTHERS                   = 2.
  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM.                    " TCOD_ALV

*&---------------------------------------------------------------------*
*&      Form  BENU_ALV
*&---------------------------------------------------------------------*
*      DISPLAYS USER STASTICS
*----------------------------------------------------------------------*
FORM BENU_ALV .

  CONSTANTS:  LC_ITABLE  TYPE DD02L-TABNAME VALUE 'GT_BENU',
              LC_SNAME    TYPE DD02L-TABNAME VALUE 'IBD_SAPMSM2102_ALV'.

  PAGE_TYPE                = 'B'.
  ADD 1 TO GV_LIST_COUNTER.
  GV_H_LIST_COUNTER  =  GV_LIST_COUNTER.
  REFRESH GT_FIELDCAT.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_ITABLE LC_SNAME
                                  CHANGING  GT_FIELDCAT .

  LOOP AT GT_FIELDCAT INTO GS_FIELDCAT.

    GS_FIELDCAT-TECH = GC_X.

    IF GS_FIELDCAT-FIELDNAME = 'BENU'.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'CNT'.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'ACCU'.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    MODIFY GT_FIELDCAT FROM GS_FIELDCAT.
    CLEAR GS_FIELDCAT.

  ENDLOOP.

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD CHANGING GT_EVENTS[].

* This is the perofrm to set the layout properties
  PERFORM LAYOUT_BUILD CHANGING GS_LAYOUT.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM       = GV_REPID
      I_CALLBACK_PF_STATUS_SET = 'LIST_ALV'
      I_CALLBACK_USER_COMMAND  = 'USER_SYSTEM_LOG'
      I_STRUCTURE_NAME         = LC_SNAME
      IS_LAYOUT                = GS_LAYOUT
      IT_FIELDCAT              = GT_FIELDCAT
      I_SAVE                   = GC_X
      IT_EVENTS                = GT_EVENTS
    TABLES
      T_OUTTAB                 = GT_BENU
    EXCEPTIONS
      PROGRAM_ERROR            = 1
      OTHERS                   = 2.
  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM.                    " BENU_ALV

*&---------------------------------------------------------------------*
*&      Form  MSG_ALV
*&---------------------------------------------------------------------*
*      displays message statistics
*----------------------------------------------------------------------*
FORM MSG_ALV .

  CONSTANTS:  LC_ITABLE  TYPE DD02L-TABNAME VALUE 'GT_MSG',
              LC_SNAME    TYPE DD02L-TABNAME VALUE 'IBD_SAPMSM2102_ALV'.

  PAGE_TYPE                = 'I'.
  ADD 1 TO GV_LIST_COUNTER.
  GV_H_LIST_COUNTER  =  GV_LIST_COUNTER.
  REFRESH GT_FIELDCAT.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_ITABLE LC_SNAME
                                  CHANGING  GT_FIELDCAT .

  LOOP AT GT_FIELDCAT INTO GS_FIELDCAT.

    GS_FIELDCAT-TECH = GC_X.

    IF GS_FIELDCAT-FIELDNAME = 'AREA'.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'COUNTER'.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'TXT'.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'ACCU'.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    MODIFY GT_FIELDCAT FROM GS_FIELDCAT.
    CLEAR GS_FIELDCAT.

  ENDLOOP.

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD CHANGING GT_EVENTS[].

* This is the perofrm to set the layout properties
  PERFORM LAYOUT_BUILD CHANGING GS_LAYOUT.


  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM       = GV_REPID
      I_CALLBACK_PF_STATUS_SET = 'LIST_ALV'
      I_CALLBACK_USER_COMMAND  = 'USER_SYSTEM_LOG'
      I_STRUCTURE_NAME         = LC_SNAME
      IS_LAYOUT                = GS_LAYOUT
      IT_FIELDCAT              = GT_FIELDCAT
      I_SAVE                   = GC_X
      IT_EVENTS                = GT_EVENTS
    TABLES
      T_OUTTAB                 = GT_MSG
    EXCEPTIONS
      PROGRAM_ERROR            = 1
      OTHERS                   = 2.
  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM.                    " MSG_ALV

*&---------------------------------------------------------------------*
*&      Form  SNAP_ALV
*&---------------------------------------------------------------------*
*       DISPLAYS ABAP/4 ERROR STATISTICS
*----------------------------------------------------------------------*
FORM SNAP_ALV .

  CONSTANTS:  LC_ITABLE  TYPE DD02L-TABNAME VALUE 'GT_SNAP',
              LC_SNAME    TYPE DD02L-TABNAME VALUE 'IBD_SAPMSM2102_ALV'.

  PAGE_TYPE                = 'E'.
  ADD 1 TO GV_LIST_COUNTER.
  GV_H_LIST_COUNTER  =  GV_LIST_COUNTER.
  REFRESH GT_FIELDCAT.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_ITABLE LC_SNAME
                                  CHANGING  GT_FIELDCAT .

  LOOP AT GT_FIELDCAT INTO GS_FIELDCAT.

    GS_FIELDCAT-TECH = GC_X.

    IF GS_FIELDCAT-FIELDNAME = 'MAND'.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'BENU'.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'CNT'.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'ACCU'.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    MODIFY GT_FIELDCAT FROM GS_FIELDCAT.
    CLEAR GS_FIELDCAT.

  ENDLOOP.

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD CHANGING GT_EVENTS[].

* This is the perofrm to set the layout properties
  PERFORM LAYOUT_BUILD CHANGING GS_LAYOUT.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM       = GV_REPID
      I_CALLBACK_PF_STATUS_SET = 'LIST_ALV'
      I_CALLBACK_USER_COMMAND  = 'USER_SYSTEM_LOG'
      I_STRUCTURE_NAME         = LC_SNAME
      IS_LAYOUT                = GS_LAYOUT
      IT_FIELDCAT              = GT_FIELDCAT
      I_SAVE                   = GC_X
      IT_EVENTS                = GT_EVENTS
    TABLES
      T_OUTTAB                 = GT_SNAP
    EXCEPTIONS
      PROGRAM_ERROR            = 1
      OTHERS                   = 2.
  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM.                    " SNAP_ALV

*&---------------------------------------------------------------------*
*&      Form  CONTENTS_ALV
*&---------------------------------------------------------------------*
*     DISPLAYS CONTENTS
*----------------------------------------------------------------------*
FORM CONTENTS_ALV .

  CONSTANTS:  LC_ITABLE  TYPE DD02L-TABNAME VALUE 'GT_CONTENTS',
              LC_SNAME    TYPE DD02L-TABNAME VALUE 'IBD_SAPMSM2103_ALV'.
  DATA: LV_TEXT(40) TYPE C.
  PAGE_TYPE = 'C'.
  ADD 1 TO GV_LIST_COUNTER.
  REFRESH GT_FIELDCAT.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_ITABLE LC_SNAME
                                  CHANGING  GT_FIELDCAT .

  LOOP AT GT_FIELDCAT INTO GS_FIELDCAT.

    IF GS_FIELDCAT-FIELDNAME = 'END_PAGE'.
      GS_FIELDCAT-TECH = GC_X.
      MODIFY GT_FIELDCAT FROM GS_FIELDCAT TRANSPORTING TECH.
    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'HIDE_LINE_TYPE'.
      GS_FIELDCAT-TECH = GC_X.
      MODIFY GT_FIELDCAT FROM GS_FIELDCAT TRANSPORTING TECH.
    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'START_TIME'.
      GS_FIELDCAT-OUTPUTLEN = 21.
      MOVE '_________Start______;;'(051) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_L = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M = LV_TEXT.
      GS_FIELDCAT-SELTEXT_S = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
      MODIFY GT_FIELDCAT FROM GS_FIELDCAT TRANSPORTING SELTEXT_L
                    SELTEXT_M SELTEXT_S REPTEXT_DDIC OUTPUTLEN.
      CLEAR GS_FIELDCAT.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'END_TIME'.
      MOVE '__End___;;'(052) TO LV_TEXT.
      GS_FIELDCAT-OUTPUTLEN = 21.
      GS_FIELDCAT-SELTEXT_L = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M = LV_TEXT.
      GS_FIELDCAT-SELTEXT_S = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
      MODIFY GT_FIELDCAT FROM GS_FIELDCAT TRANSPORTING SELTEXT_L
                      SELTEXT_M SELTEXT_S REPTEXT_DDIC OUTPUTLEN.
      CLEAR GS_FIELDCAT.
    ENDIF.
  ENDLOOP.

*This is the perform which build the event tab
 PERFORM EVENTTAB_BUILD CHANGING GT_EVENTS[].

* This is the perofrm to set the layout properties
  PERFORM LAYOUT_BUILD CHANGING GS_LAYOUT.
  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM       = GV_REPID
      I_CALLBACK_PF_STATUS_SET = 'LIST_ALV'
      I_CALLBACK_USER_COMMAND  = 'USER_SYSTEM_LOG'
      I_STRUCTURE_NAME         = LC_SNAME
      IS_LAYOUT                = GS_LAYOUT
      IT_FIELDCAT              = GT_FIELDCAT
      I_SAVE                   = GC_X
      IT_EVENTS                = GT_EVENTS
    TABLES
      T_OUTTAB                 = GT_CONTENTS
    EXCEPTIONS
      PROGRAM_ERROR            = 1
      OTHERS                   = 2.
  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.


ENDFORM.                    " CONTENTS_ALV

*&---------------------------------------------------------------------*
*&      Form  FIELDCATLOG_BUILD
*&---------------------------------------------------------------------*
*      This is the form for FieldCatalog Building
*----------------------------------------------------------------------*
*      -->IC_ITABLE TYPE DD02L-TABNAME
*      -->IC_SNAME TYPE DD02L-TABNAME
*      <--XT_FIELDCAT TYPE SLIS_T_FIELDCAT_ALV
*----------------------------------------------------------------------*
FORM FIELDCATLOG_BUILD  USING    IC_ITABLE TYPE DD02L-TABNAME
                                 IC_SNAME TYPE DD02L-TABNAME
                        CHANGING XT_FIELDCAT TYPE SLIS_T_FIELDCAT_ALV.

  CALL FUNCTION 'REUSE_ALV_FIELDCATALOG_MERGE'
    EXPORTING
      I_PROGRAM_NAME         = GV_REPID
      I_INTERNAL_TABNAME     = IC_ITABLE
      I_STRUCTURE_NAME       = IC_SNAME
      I_INCLNAME             = GV_REPID
    CHANGING
      CT_FIELDCAT            = XT_FIELDCAT
    EXCEPTIONS
      INCONSISTENT_INTERFACE = 1
      PROGRAM_ERROR          = 2
      OTHERS                 = 3.
  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.


ENDFORM.                    " FIELDCATLOG_BUILD

*&---------------------------------------------------------------------*
*&      Form  EVENTTAB_BUILD
*&---------------------------------------------------------------------*
*       This is the form for Event Handling
*----------------------------------------------------------------------*
*      <--XT_EVENTS TYPE SLIS_T_EVENT.
*----------------------------------------------------------------------*
FORM EVENTTAB_BUILD  CHANGING XT_EVENTS TYPE SLIS_T_EVENT.

  DATA: LS_EVENT TYPE SLIS_ALV_EVENT.
  CLEAR XT_EVENTS.

  CALL FUNCTION 'REUSE_ALV_EVENTS_GET'
    EXPORTING
      I_LIST_TYPE     = 0
    IMPORTING
      ET_EVENTS       = XT_EVENTS
    EXCEPTIONS
      LIST_TYPE_WRONG = 1
      OTHERS          = 2.
  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

*Pass the subroutine name to the END-OF-LIST event when the end of list
*is triggered
 READ TABLE XT_EVENTS INTO LS_EVENT WITH KEY NAME = SLIS_EV_TOP_OF_LIST.

  IF SY-SUBRC = 0.
    MOVE GC_FORMNAME_TOP_OF_PAGE TO LS_EVENT-FORM.
    MODIFY XT_EVENTS FROM LS_EVENT TRANSPORTING FORM
          WHERE NAME = SLIS_EV_TOP_OF_LIST.
  ENDIF.

*Pass the subroutine name to the END-OF-LIST event when the end of list
*is triggered
 READ TABLE XT_EVENTS INTO LS_EVENT WITH KEY NAME = SLIS_EV_TOP_OF_PAGE.

  IF SY-SUBRC = 0.
     MOVE GC_TOP_OF_PAGE TO LS_EVENT-FORM.
     MODIFY XT_EVENTS FROM LS_EVENT TRANSPORTING FORM
            WHERE NAME = SLIS_EV_TOP_OF_PAGE.
  ENDIF.

*Pass the subroutine name to the END-OF-LIST event when the end of list
*is triggered
 READ TABLE XT_EVENTS INTO LS_EVENT WITH KEY NAME = SLIS_EV_END_OF_LIST.

  IF SY-SUBRC = 0.
     MOVE GC_ENDOFLIST TO LS_EVENT-FORM.
     MODIFY XT_EVENTS FROM LS_EVENT TRANSPORTING FORM
          WHERE NAME = SLIS_EV_END_OF_LIST.
  ENDIF.

ENDFORM.                    " EVENTTAB_BUILD

*&---------------------------------------------------------------------*
*&      Form  LAYOUT_BUILD
*&---------------------------------------------------------------------*
*       THIS FORM BUILD THE LAYOUT
*----------------------------------------------------------------------*
*      <--XS_LAYOUT  text
*----------------------------------------------------------------------*
FORM LAYOUT_BUILD  CHANGING XS_LAYOUT TYPE SLIS_LAYOUT_ALV.

  CONSTANTS: LC_Y TYPE C VALUE 'Y',
             LC_X TYPE C VALUE 'X'.
  CLEAR XS_LAYOUT.
  CASE GV_LIST_COUNTER.
    WHEN 1.
      XS_LAYOUT-LIST_APPEND     = LC_Y.
    WHEN OTHERS.
      XS_LAYOUT-LIST_APPEND     = LC_X.
  ENDCASE.
  XS_LAYOUT-colwidth_optimize = 'X'.
  XS_LAYOUT-no_hotspot = 'X'.
ENDFORM.                    " LAYOUT_BUILD


*&---------------------------------------------------------------------*
* To Display the lists consequently
*&---------------------------------------------------------------------*
*&      Form

*&---------------------------------------------------------------------*
FORM END_OF_LIST .                                          "#EC CALLED

  data: lr_grid         type ref to cl_salv_form_layout_grid,
        lr_label        TYPE REF TO cl_salv_form_label,
        lr_content      type ref to cl_salv_form_element,
        lr_abap         type ref to cl_salv_form_abap,
        Lr_text         TYPE REF TO cl_salv_form_text.
  DATA: LV_COUNTER TYPE I.

  CASE GV_LIST_COUNTER.

  WHEN 1.
       HH_INT_USE_OUTLINE = ' '.
       CLEAR INT_USE_OUTLINE.
       CLEAR INT_USE_DATE.
       GV_INDEX = 0.
       LV_H_IND = 2.

       PERFORM GEN_OUTLINE_ALV.

       PERFORM GEN_OUTLINE_STAT_ALV.

       IF NOT GT_CONTENTS IS INITIAL.
          PERFORM CONTENTS_ALV.
       ENDIF.

       PERFORM GEN_OUTLINE_EOF_PART.
       GV_PAGE = 0.
       GV_OUTPUT_TERM = SPACE.
 WHEN 2.
      IF GV_LIST_COUNTER = 2 AND
         GV_OUTPUT_TERM = ' '.
         GV_PAGE = GV_IND.
      ENDIF.
 WHEN 3.
      HH_INT_USE_OUTLINE = ' '.
      REFRESH OLD_INT_USE_OUTLINE.
      REFRESH INT_USE_SIM_TOP.
      LOOP AT INT_USE_OUTLINE.
      APPEND INT_USE_OUTLINE TO OLD_INT_USE_OUTLINE.
      ENDLOOP.
if dy_statistics <> sap_yes.
      REFRESH INT_USE_OUTLINE.
      REFRESH INT_USE_DATE.
      GV_INTERNAL_DATE   = ' '.
      GV_LIST_COUNTER    = 1.
      GV_INTERNAL_NUMBER = 1.
      GV_INDEX           = 0.
      GV_IND             = 0.
      GV_IND2            = 1.
      GV_OUTPUT_TERM     = ' '.
      PAGE_TYPE          = ' '.
 endif.

  WHEN OTHERS.
     IF GV_HIGH_LIST_COUNTER = 999.
        GV_LIST_COUNTER = 1.
        GV_HIGH_LIST_COUNTER = 0.
      ENDIF.

 ENDCASE.

ENDFORM.                    " event_end_of_list

*---------------------------------------------------------------------
*       FORM TOP_OF_PAGE
*---------------------------------------------------------------------
*      For display data in TOP-OF-PAGE
*---------------------------------------------------------------------
FORM TOP_OF_PAGE.                                           "#EC CALLED

  data: lr_grid  type ref to cl_salv_form_layout_grid,
        lr_label       TYPE REF TO cl_salv_form_label,
        lr_content type ref to cl_salv_form_element.
  DATA: LV_COUNTER TYPE I.

*... a grid is created
  create object lr_grid.
GV_IND1 = 0.

IF GV_LIST_COUNTER = 1 AND GV_OUTPUT_TERM  = ' '.
   PERFORM SIM_TOP_OF_PAGE.
   GV_IND2 = 1.
 ENDIF.


IF NOT PAGE_TYPE = 'G'.
  ADD 1 TO GV_PAGE.
  CLEAR HEADER_LINE.
  HEADER_LEN1 = STRLEN( SY-TITLE ) .
  HEADER_LEN2 = 40 - ( HEADER_LEN1 / 2 ) .
  IF HEADER_LEN2 < 0. HEADER_LEN2 = 0. ENDIF.
  WRITE SY-TITLE TO HEADER_LINE+HEADER_LEN2.
  HEADER_LINE+75(5) = GV_PAGE.
  lr_label = lr_grid->create_label(
    row    = 1
    column = 1
    text    = HEADER_LINE ).
ENDIF.

  CASE PAGE_TYPE.
    WHEN 'S'.              " Instanz Statistik
 MOVE  '           i n s t a n c e   s t a t i s t i c s         '(078)
                                                            TO GV_LINE.
      lr_label = lr_grid->create_label(
        row    = 2
        column = 1
        text    = GV_LINE ).
      CLEAR GV_LINE.
    WHEN 'M'.              " Mandant Statistik
  MOVE '           c l i e n t   s t a t i s t i c s             '(069)
                                                           TO GV_LINE.
      lr_label = lr_grid->create_label(
        row    = 2
        column = 1
        text    = GV_LINE ).
      CLEAR GV_LINE.
    WHEN 'T'.              " transaction Statistik
  MOVE '       t r a n s a c t i o n   s t a t i s t i c s       '(068)
                                                            TO GV_LINE.
      lr_label = lr_grid->create_label(
        row    = 2
        column = 1
        text    = GV_LINE ).
      CLEAR GV_LINE.
    WHEN 'R'.              " Report Statistik
  MOVE '             r e p o r t   s t a t i s t i c s           '(095)
                                                            TO GV_LINE.
      lr_label = lr_grid->create_label(
        row    = 2
        column = 1
        text    = GV_LINE ).
      CLEAR GV_LINE.
    WHEN 'B'.              " Benutzer Statistik
  MOVE '             u s e r   s t a t i s t i c s               '(067)
                                                            TO GV_LINE.
      lr_label = lr_grid->create_label(
        row    = 2
        column = 1
        text    = GV_LINE ).
      CLEAR GV_LINE.

    WHEN 'I'.              " Meldungs Statistik
  MOVE '         m e s s a g e   s t a t i s t i c s             '(272)
                                                            TO GV_LINE.
      lr_label = lr_grid->create_label(
        row    = 2
        column = 1
        text    = GV_LINE ).
      CLEAR GV_LINE.

    WHEN 'A' or 'E'.              " ABAP/4-SNAP mini dump Statistik
  MOVE '      A B A P / 4   e r r o r s   s t a t i s t i c s    '(301)
                                                            TO GV_LINE.
      lr_label = lr_grid->create_label(
        row    = 2
        column = 1
        text    = GV_LINE ).
      CLEAR GV_LINE.

    WHEN 'C'.              " table of contents
  MOVE '           t a b l e   o f   c o n t e n t s             '(070)
                                                            TO GV_LINE.
      lr_label = lr_grid->create_label(
        row    = 2
        column = 1
        text    = GV_LINE ).
      CLEAR GV_LINE.
    WHEN ' '.
    WHEN OTHERS.
  ENDCASE.

  lr_content = lr_grid.
  cl_salv_form_content=>set( lr_content ).

ENDFORM.                    "TOP_OF_PAGE

*&---------------------------------------------------------------------*
*&      Form  LIST_ALV
*&---------------------------------------------------------------------*
*       SET THE PF_STATUS
*----------------------------------------------------------------------*
*   -->XT_EXTAB   text
*----------------------------------------------------------------------*
FORM LIST_ALV  CHANGING XT_EXTAB TYPE SLIS_T_EXTAB.

  SET PF-STATUS 'LIST_ALV' EXCLUDING XT_EXTAB.
  DISABLED_FUNCTIONS-FUNC = 'LAYO'.
  APPEND DISABLED_FUNCTIONS.
  DISABLED_FUNCTIONS-FUNC = 'SOFI'.
  APPEND DISABLED_FUNCTIONS.
  DISABLED_FUNCTIONS-FUNC = 'SOTI'.
  APPEND DISABLED_FUNCTIONS.
  DISABLED_FUNCTIONS-FUNC = 'SOPC'.
  APPEND DISABLED_FUNCTIONS.
  DISABLED_FUNCTIONS-FUNC = 'SOCP'.
  APPEND DISABLED_FUNCTIONS.
  DISABLED_FUNCTIONS-FUNC = 'SOTA'.
  APPEND DISABLED_FUNCTIONS.
*  DISABLED_FUNCTIONS-FUNC = 'ENT+'.
*  APPEND DISABLED_FUNCTIONS.
*  DISABLED_FUNCTIONS-FUNC = 'ENT-'.
*  APPEND DISABLED_FUNCTIONS.
  SET PF-STATUS 'LIST_ALV' EXCLUDING DISABLED_FUNCTIONS.

  PERFORM SCROLL_TO_LIST.

ENDFORM.                    " LIST_ALV

*&---------------------------------------------------------------------*
*&      Form  INFO_ALV
*&---------------------------------------------------------------------*
*       SET THE PF_STATUS
*----------------------------------------------------------------------*
*   -->XT_EXTAB   text
*----------------------------------------------------------------------*
FORM INFO_ALV  CHANGING XT_EXTAB TYPE SLIS_T_EXTAB.

  PERFORM SET_TRUE_PF_STATUS.
  SET PF-STATUS 'INFO_ALV' EXCLUDING XT_EXTAB.
  SET PF-STATUS 'INFO_ALV' EXCLUDING DISABLED_FUNCTIONS.

ENDFORM.                    " INFO_ALV

*&---------------------------------------------------------------------*
*&      Form  BACK_ALV
*&---------------------------------------------------------------------*
*       SET THE PF_STATUS
*----------------------------------------------------------------------*
*   -->XT_EXTAB   text
*----------------------------------------------------------------------*
FORM BACK_ALV  CHANGING XT_EXTAB TYPE SLIS_T_EXTAB.

  SET PF-STATUS 'BACK' EXCLUDING XT_EXTAB.

ENDFORM.                    " BACK_ALV

*&---------------------------------------------------------------------*
*&      Form  USER_SYSTEM_LOG
*&---------------------------------------------------------------------*
*     Form which handles user command
*----------------------------------------------------------------------*
*  -->  IV_UCOMM        text
*  -->  IS_SELFIELD     text
*----------------------------------------------------------------------*
FORM USER_SYSTEM_LOG USING IV_UCOMM TYPE SYUCOMM
                           IS_SELFIELD TYPE SLIS_SELFIELD.  "#EC *
 IF IS_SELFIELD-TABNAME  = 'GT_TOP'.
    IS_SELFIELD-TABINDEX = 0.
 ENDIF.

 IF IS_SELFIELD-TABINDEX = 0 AND IV_UCOMM = 'INFO'.
     EXIT.
 ENDIF.

 IF IV_UCOMM = 'QUIT'.
    LEAVE PROGRAM.
 ENDIF.

 IF IV_UCOMM = 'ENT-' OR IV_UCOMM = 'ENT+'.
    IS_SELFIELD-REFRESH = 'X'.
 ENDIF.

 IF IS_SELFIELD-TABNAME = 'GT_GEN_OUTLINE'.
    CLEAR GS_HIDE_BUFFER.
    READ TABLE GT_HIDE_BUFFER INTO GS_HIDE_BUFFER INDEX
                                   IS_SELFIELD-TABINDEX.
    MOVE GS_HIDE_BUFFER-HIDE_LINE_TYPE TO HIDE_LINE_TYPE.
    MOVE-CORRESPONDING GS_HIDE_BUFFER TO HIDE_BUFFER.
    MOVE GS_HIDE_BUFFER-native_s_id TO HIDE_C_BUFFER-NATIVE_S_ID.
    MOVE-CORRESPONDING GS_HIDE_BUFFER TO HIDE_ABAP_INFO.
    MOVE GS_HIDE_BUFFER-HIDE_TEXT TO HIDE_TEXT.
    MOVE GS_HIDE_BUFFER-HIDE_TEXT_LG TO HIDE_TEXT_LG.
    MOVE GS_HIDE_BUFFER-HIDE_PARAMS TO HIDE_PARAMS.
    MOVE GS_HIDE_BUFFER-HIDE_AREA   TO HIDE_AREA.
    MOVE GS_HIDE_BUFFER-HIDE_SUBID  TO HIDE_SUBID.

    READ TABLE GT_GEN_OUTLINE INTO GS_GEN_OUTLINE INDEX
                                   IS_SELFIELD-TABINDEX.
    MOVE IS_SELFIELD-TABINDEX TO GV_TABINDEX.
    REFRESH GT_GEN_OUTLINE1.
    MOVE-CORRESPONDING GS_GEN_OUTLINE TO GS_GEN_OUTLINE1.
    APPEND GS_GEN_OUTLINE1 TO GT_GEN_OUTLINE1.

  ELSEIF IS_SELFIELD-TABNAME = 'GT_INST'.
    REFRESH GT_COMMON.
    MOVE IS_SELFIELD-TABINDEX TO GV_TABINDEX.
    READ TABLE GT_INST INTO GS_INST INDEX IS_SELFIELD-TABINDEX.
    HIDE_LINE_TYPE = GS_INST-HIDE_LINE_TYPE.
    MOVE-CORRESPONDING GS_INST TO GS_COMMON.
    MOVE GS_COMMON-HIDE_LINE_TYPE TO HIDE_LINE_TYPE.
    APPEND GS_COMMON TO GT_COMMON.

  ELSEIF IS_SELFIELD-TABNAME = 'GT_MAND'.
    REFRESH GT_COMMON.
    MOVE IS_SELFIELD-TABINDEX TO GV_TABINDEX.
    READ TABLE GT_MAND INTO GS_MAND INDEX IS_SELFIELD-TABINDEX.
    HIDE_LINE_TYPE = GS_MAND-HIDE_LINE_TYPE.
    MOVE-CORRESPONDING GS_MAND TO GS_COMMON.
    MOVE GS_COMMON-HIDE_LINE_TYPE TO HIDE_LINE_TYPE.
    APPEND GS_COMMON TO GT_COMMON.

  ELSEIF IS_SELFIELD-TABNAME = 'GT_TCOD'.
    REFRESH GT_COMMON.
    MOVE IS_SELFIELD-TABINDEX TO GV_TABINDEX.
    READ TABLE GT_TCOD INTO GS_TCOD INDEX IS_SELFIELD-TABINDEX.
    HIDE_LINE_TYPE = GS_TCOD-HIDE_LINE_TYPE.
    MOVE-CORRESPONDING GS_TCOD TO GS_COMMON.
    MOVE GS_COMMON-HIDE_LINE_TYPE TO HIDE_LINE_TYPE.
    APPEND GS_COMMON TO GT_COMMON.

  ELSEIF IS_SELFIELD-TABNAME = 'GT_REPO'.
    REFRESH GT_COMMON.
    MOVE IS_SELFIELD-TABINDEX TO GV_TABINDEX.
    READ TABLE GT_REPO INTO GS_REPO INDEX IS_SELFIELD-TABINDEX.
    HIDE_LINE_TYPE = GS_REPO-HIDE_LINE_TYPE.
    MOVE-CORRESPONDING GS_REPO TO GS_COMMON.
    MOVE GS_COMMON-HIDE_LINE_TYPE TO HIDE_LINE_TYPE.
    APPEND GS_COMMON TO GT_COMMON.

  ELSEIF IS_SELFIELD-TABNAME = 'GT_BENU'.
    REFRESH GT_COMMON.
    MOVE IS_SELFIELD-TABINDEX TO GV_TABINDEX.
    READ TABLE GT_BENU INTO GS_BENU INDEX IS_SELFIELD-TABINDEX.
    HIDE_LINE_TYPE = GS_BENU-HIDE_LINE_TYPE.
    MOVE-CORRESPONDING GS_BENU TO GS_COMMON.
    MOVE GS_COMMON-HIDE_LINE_TYPE TO HIDE_LINE_TYPE.
    APPEND GS_COMMON TO GT_COMMON.

  ELSEIF IS_SELFIELD-TABNAME = 'GT_MSG'.
    REFRESH GT_COMMON.
    MOVE IS_SELFIELD-TABINDEX TO GV_TABINDEX.
    READ TABLE GT_MSG INTO GS_MSG INDEX IS_SELFIELD-TABINDEX.
    HIDE_LINE_TYPE = GS_MSG-HIDE_LINE_TYPE.
    MOVE-CORRESPONDING GS_MSG TO GS_COMMON.
    MOVE GS_COMMON-HIDE_LINE_TYPE TO HIDE_LINE_TYPE.
    APPEND GS_COMMON TO GT_COMMON.

  ELSEIF IS_SELFIELD-TABNAME = 'GT_SNAP'.
    REFRESH GT_COMMON.
    MOVE IS_SELFIELD-TABINDEX TO GV_TABINDEX.
    READ TABLE GT_SNAP INTO GS_SNAP INDEX IS_SELFIELD-TABINDEX.
    HIDE_LINE_TYPE = GS_SNAP-HIDE_LINE_TYPE.
    MOVE-CORRESPONDING GS_SNAP TO GS_COMMON.
    MOVE GS_COMMON-HIDE_LINE_TYPE TO HIDE_LINE_TYPE.
    APPEND GS_COMMON TO GT_COMMON.

  ELSEIF IS_SELFIELD-TABNAME = 'GT_CONTENTS'.
    MOVE IS_SELFIELD-TABINDEX TO GV_TABINDEX.
    READ TABLE GT_CONTENTS INTO GS_CONTENTS INDEX IS_SELFIELD-TABINDEX.
    HIDE_LINE_TYPE = GS_CONTENTS-HIDE_LINE_TYPE.
    REFRESH GT_CONTENTS1.
    APPEND GS_CONTENTS TO GT_CONTENTS1.
    CLEAR GS_CONTENTS.
   ENDIF.

  PERFORM DO_USER_INPUT_EARLY_ALV USING IV_UCOMM.
  PERFORM DO_USER_INPUT_LATE_ALV  USING IV_UCOMM.

ENDFORM.                    " USER_SYSTEM_LOG

*&---------------------------------------------------------------------
*&      Form  create_alv_form_content_tol
*&---------------------------------------------------------------------
*      This displays Top Of List
*----------------------------------------------------------------------
*      <--CR_CONTENT  text
*      <--IT_TOP      text
*----------------------------------------------------------------------

FORM create_alv_form_content_tol USING IT_TOP TYPE TABLE
      changing cr_content type ref to cl_salv_form_element.

  data: lr_grid   type ref to cl_salv_form_layout_grid,
        lr_label       TYPE REF TO cl_salv_form_label.
  DATA: LS_TOP TYPE KERNELSTAT.

  DATA: LV_COUNTER TYPE I.

*... create a grid
  create object lr_grid.

  LOOP AT IT_TOP INTO LS_TOP.
    ADD 1 TO LV_COUNTER.

    lr_label = lr_grid->create_label(
    row    = LV_COUNTER
    column = 1
    text    = LS_TOP-LINE ).

  ENDLOOP.

*... content is the top grid
  cr_content = lr_grid.

ENDFORM.                    " create_alv_form_content_tol

*&---------------------------------------------------------------------*
*&      Form  EXPLAIN_PERMISSIONS_ALV
*&---------------------------------------------------------------------*
FORM EXPLAIN_PERMISSIONS_ALV.

  data:lr_columns_header type ref to cl_salv_columns_table.

* creating an ALV table - grid display
  try.
      cl_salv_table=>factory(
        importing
          r_salv_table = gr_PERMISSIONS
        changing
          t_table      = GT_AUTH ).
    catch cx_salv_msg.  "#EC NO_HANDLER
  endtry.

*  GR_PERMISSIONS->SET_SCREEN_STATUS(
*       PFSTATUS      =  'BACK'
*       REPORT        =  GV_REPID
* SET_FUNCTIONS = gr_PERMISSIONS->C_FUNCTIONS_ALL ).

* set the top of list content
  perform create_alv_form_content_tol USING GT_AUTH_TOP
                                    changing gr_content.
  gr_PERMISSIONS->set_top_of_list( gr_content ).
*
* setting default ALV generic funtions
  gr_functions = gr_PERMISSIONS->get_functions( ).
  gr_functions->set_default( ).

  lr_columns_header = gr_PERMISSIONS->get_columns( ).
  lr_columns_header->SET_HEADERS_VISIBLE( SPACE ).
  lr_columns_header->set_optimize( abap_true ).

  GR_PERMISSIONS->DISPLAY( ).

ENDFORM.                    " EXPLAIN_PERMISSIONS_ALV

*&---------------------------------------------------------------------*
*&      Form  SHOW_CLOCKS_ALV
*&---------------------------------------------------------------------*
FORM SHOW_CLOCKS_ALV .

  data:lr_columns_header type ref to cl_salv_columns_table.

* creating an ALV table - grid display
  try.
      cl_salv_table=>factory(
        importing
          r_salv_table = gr_CLOCK
        changing
          t_table      = GT_CLOCK ).
    catch cx_salv_msg.  "#EC NO_HANDLER
  endtry.

*  GR_CLOCK->SET_SCREEN_STATUS(
*       PFSTATUS      =  'BACK'
*       REPORT        =  GV_REPID
* SET_FUNCTIONS = gr_CLOCK->C_FUNCTIONS_ALL ).

  gr_CLOCK->set_top_of_list( gr_content ).

* setting default ALV generic funtions
  gr_functions = gr_CLOCK->get_functions( ).
  gr_functions->set_default( ).

  lr_columns_header = gr_CLOCK->get_columns( ).
  lr_columns_header->SET_HEADERS_VISIBLE( SPACE ).
  lr_columns_header->set_optimize( abap_true ).

  GR_CLOCK->DISPLAY( ).

ENDFORM.                    " SHOW_CLOCKS_ALV

*&---------------------------------------------------------------------*
*&      Form  SHOW_DETAILS_ALV
*&---------------------------------------------------------------------*
*     THIS SUBROUTINE DISPLAYS SECOND ALV LIST
*----------------------------------------------------------------------*
FORM SHOW_DETAILS_ALV USING A_KEY.

  CONSTANTS:  LC_ITABLE  TYPE DD02L-TABNAME VALUE 'GT_GEN_OUTLINE1',
              LC_SNAME    TYPE DD02L-TABNAME VALUE 'IBD_SAPMSM2101_ALV'.
  DATA: LV_DATE TYPE D,
        LV_DATE1(10) TYPE C,
        LV_TEXT(40) TYPE C.

  CLEAR GV_LIST_COUNTER1.
  ADD 1 TO GV_LIST_COUNTER1.
  REFRESH GT_FIELDCAT.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_ITABLE LC_SNAME
                                  CHANGING  GT_FIELDCAT .

  LOOP AT GT_FIELDCAT INTO GS_FIELDCAT.

    GS_FIELDCAT-TECH = 'X'.

    IF LAYOUT-W_COL_POSI = SAP_YES.
      IF GS_FIELDCAT-FIELDNAME = 'FILE_NO'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      IF GS_FIELDCAT-FIELDNAME = 'POS'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

    ENDIF.
    IF LAYOUT-W_COL_DATE = SAP_YES.
      IF GS_FIELDCAT-FIELDNAME = 'DATE'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.
    ENDIF.

    IF LAYOUT-W_COL_INST = SAP_YES.

      IF GS_FIELDCAT-FIELDNAME = 'INSTID'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'TIME'.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    IF LAYOUT-W_COL_TASK = SAP_YES.

      IF GS_FIELDCAT-FIELDNAME = 'TSKNA'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      IF GS_FIELDCAT-FIELDNAME = 'TSKNU'.
        GS_FIELDCAT-TECH = SPACE.
        GS_FIELDCAT-SELTEXT_S    = text-999.
        GS_FIELDCAT-SELTEXT_M    = text-999.
        GS_FIELDCAT-SELTEXT_L    = text-999.
        GS_FIELDCAT-REPTEXT_DDIC = text-999.
      ENDIF.

    ENDIF.

    IF LAYOUT-W_COL_MAND = SAP_YES.

      IF GS_FIELDCAT-FIELDNAME = 'MAND'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

    ENDIF.

    IF LAYOUT-W_COL_USER = SAP_YES.

      IF GS_FIELDCAT-FIELDNAME = 'USER'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

    ENDIF.

    IF LAYOUT-W_COL_TRAN = SAP_YES.

      IF GS_FIELDCAT-FIELDNAME = 'TRANSCODE'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

    ENDIF.

    IF LAYOUT-W_COL_PROG = SAP_YES.

      IF GS_FIELDCAT-FIELDNAME = 'REPNA'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

    ENDIF.

    IF LAYOUT-W_COL_TERM = SAP_YES.

      IF GS_FIELDCAT-FIELDNAME = 'TERMINAL'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

    ENDIF.

    IF LAYOUT-W_COL_DEVC = SAP_YES.

      IF GS_FIELDCAT-FIELDNAME = 'DEVCLASS'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

    ENDIF.

    IF LAYOUT-W_COL_TABE = SAP_YES.

      IF GS_FIELDCAT-FIELDNAME = 'AREA'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      IF GS_FIELDCAT-FIELDNAME = 'SUBID'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

    ENDIF.

    IF LAYOUT-W_COL_BEW = SAP_YES.

      IF GS_FIELDCAT-FIELDNAME = 'BEWERTUNG'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'TEXT'.
      GS_FIELDCAT-SELTEXT_S    = TEXT-105.
      GS_FIELDCAT-SELTEXT_M    = TEXT-105.
      GS_FIELDCAT-SELTEXT_L    = TEXT-105.
      GS_FIELDCAT-REPTEXT_DDIC = TEXT-105.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    MODIFY GT_FIELDCAT FROM GS_FIELDCAT.

  ENDLOOP.

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD1 CHANGING GT_EVENTS[].

  GS_LAYOUT-colwidth_optimize = GC_X.
  GS_LAYOUT-LIST_APPEND     = 'Y'.
*  GS_LAYOUT-MIN_LINESIZE    = 200.
*  GS_LAYOUT-MAX_LINESIZE    = 700.
   GS_LAYOUT-MIN_LINESIZE    = GV_DEFAULT_LINESIZE.
   GS_LAYOUT-MAX_LINESIZE    = GV_DEFAULT_LINESIZE.

* Do not call function again by next or previous detail
* selfield-refresh is set to X
  IF A_KEY <> 'F2'.
     EXIT.
  ENDIF.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM       = GV_REPID
      I_CALLBACK_PF_STATUS_SET = 'INFO_ALV'
      I_CALLBACK_USER_COMMAND  = 'USER_SYSTEM_LOG'
      I_STRUCTURE_NAME         = LC_SNAME
      IS_LAYOUT                = GS_LAYOUT
      IT_FIELDCAT              = GT_FIELDCAT[]
      I_SAVE                   = GC_X
      IT_EVENTS                = GT_EVENTS
    TABLES
      T_OUTTAB                 = GT_GEN_OUTLINE1
    EXCEPTIONS
      PROGRAM_ERROR            = 1
      OTHERS                   = 2.
  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM.                    " SHOW_DETAILS_ALV

*&---------------------------------------------------------------------*
* To Display the lists consequently
*&---------------------------------------------------------------------*
*&      Form  end_of_list1
*&---------------------------------------------------------------------*
FORM END_OF_LIST1 .                                         "#EC CALLED

  data: lr_grid  type ref to cl_salv_form_layout_grid,
        lr_label       TYPE REF TO cl_salv_form_label,
        lr_content type ref to cl_salv_form_element.
  DATA: LV_COUNTER TYPE I.

*... a grid is created
  create object lr_grid.

  CASE GV_LIST_COUNTER1.
    WHEN '1'.
      PERFORM DETAILS_ALV.
    WHEN '2'.
      ADD 1 TO GV_LIST_COUNTER1.
      REFRESH GT_FIELDCAT1.
      CASE GV_SLGFTYP.
        WHEN RSLGTYother. " no one of the other ones
          PERFORM END_OF_LIST1.
        WHEN RSLGTYcf.  PERFORM SHOW_CF_DETAILS_ALV.
        WHEN RSLGTYup.  PERFORM SHOW_UP_DETAILS_ALV.
        WHEN RSLGTYdo.  PERFORM SHOW_DO_DETAILS_ALV.
        WHEN RSLGTYpr.  PERFORM SHOW_PR_DETAILS_ALV.
        WHEN RSLGTYep.  PERFORM SHOW_EP_DETAILS_ALV.
        WHEN RSLGTYel.  PERFORM SHOW_EL_DETAILS_ALV.
        WHEN RSLGTYed.  PERFORM SHOW_ED_DETAILS_ALV.
        WHEN RSLGTYer.  PERFORM SHOW_ER_DETAILS_ALV.
        WHEN RSLGTYex.  PERFORM SHOW_EX_DETAILS_ALV.
        WHEN RSLGTYsql. PERFORM SHOW_SQL_DETAILS_ALV.
        WHEN RSLGTYdbi. PERFORM SHOW_DBI_DETAILS_ALV.
        WHEN RSLGTYdd.  PERFORM SHOW_DD_DETAILS_ALV.
        WHEN RSLGTYab.  PERFORM SHOW_AB_DETAILS_ALV.
        WHEN RSLGTYax.  PERFORM SHOW_AX_DETAILS_ALV.
        WHEN RSLGTYad.  PERFORM SHOW_AD_DETAILS_ALV.
        WHEN RSLGTYib.  PERFORM SHOW_IB_DETAILS_ALV.
        WHEN RSLGTYpa.  PERFORM SHOW_PA_DETAILS_ALV.
      ENDCASE.
    WHEN '3'.
      IF NOT GT_D_END IS INITIAL.
        LV_COUNTER = 1.
        LOOP AT GT_D_END INTO GS_D_END.
          ADD 1 TO LV_COUNTER.
          lr_label = lr_grid->create_label(
            row    = LV_COUNTER
            column = 1
            text    = GS_D_END-LINE ).
        ENDLOOP.
        lr_content = lr_grid.
        cl_salv_form_content=>set( lr_content ).
      ENDIF.
      PERFORM DOC_ALV.
    WHEN '4'.
      IF GT_PARAM IS INITIAL.
        ADD 1 TO GV_LIST_COUNTER1.
        PERFORM END_OF_LIST1.
      ELSE.
        PERFORM PARAM_ALV.
      ENDIF.
    WHEN '5'.
      PERFORM TECHNICAL_ALV.
  ENDCASE.

ENDFORM.                      " END_OF_LIST1

*&---------------------------------------------------------------------*
*&      Form  DETAILS_ALV
*&---------------------------------------------------------------------*
FORM DETAILS_ALV .

  CONSTANTS:  LC_ITABLE  TYPE DD02L-TABNAME VALUE 'GT_DETAILS',
              LC_SNAME   TYPE DD02L-TABNAME VALUE 'IBD_SAPMSM2104_ALV'.

  DATA: LV_TEXT(40) TYPE C.
  ADD 1 TO GV_LIST_COUNTER1.
  REFRESH GT_FIELDCAT.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_ITABLE LC_SNAME
                                  CHANGING  GT_FIELDCAT .

  LOOP AT GT_FIELDCAT INTO GS_FIELDCAT.

    IF GS_FIELDCAT-FIELDNAME = 'TASK'.
      MOVE 'task................'(020) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_L = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M = LV_TEXT.
      GS_FIELDCAT-SELTEXT_S = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'USER'.
      MOVE 'user................'(025) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_L = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M = LV_TEXT.
      GS_FIELDCAT-SELTEXT_S = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'MODE'.
      MOVE 'mode..'(024) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_L = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M = LV_TEXT.
      GS_FIELDCAT-SELTEXT_S = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'CNAME'.
      MOVE 'Problemklasse.......'(151) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_L = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M = LV_TEXT.
      GS_FIELDCAT-SELTEXT_S = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
    ENDIF.

    MODIFY GT_FIELDCAT FROM GS_FIELDCAT TRANSPORTING SELTEXT_L
                           SELTEXT_M SELTEXT_S REPTEXT_DDIC.

  ENDLOOP.

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD1 CHANGING GT_EVENTS[].

  GS_LAYOUT-colwidth_optimize = GC_X.
  GS_LAYOUT-LIST_APPEND     = 'X'.
*  GS_LAYOUT-MIN_LINESIZE    = 200.
*  GS_LAYOUT-MAX_LINESIZE    = 700.
  GS_LAYOUT-MIN_LINESIZE    = GV_DEFAULT_LINESIZE.
  GS_LAYOUT-MAX_LINESIZE    = GV_DEFAULT_LINESIZE.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM       = GV_REPID
      I_CALLBACK_PF_STATUS_SET = 'INFO_ALV'
      I_CALLBACK_USER_COMMAND  = 'USER_SYSTEM_LOG'
      I_STRUCTURE_NAME         = LC_SNAME
      IS_LAYOUT                = GS_LAYOUT
      IT_FIELDCAT              = GT_FIELDCAT[]
      I_SAVE                   = GC_X
      IT_EVENTS                = GT_EVENTS
    TABLES
      T_OUTTAB                 = GT_DETAILS
    EXCEPTIONS
      PROGRAM_ERROR            = 1
      OTHERS                   = 2.
  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM.                    " DETAILS_ALV

*&---------------------------------------------------------------------*
*&      Form  DOC_ALV
*&---------------------------------------------------------------------*
FORM DOC_ALV .

  CONSTANTS:  LC_ITABLE  TYPE DD02L-TABNAME VALUE 'GT_DOC',
              LC_SNAME    TYPE DD02L-TABNAME VALUE 'KERNELSTAT'.

  ADD 1 TO GV_LIST_COUNTER1.
  REFRESH GT_FIELDCAT.
*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_ITABLE LC_SNAME
                                  CHANGING  GT_FIELDCAT .

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD1 CHANGING GT_EVENTS[].

  GS_LAYOUT-colwidth_optimize = GC_X.
  GS_LAYOUT-LIST_APPEND     = 'X'.
  GS_LAYOUT-NO_COLHEAD      = GC_X.
  GS_LAYOUT-coltab_fieldname = 'COLOR'.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM       = GV_REPID
      I_CALLBACK_PF_STATUS_SET = 'INFO_ALV'
      I_CALLBACK_USER_COMMAND  = 'USER_SYSTEM_LOG'
      I_STRUCTURE_NAME         = LC_SNAME
      IS_LAYOUT                = GS_LAYOUT
      IT_FIELDCAT              = GT_FIELDCAT[]
      I_SAVE                   = GC_X
      IT_EVENTS                = GT_EVENTS
    TABLES
      T_OUTTAB                 = GT_DOC
    EXCEPTIONS
      PROGRAM_ERROR            = 1
      OTHERS                   = 2.
  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM.                    " DOC_ALV

*&---------------------------------------------------------------------*
*&      Form  PARAM_ALV
*&---------------------------------------------------------------------*
FORM PARAM_ALV .

  CONSTANTS:  LC_ITABLE  TYPE DD02L-TABNAME VALUE 'GT_PARAM',
              LC_SNAME    TYPE DD02L-TABNAME VALUE 'KERNELSTAT'.

  ADD 1 TO GV_LIST_COUNTER1.
  REFRESH GT_FIELDCAT.
*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_ITABLE LC_SNAME
                                  CHANGING  GT_FIELDCAT .

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD1 CHANGING GT_EVENTS[].

  CLEAR GS_LAYOUT.
  GS_LAYOUT-colwidth_optimize = GC_X.
  GS_LAYOUT-LIST_APPEND     = GC_X.
  GS_LAYOUT-NO_COLHEAD      = GC_X.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM       = GV_REPID
      I_CALLBACK_PF_STATUS_SET = 'INFO_ALV'
      I_CALLBACK_USER_COMMAND  = 'USER_SYSTEM_LOG'
      I_STRUCTURE_NAME         = LC_SNAME
      IS_LAYOUT                = GS_LAYOUT
      IT_FIELDCAT              = GT_FIELDCAT[]
      I_SAVE                   = GC_X
      IT_EVENTS                = GT_EVENTS
    TABLES
      T_OUTTAB                 = GT_PARAM
    EXCEPTIONS
      PROGRAM_ERROR            = 1
      OTHERS                   = 2.
  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM.                    " PARAM_ALV

*&---------------------------------------------------------------------*
*&      Form  TECHNICAL_ALV
*&---------------------------------------------------------------------*
FORM TECHNICAL_ALV .

  CONSTANTS:  LC_ITABLE  TYPE DD02L-TABNAME VALUE 'GT_TECHNICAL',
              LC_SNAME    TYPE DD02L-TABNAME VALUE 'IBD_SAPMSM2105_ALV'.

  ADD 1 TO GV_LIST_COUNTER1.
  REFRESH GT_FIELDCAT.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_ITABLE LC_SNAME
                                  CHANGING  GT_FIELDCAT .
  LOOP AT GT_FIELDCAT INTO GS_FIELDCAT.

    IF GS_FIELDCAT-FIELDNAME = 'SLGFTYP'.
       GS_FIELDCAT-SELTEXT_S = 'RecFm'.
       GS_FIELDCAT-SELTEXT_M = 'RecFm'.
       GS_FIELDCAT-SELTEXT_L = 'RecFm'.
       GS_FIELDCAT-REPTEXT_DDIC = 'RecFm'.
       MODIFY GT_FIELDCAT FROM GS_FIELDCAT.
    ENDIF.

  ENDLOOP.

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD1 CHANGING GT_EVENTS[].

  CLEAR GS_LAYOUT.
  GS_LAYOUT-colwidth_optimize = GC_X.
  GS_LAYOUT-LIST_APPEND     = GC_X.
  GS_LAYOUT-NO_COLHEAD      = SPACE.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM       = GV_REPID
      I_CALLBACK_PF_STATUS_SET = 'INFO_ALV'
      I_CALLBACK_USER_COMMAND  = 'USER_SYSTEM_LOG'
      I_STRUCTURE_NAME         = LC_SNAME
      IS_LAYOUT                = GS_LAYOUT
      IT_FIELDCAT              = GT_FIELDCAT[]
      I_SAVE                   = GC_X
      IT_EVENTS                = GT_EVENTS
    TABLES
      T_OUTTAB                 = GT_TECHNICAL
    EXCEPTIONS
      PROGRAM_ERROR            = 1
      OTHERS                   = 2.
  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM.                    " TECHNICAL_ALV

*&---------------------------------------------------------------------*
*&      Form  EVENTTAB_BUILD
*&---------------------------------------------------------------------*
*       This is the form for Event Handling
*----------------------------------------------------------------------*
*      <--XT_EVENTS TYPE SLIS_T_EVENT.
*----------------------------------------------------------------------*
FORM EVENTTAB_BUILD1  CHANGING XT_EVENTS TYPE SLIS_T_EVENT.

  DATA: LS_EVENT TYPE SLIS_ALV_EVENT.
  CLEAR XT_EVENTS.

  CALL FUNCTION 'REUSE_ALV_EVENTS_GET'
    EXPORTING
      I_LIST_TYPE     = 0
    IMPORTING
      ET_EVENTS       = XT_EVENTS
    EXCEPTIONS
      LIST_TYPE_WRONG = 1
      OTHERS          = 2.
  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

*Pass the subroutine name to the END-OF-LIST event when the end of list
*is triggered
 READ TABLE XT_EVENTS INTO LS_EVENT WITH KEY NAME = SLIS_EV_END_OF_LIST.

  IF SY-SUBRC = 0.
    MOVE 'END_OF_LIST1' TO LS_EVENT-FORM.
    MODIFY XT_EVENTS FROM LS_EVENT TRANSPORTING FORM
          WHERE NAME = SLIS_EV_END_OF_LIST.
  ENDIF.

*Pass the subroutine name to the TOP-OF-PAGE event when the end of list
*is triggered
 READ TABLE XT_EVENTS INTO LS_EVENT WITH KEY NAME = SLIS_EV_TOP_OF_PAGE.

  IF SY-SUBRC = 0.
    MOVE 'TOP_OF_PAGE1' TO LS_EVENT-FORM.
    MODIFY XT_EVENTS FROM LS_EVENT TRANSPORTING FORM
          WHERE NAME = SLIS_EV_TOP_OF_PAGE.
  ENDIF.

ENDFORM.                    " EVENTTAB_BUILD1

*&---------------------------------------------------------------------*
* To Display the lists consequently
*&---------------------------------------------------------------------*
*&      Form  top_of_page1
*&---------------------------------------------------------------------*
FORM TOP_OF_PAGE1 .                                         "#EC CALLED

  data: lr_grid  type ref to cl_salv_form_layout_grid,
        lr_label       TYPE REF TO cl_salv_form_label,
        lr_content type ref to cl_salv_form_element.
  DATA: LV_COUNTER TYPE I.

*... a grid is created
  create object lr_grid.

  CASE GV_LIST_COUNTER1.
    WHEN '1'.
      CLEAR HEADER_LINE.
      MOVE 'Details'(118) TO HEADER_LINE(49).
      MOVE 'page'(119)    TO HEADER_LINE+50(29).
      WRITE SY-CPAGE      TO HEADER_LINE+80(9).
      WRITE 'line'(120)   TO HEADER_LINE+90(9).
      WRITE SY-CUROW      TO HEADER_LINE+100(9).
      CONDENSE               HEADER_LINE.
      HEADER_LEN1 = STRLEN( HEADER_LINE ) + 1 .
      HEADER_LEN2 = ( 79 - STRLEN( SY-TITLE ) ) / 2 .

      IF HEADER_LEN1 LE HEADER_LEN2.
        WRITE SY-TITLE TO HEADER_LINE+HEADER_LEN2.
      ELSE.
        WRITE SY-TITLE TO HEADER_LINE+HEADER_LEN1.
      ENDIF.
      MOVE SY-PAGNO TO HEADER_LINE+75(5).
      lr_label = lr_grid->create_label(
        row    = 1
        column = 1
        text    = HEADER_LINE ).

    WHEN '2'.

      LV_COUNTER = 1.
      LOOP AT GT_DETAIL_TOP INTO GS_DETAIL_TOP.
        ADD 1 TO LV_COUNTER.
        lr_label = lr_grid->create_label(
          row    = LV_COUNTER
          column = 1
          text    = GS_DETAIL_TOP-LINE ).
      ENDLOOP.

    WHEN '3'.
      LV_COUNTER = 1.
      LOOP AT GT_D_TOP INTO GS_D_TOP.
        ADD 1 TO LV_COUNTER.
        lr_label = lr_grid->create_label(
          row    = LV_COUNTER
          column = 1
          text    = GS_D_TOP-LINE ).
      ENDLOOP.
      IF ENTRIESTAB-slgftyp = RSLGTYpa.
        lr_content = lr_grid.
        cl_salv_form_content=>set( lr_content ).
        PERFORM END_OF_LIST1.
      ENDIF.
    WHEN '5'.
      LV_COUNTER = 1.
      LOOP AT GT_PARAM_TOP INTO GS_PARAM_TOP.
        ADD 1 TO LV_COUNTER.
        lr_label = lr_grid->create_label(
          row    = LV_COUNTER
          column = 1
          text    = GS_PARAM_TOP-LINE ).
      ENDLOOP.
    WHEN '6'.
      LV_COUNTER = 1.
      LOOP AT GT_TECH_TOP INTO GS_TECH_TOP.
        ADD 1 TO LV_COUNTER.
        lr_label = lr_grid->create_label(
          row    = LV_COUNTER
          column = 1
          text    = GS_TECH_TOP-LINE ).
      ENDLOOP.

  ENDCASE.

  lr_content = lr_grid.
  cl_salv_form_content=>set( lr_content ).

ENDFORM.                    "TOP_OF_PAGE1

*&---------------------------------------------------------------------*
*&      Form  COMMON_DISPLAY
*&---------------------------------------------------------------------*
FORM COMMON_DISPLAY .

  CONSTANTS:  LC_ITABLE  TYPE DD02L-TABNAME VALUE 'GT_COMMON',
              LC_SNAME    TYPE DD02L-TABNAME VALUE 'IBD_SAPMSM2102_ALV'.

  DATA: LS_EVENT TYPE SLIS_ALV_EVENT.

  REFRESH GT_FIELDCAT.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_ITABLE LC_SNAME
                                  CHANGING  GT_FIELDCAT .
  IF HIDE_LINE_TYPE = 'S'.

    LOOP AT GT_FIELDCAT INTO GS_FIELDCAT.

      GS_FIELDCAT-TECH = GC_X.

      IF GS_FIELDCAT-FIELDNAME = 'INST'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      IF GS_FIELDCAT-FIELDNAME = 'CNT'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      IF GS_FIELDCAT-FIELDNAME = 'ACCU'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      MODIFY GT_FIELDCAT FROM GS_FIELDCAT.
      CLEAR GS_FIELDCAT.

    ENDLOOP.

  ELSEIF HIDE_LINE_TYPE = 'M'.

    LOOP AT GT_FIELDCAT INTO GS_FIELDCAT.

      GS_FIELDCAT-TECH = GC_X.

      IF GS_FIELDCAT-FIELDNAME = 'MAND'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      IF GS_FIELDCAT-FIELDNAME = 'CNT'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      IF GS_FIELDCAT-FIELDNAME = 'ACCU'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      MODIFY GT_FIELDCAT FROM GS_FIELDCAT.
      CLEAR GS_FIELDCAT.

    ENDLOOP.

  ELSEIF HIDE_LINE_TYPE = 'T'.

    LOOP AT GT_FIELDCAT INTO GS_FIELDCAT.

      GS_FIELDCAT-TECH = GC_X.

      IF GS_FIELDCAT-FIELDNAME = 'TCOD'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      IF GS_FIELDCAT-FIELDNAME = 'CNT'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      IF GS_FIELDCAT-FIELDNAME = 'ACCU'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      MODIFY GT_FIELDCAT FROM GS_FIELDCAT.
      CLEAR GS_FIELDCAT.

    ENDLOOP.

  ELSEIF HIDE_LINE_TYPE = 'R'.

    LOOP AT GT_FIELDCAT INTO GS_FIELDCAT.

      GS_FIELDCAT-TECH = GC_X.

      IF GS_FIELDCAT-FIELDNAME = 'REPO'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      IF GS_FIELDCAT-FIELDNAME = 'CNT'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      IF GS_FIELDCAT-FIELDNAME = 'ACCU'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      MODIFY GT_FIELDCAT FROM GS_FIELDCAT.
      CLEAR GS_FIELDCAT.

    ENDLOOP.

  ELSEIF HIDE_LINE_TYPE = 'B'.

    LOOP AT GT_FIELDCAT INTO GS_FIELDCAT.

      GS_FIELDCAT-TECH = GC_X.

      IF GS_FIELDCAT-FIELDNAME = 'BENU'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      IF GS_FIELDCAT-FIELDNAME = 'CNT'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      IF GS_FIELDCAT-FIELDNAME = 'ACCU'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      MODIFY GT_FIELDCAT FROM GS_FIELDCAT.
      CLEAR GS_FIELDCAT.

    ENDLOOP.

  ELSEIF HIDE_LINE_TYPE = 'I'.

    LOOP AT GT_FIELDCAT INTO GS_FIELDCAT.

      GS_FIELDCAT-TECH = GC_X.

      IF GS_FIELDCAT-FIELDNAME = 'AREA'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      IF GS_FIELDCAT-FIELDNAME = 'COUNTER'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      IF GS_FIELDCAT-FIELDNAME = 'TXT'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      IF GS_FIELDCAT-FIELDNAME = 'ACCU'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      MODIFY GT_FIELDCAT FROM GS_FIELDCAT.
      CLEAR GS_FIELDCAT.

    ENDLOOP.

  ELSEIF HIDE_LINE_TYPE = 'E'.

    LOOP AT GT_FIELDCAT INTO GS_FIELDCAT.

      GS_FIELDCAT-TECH = GC_X.

      IF GS_FIELDCAT-FIELDNAME = 'MAND'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      IF GS_FIELDCAT-FIELDNAME = 'BENU'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      IF GS_FIELDCAT-FIELDNAME = 'CNT'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      IF GS_FIELDCAT-FIELDNAME = 'ACCU'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      MODIFY GT_FIELDCAT FROM GS_FIELDCAT.
      CLEAR GS_FIELDCAT.

    ENDLOOP.

  ENDIF.

  REFRESH GT_EVENTS.
  PERFORM EVENTTAB_BUILD CHANGING GT_EVENTS[].

*Pass the subroutine name to the END-OF-LIST event when the end of list
*is triggered
 READ TABLE GT_EVENTS INTO LS_EVENT WITH KEY NAME = SLIS_EV_END_OF_LIST.

  IF SY-SUBRC = 0.
    MOVE 'END_OF_LIST2' TO LS_EVENT-FORM.
    MODIFY GT_EVENTS FROM LS_EVENT TRANSPORTING FORM
          WHERE NAME = SLIS_EV_END_OF_LIST.
  ENDIF.

*Pass the subroutine name to the USER_COMMAND event when the end of list
*is triggered
READ TABLE GT_EVENTS INTO LS_EVENT WITH KEY NAME = SLIS_EV_USER_COMMAND.
  IF SY-SUBRC = 0.
    MOVE 'USER_BACK' TO LS_EVENT-FORM.
    MODIFY GT_EVENTS FROM LS_EVENT TRANSPORTING FORM
          WHERE NAME = SLIS_EV_USER_COMMAND.
  ENDIF.

  CLEAR GS_LAYOUT.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM       = GV_REPID
      I_CALLBACK_PF_STATUS_SET = 'BACK_ALV'
      I_CALLBACK_USER_COMMAND  = 'USER_BACK'
      I_STRUCTURE_NAME         = LC_SNAME
      IS_LAYOUT                = GS_LAYOUT
      IT_FIELDCAT              = GT_FIELDCAT
      I_SAVE                   = GC_X
      IT_EVENTS                = GT_EVENTS
    TABLES
      T_OUTTAB                 = GT_COMMON
    EXCEPTIONS
      PROGRAM_ERROR            = 1
      OTHERS                   = 2.
  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM.                    " COMMON_DISPLAY

*&---------------------------------------------------------------------*
*&      Form  USER_BACK
*&---------------------------------------------------------------------*
*     Form which handles user command
*----------------------------------------------------------------------*
*  -->  IV_UCOMM        text
*  -->  IS_SELFIELD     text
*----------------------------------------------------------------------*
FORM USER_BACK USING IV_UCOMM TYPE SYUCOMM
                           IS_SELFIELD TYPE SLIS_SELFIELD.  "#EC *
  IF IV_UCOMM = 'ENT-'.
    SUBTRACT 1 FROM GV_TABINDEX.
    IS_SELFIELD-EXIT = 'X'.
  ELSEIF IV_UCOMM = 'ENT+'.
    ADD 1 TO GV_TABINDEX.
    IS_SELFIELD-EXIT = 'X'.
  ENDIF.

  IF HIDE_LINE_TYPE = 'S'.
    REFRESH GT_COMMON.
    READ TABLE GT_INST INTO GS_INST INDEX GV_TABINDEX.
    IF SY-SUBRC = 0.
      MOVE-CORRESPONDING GS_INST TO GS_COMMON.
      APPEND GS_COMMON TO GT_COMMON.
    ENDIF.
    PERFORM COMMON_DISPLAY.
  ELSEIF HIDE_LINE_TYPE = 'M'.
    REFRESH GT_COMMON.
    READ TABLE GT_MAND INTO GS_MAND INDEX GV_TABINDEX.
    IF SY-SUBRC = 0.
      MOVE-CORRESPONDING GS_MAND TO GS_COMMON.
      APPEND GS_COMMON TO GT_COMMON.
    ENDIF.
    PERFORM COMMON_DISPLAY.
  ELSEIF HIDE_LINE_TYPE = 'T'.
    REFRESH GT_COMMON.
    READ TABLE GT_TCOD INTO GS_TCOD INDEX GV_TABINDEX.
    IF SY-SUBRC = 0.
      MOVE-CORRESPONDING GS_TCOD TO GS_COMMON.
      APPEND GS_COMMON TO GT_COMMON.
    ENDIF.
    PERFORM COMMON_DISPLAY.
  ELSEIF HIDE_LINE_TYPE = 'R'.
    REFRESH GT_COMMON.
    READ TABLE GT_REPO INTO GS_REPO INDEX GV_TABINDEX.
    IF SY-SUBRC = 0.
      MOVE-CORRESPONDING GS_REPO TO GS_COMMON.
      APPEND GS_COMMON TO GT_COMMON.
    ENDIF.
    PERFORM COMMON_DISPLAY.
  ELSEIF HIDE_LINE_TYPE = 'B'.
    REFRESH GT_COMMON.
    READ TABLE GT_BENU INTO GS_BENU INDEX GV_TABINDEX.
    IF SY-SUBRC = 0.
      MOVE-CORRESPONDING GS_BENU TO GS_COMMON.
      APPEND GS_COMMON TO GT_COMMON.
    ENDIF.
    PERFORM COMMON_DISPLAY.
  ELSEIF HIDE_LINE_TYPE = 'I'.
    REFRESH GT_COMMON.
    READ TABLE GT_MSG INTO GS_MSG INDEX GV_TABINDEX.
    IF SY-SUBRC = 0.
      MOVE-CORRESPONDING GS_MSG TO GS_COMMON.
      APPEND GS_COMMON TO GT_COMMON.
    ENDIF.
    PERFORM COMMON_DISPLAY.
  ELSEIF HIDE_LINE_TYPE = 'E'.
    REFRESH GT_COMMON.
    READ TABLE GT_SNAP INTO GS_SNAP INDEX GV_TABINDEX.
    IF SY-SUBRC = 0.
      MOVE-CORRESPONDING GS_SNAP TO GS_COMMON.
      APPEND GS_COMMON TO GT_COMMON.
    ENDIF.
    PERFORM COMMON_DISPLAY.
  ELSEIF HIDE_LINE_TYPE = 'C'.
    REFRESH GT_CONTENTS1.
    READ TABLE GT_CONTENTS INTO GS_CONTENTS INDEX GV_TABINDEX.
    IF SY-SUBRC = 0.
      APPEND GS_CONTENTS TO GT_CONTENTS1.
      CLEAR GS_CONTENTS.
    ENDIF.
    PERFORM  CONTENTS1_ALV.
  ENDIF.

ENDFORM.                    " USER_BACK

*&---------------------------------------------------------------------*
*&      Form  CONTENTS1_ALV
*&---------------------------------------------------------------------*
FORM CONTENTS1_ALV .

  CONSTANTS:  LC_ITABLE  TYPE DD02L-TABNAME VALUE 'GT_CONTENTS1',
              LC_SNAME   TYPE DD02L-TABNAME VALUE 'IBD_SAPMSM2103_ALV'.
  DATA: LS_EVENT TYPE SLIS_ALV_EVENT.

  DATA: LV_TEXT(40) TYPE C.
  ADD 1 TO GV_LIST_COUNTER.
  REFRESH GT_FIELDCAT.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_ITABLE LC_SNAME
                                  CHANGING  GT_FIELDCAT .

  LOOP AT GT_FIELDCAT INTO GS_FIELDCAT.

    IF GS_FIELDCAT-FIELDNAME = 'END_PAGE'.
      GS_FIELDCAT-TECH = GC_X.
      MODIFY GT_FIELDCAT FROM GS_FIELDCAT TRANSPORTING TECH.
    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'HIDE_LINE_TYPE'.
      GS_FIELDCAT-TECH = GC_X.
      MODIFY GT_FIELDCAT FROM GS_FIELDCAT TRANSPORTING TECH.
    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'START_TIME'.
      GS_FIELDCAT-OUTPUTLEN = 21.
      MOVE '_________Start______;;'(051) TO LV_TEXT.
      GS_FIELDCAT-SELTEXT_L = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M = LV_TEXT.
      GS_FIELDCAT-SELTEXT_S = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
      MODIFY GT_FIELDCAT FROM GS_FIELDCAT TRANSPORTING SELTEXT_L
                    SELTEXT_M SELTEXT_S REPTEXT_DDIC OUTPUTLEN.
      CLEAR GS_FIELDCAT.
    ENDIF.
    IF GS_FIELDCAT-FIELDNAME = 'END_TIME'.
      MOVE '__End___;;'(052) TO LV_TEXT.
      GS_FIELDCAT-OUTPUTLEN = 21.
      GS_FIELDCAT-SELTEXT_L = LV_TEXT.
      GS_FIELDCAT-SELTEXT_M = LV_TEXT.
      GS_FIELDCAT-SELTEXT_S = LV_TEXT.
      GS_FIELDCAT-REPTEXT_DDIC = LV_TEXT.
      MODIFY GT_FIELDCAT FROM GS_FIELDCAT TRANSPORTING SELTEXT_L
                      SELTEXT_M SELTEXT_S REPTEXT_DDIC OUTPUTLEN.
      CLEAR GS_FIELDCAT.
    ENDIF.
  ENDLOOP.

*This is the perform which build the event tab
  REFRESH GT_EVENTS.
  PERFORM EVENTTAB_BUILD CHANGING GT_EVENTS[].

*Pass the subroutine name to the END-OF-LIST event when the end of list
*is triggered
 READ TABLE GT_EVENTS INTO LS_EVENT WITH KEY NAME = SLIS_EV_END_OF_LIST.

  IF SY-SUBRC = 0.
    MOVE 'END_OF_LIST2' TO LS_EVENT-FORM.
    MODIFY GT_EVENTS FROM LS_EVENT TRANSPORTING FORM
          WHERE NAME = SLIS_EV_END_OF_LIST.
  ENDIF.

*Pass the subroutine name to the USER_COMMAND event when the end of list
*is triggered
READ TABLE GT_EVENTS INTO LS_EVENT WITH KEY NAME = SLIS_EV_USER_COMMAND.
  IF SY-SUBRC = 0.
    MOVE 'USER_BACK' TO LS_EVENT-FORM.
    MODIFY GT_EVENTS FROM LS_EVENT TRANSPORTING FORM
          WHERE NAME = SLIS_EV_USER_COMMAND.
  ENDIF.

  CLEAR GS_LAYOUT.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM       = GV_REPID
      I_CALLBACK_PF_STATUS_SET = 'BACK_ALV'
      I_CALLBACK_USER_COMMAND  = 'USER_BACK'
      I_STRUCTURE_NAME         = LC_SNAME
      IS_LAYOUT                = GS_LAYOUT
      IT_FIELDCAT              = GT_FIELDCAT
      I_SAVE                   = GC_X
      IT_EVENTS                = GT_EVENTS
    TABLES
      T_OUTTAB                 = GT_CONTENTS1
    EXCEPTIONS
      PROGRAM_ERROR            = 1
      OTHERS                   = 2.
  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.


ENDFORM.                    " CONTENTS1_ALV

*&---------------------------------------------------------------------*
* To Display the lists consequently
*&---------------------------------------------------------------------*
*&      Form  end_of_list2
*&---------------------------------------------------------------------*
FORM END_OF_LIST2 .                                         "#EC CALLED

  data: lr_grid  type ref to cl_salv_form_layout_grid,
        lr_label       TYPE REF TO cl_salv_form_label,
        lr_content type ref to cl_salv_form_element.

*... a grid is created
  create object lr_grid.

  lr_label = lr_grid->create_label(
   row    = 1
   column = 1
   text    = 'There is no more information for this line.'(071) ).
  lr_content = lr_grid.
  cl_salv_form_content=>set( lr_content ).

ENDFORM.                      " END_OF_LIST2

*&---------------------------------------------------------------------*
*&      FORM  T_SORT_BUILD_ALV
*
*&---------------------------------------------------------------------*
*       THIS SUBROUTINE BUILD THE SORT TABLE                           *
*----------------------------------------------------------------------*
*      <--XT_SORT   Default Sort by date and time                      *
*----------------------------------------------------------------------*
FORM SORT_FILE_SORT_BUILD_ALV  CHANGING XT_SORT TYPE SLIS_T_SORTINFO_ALV
.

  DATA: LS_SORT TYPE SLIS_SORTINFO_ALV.

  LS_SORT-FIELDNAME = 'DATE_INT'.
  LS_SORT-SPOS = 1.
  LS_SORT-UP = 'X'.
  LS_SORT-GROUP = '*'.
  APPEND LS_SORT TO XT_SORT.
  CLEAR LS_SORT.
  LS_SORT-FIELDNAME = 'TIME'.
  LS_SORT-SPOS = 2.
  LS_SORT-UP = 'X'.
  APPEND LS_SORT TO XT_SORT.
  CLEAR LS_SORT.

ENDFORM.                    " SORT_FILE_SORT_BUILD


*----------------------------------------------------------------------*
*      <--XT_SORT   Sort by SENDR_ID                                   *
*----------------------------------------------------------------------*

FORM SORT_INST_SORT_BUILD_ALV  CHANGING XT_SORT TYPE SLIS_T_SORTINFO_ALV
.

  DATA: LS_SORT TYPE SLIS_SORTINFO_ALV.

  CLEAR XT_SORT.

ENDFORM.                    " SORT_INST_SORT_BUILD

*----------------------------------------------------------------------*
*      <--XT_SORT   Sort by TIME                                       *
*----------------------------------------------------------------------*

FORM SORT_TIME_SORT_BUILD_ALV  CHANGING XT_SORT TYPE SLIS_T_SORTINFO_ALV
.

  DATA: LS_SORT TYPE SLIS_SORTINFO_ALV.

  LS_SORT-FIELDNAME = 'DATE_INT'.
  LS_SORT-SPOS = 1.
  LS_SORT-UP = 'X'.
  LS_SORT-GROUP = '*'.
  APPEND LS_SORT TO XT_SORT.
  CLEAR LS_SORT.
  LS_SORT-FIELDNAME = 'TIME'.
  LS_SORT-SPOS = 2.
  LS_SORT-UP = 'X'.
  APPEND LS_SORT TO XT_SORT.
  CLEAR LS_SORT.
  LS_SORT-FIELDNAME = 'FILE_NO'.
  LS_SORT-SPOS = 3.
  LS_SORT-UP = 'X'.
  APPEND LS_SORT TO XT_SORT.
  CLEAR LS_SORT.
  LS_SORT-FIELDNAME = 'POS'.
  LS_SORT-SPOS = 4.
  LS_SORT-UP = 'X'.
  APPEND LS_SORT TO XT_SORT.
  CLEAR LS_SORT.

ENDFORM.                    " SORT_TIME_SORT_BUILD

*----------------------------------------------------------------------*
*      <--XT_SORT   Sort by CLASID                                     *
*----------------------------------------------------------------------*

FORM SORT_CLASID_SORT_BUILD_ALV  CHANGING XT_SORT TYPE
SLIS_T_SORTINFO_ALV.

  DATA: LS_SORT TYPE SLIS_SORTINFO_ALV.

  CLEAR XT_SORT.

ENDFORM.                    " SORT_CLASID_SORT_BUILD


*----------------------------------------------------------------------*
*      <--XT_SORT   Sort by TASK TYPE                                  *
*----------------------------------------------------------------------*

FORM SORT_TTYP_SORT_BUILD_ALV  CHANGING XT_SORT TYPE SLIS_T_SORTINFO_ALV
.

  DATA: LS_SORT TYPE SLIS_SORTINFO_ALV.

  CLEAR XT_SORT.

ENDFORM.                    " SORT_TTYP_SORT_BUILD

*----------------------------------------------------------------------*
*      <--XT_SORT   Sort by SYSLOG TYPE                                *
*----------------------------------------------------------------------*

FORM SORT_FTYP_SORT_BUILD_ALV  CHANGING XT_SORT TYPE SLIS_T_SORTINFO_ALV
.

  DATA: LS_SORT TYPE SLIS_SORTINFO_ALV.

  CLEAR XT_SORT.

ENDFORM.                    " SORT_FTYP_SORT_BUILD



*----------------------------------------------------------------------*
*      <--XT_SORT   Sort by DEVCLASS                                   *
*----------------------------------------------------------------------*

FORM SORT_DEVCLASS_SORT_BUILD_ALV  CHANGING XT_SORT TYPE
SLIS_T_SORTINFO_ALV.

  DATA: LS_SORT TYPE SLIS_SORTINFO_ALV.

  CLEAR XT_SORT.

ENDFORM.                    " SORT_DEVCLASS_SORT_BUILD

*----------------------------------------------------------------------*
*      <--XT_SORT   Sort by AREA and SUBID                             *
*----------------------------------------------------------------------*

FORM SORT_A_S_SORT_BUILD_ALV  CHANGING XT_SORT TYPE SLIS_T_SORTINFO_ALV.

  DATA: LS_SORT TYPE SLIS_SORTINFO_ALV.

  CLEAR XT_SORT.

ENDFORM.                    " SORT_A_S_SORT_BUILD


*---------------------------------------------------------------------
*       FORM TOP_OF_OUTLINE
*---------------------------------------------------------------------
*      For display data in TOP-OF-PAGE
*---------------------------------------------------------------------
FORM TOP_OF_OUTLINE.                                        "#EC CALLED

  data: lr_grid  type ref to cl_salv_form_layout_grid,
        lr_grid_inner  type ref to cl_salv_form_layout_grid,
        lr_label       TYPE REF TO cl_salv_form_label,
        lr_content type ref to cl_salv_form_element.

  DATA: LV_TEXT(40),
        LV_DATE(10),
        LV_H_DATE(10),
        LV_COUNTER TYPE I.


*... a grid is created
  create object lr_grid.

  CASE PAGE_TYPE.

    WHEN 'G'.

        ADD  1 TO LV_COUNTER.
        CLEAR HEADER_LINE.
        HEADER_LEN1 = STRLEN( SY-TITLE ) .
        HEADER_LEN2 = 40 - ( HEADER_LEN1 / 2 ) .
        IF HEADER_LEN2 < 0. HEADER_LEN2 = 0. ENDIF.
        WRITE SY-TITLE TO HEADER_LINE+HEADER_LEN2.
*       output on screen
        IF GV_OUTPUT_TERM = 'X'.
           ADD 1 TO GV_INDEX.
           ADD 1 TO GV_PAGE.
           IF GV_PAGE <> 1.
              READ TABLE INT_USE_DATE INDEX GV_INDEX.
              WRITE INT_USE_DATE-DATE TO LV_DATE.
              DO.
               READ TABLE GT_CONTENTS INDEX LV_H_IND INTO GS_CONTENTS.
               IF SY-SUBRC = 4.
                  EXIT.
               ENDIF.
               MOVE GS_CONTENTS-START_TIME(10) TO LV_H_DATE.
               IF LV_DATE = LV_H_DATE.
                  MOVE GS_CONTENTS-START_PAGE TO GV_PAGE.
                  EXIT.
               ELSE.
                  ADD 1 TO LV_H_IND.
               ENDIF.
             ENDDO.
           HEADER_LINE+75(5) = GV_PAGE.
           ENDIF.
        ELSE.
           IF GV_LIST_COUNTER = 3.
              ADD 1 TO GV_IND.
           ELSE.
              READ TABLE INT_USE_SIM_TOP INDEX GV_IND2.
              GV_IND = INT_USE_SIM_TOP-NUMBER.
           ENDIF.
        HEADER_LINE+75(5) = GV_IND.
        ENDIF.

        lr_grid_inner = lr_grid->create_grid(
              row = LV_COUNTER
              column = 1 ).

           lr_label = lr_grid_inner->create_label(
              row     = LV_COUNTER
              column  = 1
              text    = HEADER_LINE ).


      ADD 1 TO LV_COUNTER.

      IF GV_OUTPUT_TERM  = 'X'.
         READ TABLE INT_USE_DATE INDEX GV_INDEX.
         WRITE INT_USE_DATE-DATE TO LV_DATE.
      ELSE.
         READ TABLE INT_USE_SIM_TOP INDEX GV_IND2.
         WRITE INT_USE_DATE-DATE TO LV_DATE.
         ADD 1 TO GV_IND2.
      ENDIF.
      CONCATENATE  TEXT-117 ':' LV_DATE INTO LV_TEXT
                    SEPARATED BY SPACE.

      lr_grid_inner = lr_grid->create_grid(
        row = LV_COUNTER
        column = 1 ).

      lr_label = lr_grid_inner->create_label(
         row     = LV_COUNTER
         column  = 1
         text    = LV_TEXT ).

      lr_content = lr_grid.
      cl_salv_form_content=>set( lr_content ).

  ENDCASE.

ENDFORM.                    "TOP_OF_OUTLINE


*&---------------------------------------------------------------------*
*&      Form  SCROLL_TO_LIST
*&---------------------------------------------------------------------*
*      SCROLL TO LIST AND DISPLAY THE DATA
*----------------------------------------------------------------------*
FORM SCROLL_TO_LIST .

  data: ls_scroll_grid type lvc_s_scrl,
        ls_scroll_list type slis_list_scroll.

      call function 'REUSE_ALV_LIST_LAYOUT_INFO_GET'
        importing
          es_list_scroll = ls_scroll_list
        exceptions
          no_infos       = 1
          program_error  = 2
          others         = 3.
      if sy-subrc <> 0.
        message id sy-msgid type sy-msgty number sy-msgno
                with sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      endif.

   ls_scroll_list-lsind         = 1.
   ls_scroll_list-cpage         = 2.
   ls_scroll_list-staro         = 1.
   ls_scroll_list-staco         = 1.
   ls_scroll_list-cursor_line   = 1.
   ls_scroll_list-cursor_offset = 0.

  call function 'REUSE_ALV_LIST_LAYOUT_INFO_SET'
    exporting
      is_list_scroll = ls_scroll_list.


ENDFORM.                    " SCROLL_TO_LIST
*&---------------------------------------------------------------------*
*&      Form  GEN_OUTLINE_ALV
*&---------------------------------------------------------------------*
*     THIS DIESPLAYS DATA OF GEN_OUTLINE_DATA.
*----------------------------------------------------------------------*
FORM GEN_OUTLINE_ALV .

  CONSTANTS:  LC_ITABLE  TYPE DD02L-TABNAME VALUE 'GT_GEN_OUTLINE',
              LC_SNAME   TYPE DD02L-TABNAME VALUE 'IBD_SAPMSM2101_ALV'.
  DATA: LV_DATE TYPE D,
        LV_DATE1(10) TYPE C,
        LV_TEXT(40) TYPE C.

  PAGE_TYPE = 'G'.
  ADD 1 TO GV_LIST_COUNTER.
  REFRESH GT_FIELDCAT.

  READ TABLE GT_GEN_OUTLINE INTO GS_GEN_OUTLINE INDEX 1.
  CONCATENATE GS_GEN_OUTLINE-DATE+6(4) GS_GEN_OUTLINE-DATE+3(2)
  GS_GEN_OUTLINE-DATE+0(2) INTO GV_DATE.

* Subroutine for building Sort Table for Summary List
*  PERFORM T_SORT_BUILD_ALV CHANGING GT_SORT.

*This is the perform to build the field catalog
  PERFORM FIELDCATLOG_BUILD USING    LC_ITABLE LC_SNAME
                                  CHANGING  GT_FIELDCAT .
  LOOP AT GT_FIELDCAT INTO GS_FIELDCAT.

    GS_FIELDCAT-TECH = 'X'.

    IF LAYOUT-W_COL_POSI = SAP_YES.
      IF GS_FIELDCAT-FIELDNAME = 'FILE_NO'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      IF GS_FIELDCAT-FIELDNAME = 'POS'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

    ENDIF.

    IF LAYOUT-W_COL_DATE = SAP_YES.
      IF GS_FIELDCAT-FIELDNAME = 'DATE'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.
    ENDIF.

    IF LAYOUT-W_COL_INST = SAP_YES.

      IF GS_FIELDCAT-FIELDNAME = 'INSTID'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'TIME'.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    IF LAYOUT-W_COL_TASK = SAP_YES.

      IF GS_FIELDCAT-FIELDNAME = 'TSKNA'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      IF GS_FIELDCAT-FIELDNAME = 'TSKNU'.
        GS_FIELDCAT-TECH = SPACE.
        GS_FIELDCAT-SELTEXT_S    = text-999.
        GS_FIELDCAT-SELTEXT_M    = text-999.
        GS_FIELDCAT-SELTEXT_L    = text-999.
        GS_FIELDCAT-REPTEXT_DDIC = text-999.
      ENDIF.

    ENDIF.

    IF LAYOUT-W_COL_MAND = SAP_YES.

      IF GS_FIELDCAT-FIELDNAME = 'MAND'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

    ENDIF.

    IF LAYOUT-W_COL_USER = SAP_YES.

      IF GS_FIELDCAT-FIELDNAME = 'USER'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

    ENDIF.

    IF LAYOUT-W_COL_TRAN = SAP_YES.

      IF GS_FIELDCAT-FIELDNAME = 'TRANSCODE'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

    ENDIF.

    IF LAYOUT-W_COL_PROG = SAP_YES.

      IF GS_FIELDCAT-FIELDNAME = 'REPNA'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

    ENDIF.

    IF LAYOUT-W_COL_TERM = SAP_YES.

      IF GS_FIELDCAT-FIELDNAME = 'TERMINAL'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

    ENDIF.

    IF LAYOUT-W_COL_DEVC = SAP_YES.

      IF GS_FIELDCAT-FIELDNAME = 'DEVCLASS'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

    ENDIF.

    IF LAYOUT-W_COL_TABE = SAP_YES.

      IF GS_FIELDCAT-FIELDNAME = 'AREA'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

      IF GS_FIELDCAT-FIELDNAME = 'SUBID'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

    ENDIF.

    IF LAYOUT-W_COL_BEW = SAP_YES.

      IF GS_FIELDCAT-FIELDNAME = 'BEWERTUNG'.
        GS_FIELDCAT-TECH = SPACE.
      ENDIF.

    ENDIF.

      IF GS_FIELDCAT-FIELDNAME = 'ICON'.
        GS_FIELDCAT-TECH = SPACE.
        GS_FIELDCAT-ICON = GC_X.
        GS_FIELDCAT-OUTPUTLEN = 4.
      ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'TEXT'.
      GS_FIELDCAT-SELTEXT_S    = TEXT-105.
      GS_FIELDCAT-SELTEXT_M    = TEXT-105.
      GS_FIELDCAT-SELTEXT_L    = TEXT-105.
      GS_FIELDCAT-REPTEXT_DDIC = TEXT-105.
      GS_FIELDCAT-TECH = SPACE.
    ENDIF.

    IF GS_FIELDCAT-FIELDNAME = 'DATE_INT'.
       GS_FIELDCAT-TECH = 'X'.
    ENDIF.

    MODIFY GT_FIELDCAT FROM GS_FIELDCAT.

  ENDLOOP.

*This is the perform which build the event tab
  PERFORM EVENTTAB_BUILD CHANGING GT_EVENTS[].
CLEAR GS_LAYOUT.
* This is the perofrm to set the layout properties
  PERFORM LAYOUT_BUILD CHANGING GS_LAYOUT.
  GS_LAYOUT-MIN_LINESIZE =  GV_DEFAULT_LINESIZE.
  GS_LAYOUT-MAX_LINESIZE =  GV_DEFAULT_LINESIZE.
  GS_LAYOUT-colwidth_optimize = GC_X.
  GS_LAYOUT-zebra             = GC_X.
*  GS_LAYOUT-coltab_fieldname = 'COLOR'.
  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      I_CALLBACK_PROGRAM       = GV_REPID
      I_CALLBACK_PF_STATUS_SET = 'LIST_ALV'
      I_CALLBACK_USER_COMMAND  = 'USER_SYSTEM_LOG'
      I_STRUCTURE_NAME         = LC_SNAME
      IS_LAYOUT                = GS_LAYOUT
      IT_SORT                  = GT_SORT
      IT_FIELDCAT              = GT_FIELDCAT[]
      I_SAVE                   = GC_X
      IT_EVENTS                = GT_EVENTS
    TABLES
      T_OUTTAB                 = GT_GEN_OUTLINE
    EXCEPTIONS
      PROGRAM_ERROR            = 1
      OTHERS                   = 2.
  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM.                    " GEN_OUTLINE_ALV

*&---------------------------------------------------------------------*
*&      Form  icon_tool_tips_create
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->i_LGHT  text
*      -->i_TEXT  text
*      <--x_ICONID  text
*----------------------------------------------------------------------*
FORM icon_tool_tips_create  USING    I_LGHT
                                     I_TEXT
                            CHANGING X_ICONID.
  IF i_text IS NOT INITIAL.
    CALL FUNCTION 'ICON_CREATE'
      EXPORTING
        name                  = i_lght
        info                  = i_text
      IMPORTING
        RESULT                = X_iconid
      EXCEPTIONS
        icon_not_found        = 1
        outputfield_too_short = 2
        OTHERS                = 3.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
  ENDIF.

ENDFORM.                    " icon_tool_tips_create



*&---------------------------------------------------------------------*
*&      Form  set_print
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM SET_GT_PRINT changing GT_PRINT TYPE SLIS_PRINT_ALV.

*... the print structure can be set in order to change certain
*    print behaviours

  GT_PRINT-no_print_listinfos = 'X'.
  GT_PRINT-no_print_selinfos  = 'X'.

*... IMPORTANT NOTE: each list is printed on a new page. If you
*    would like to have all of the lists printed on the same page
*    set the field NO_NEW_PAGE to 'X'
* GT_PRINT-no_new_page        = 'X'.

ENDFORM.                    " set_print

*&---------------------------------------------------------------------*
*&     Form  print static part                                         *
*&---------------------------------------------------------------------*
FORM GEN_OUTLINE_STAT_ALV.

data: lr_grid         type ref to cl_salv_form_layout_grid,
      lr_label        TYPE REF TO cl_salv_form_label,
      lr_content      type ref to cl_salv_form_element,
      lr_abap         type ref to cl_salv_form_abap,
      Lr_text         TYPE REF TO cl_salv_form_text.
DATA: LV_COUNTER TYPE I.

* onyl for output to printer
* new page for statistic part
*

*  wirte statistic part if requested dynpro 0200
*
if dy_statistics = 'X'.
   if NOT GT_INST IS INITIAL.
      perform inst_alv.
      move GV_H_LIST_COUNTER to GV_LIST_COUNTER.
   endif.
   if NOT GT_MAND IS INITIAL.
      perform mand_alv.
      move GV_H_LIST_COUNTER to GV_LIST_COUNTER.
   endif.
   if NOT GT_REPO IS INITIAL.
      perform repo_alv.
      move GV_H_LIST_COUNTER to GV_LIST_COUNTER.
   endif.
   if NOT GT_TCOD IS INITIAL.
      perform tcod_alv.
      move GV_H_LIST_COUNTER to GV_LIST_COUNTER.
   endif.
   if NOT GT_BENU IS INITIAL.
      perform benu_alv.
      move GV_H_LIST_COUNTER to GV_LIST_COUNTER.
   endif.
   if NOT GT_MSG IS INITIAL.
      perform msg_alv.
      move GV_H_LIST_COUNTER to GV_LIST_COUNTER.
   endif.
   if NOT GT_SNAP IS INITIAL.
      perform snap_alv.
      move GV_H_LIST_COUNTER to GV_LIST_COUNTER.
   endif.
   GV_HIGH_LIST_COUNTER = 999.
endif.

IF GV_OUTPUT_TERM = ' '.
   new-page.
ENDIF.

*
*  write the statistics if selected
*

*     ... a grid is created
       create object lr_grid.
       create object lr_abap.

       LV_COUNTER = 1.
       LOOP AT GT_END INTO GS_END.
         ADD 1 TO LV_COUNTER.
         lr_label = lr_grid->create_label(
           row    = LV_COUNTER
           column = 1
          text    = GS_END-LINE ).
       ENDLOOP.
       lr_content = lr_grid.
       lr_abap->set_content( lr_grid ).
       lr_abap->display( ).

ENDFORM.

*&---------------------------------------------------------------------*
*&     Form  contents statist part                                     *
*&---------------------------------------------------------------------*
FORM GEN_OUTLINE_EOF_PART.

data: lr_grid         type ref to cl_salv_form_layout_grid,
        lr_label        TYPE REF TO cl_salv_form_label,
        lr_content      type ref to cl_salv_form_element,
        lr_abap         type ref to cl_salv_form_abap,
        Lr_text         TYPE REF TO cl_salv_form_text.
  DATA: LV_COUNTER TYPE I.

create object lr_grid.
       Lr_TEXT = lr_grid->create_TEXT(
         row    = 2
         column = 1
         text    = TEXT-040 ).

       CALL METHOD cl_salv_form_content=>set
            EXPORTING
           value = lr_grid.
ENDFORM.

*&---------------------------------------------------------------------*
*&     FORM   simulate writes for top of page                          *
*&---------------------------------------------------------------------*
FORM SIM_TOP_OF_PAGE.

DATA:  H_DATE(10)        TYPE C.
DATA:  H_PAGE_CNT        TYPE I.
DATA:  H_INT_CNT         TYPE I.

H_PAGE_CNT = SY-LINCT - 8.
H_INT_CNT  = 0.

LOOP AT OLD_INT_USE_OUTLINE.

ADD 1 TO H_INT_CNT.
IF SY-TABIX = 1.
   MOVE  OLD_INT_USE_OUTLINE-DATE    TO H_DATE.
   MOVE  OLD_INT_USE_OUTLINE-DATE    TO INT_USE_SIM_TOP-DATE.
   MOVE  OLD_INT_USE_OUTLINE-TIME    TO INT_USE_SIM_TOP-TIME.
   MOVE  OLD_INT_USE_OUTLINE-USER    TO INT_USE_SIM_TOP-USER.
   MOVE  OLD_INT_USE_OUTLINE-NUMBER  TO INT_USE_SIM_TOP-NUMBER.
   APPEND INT_USE_SIM_TOP.
ELSE.
   IF OLD_INT_USE_OUTLINE-DATE <> H_DATE OR H_INT_CNT > H_PAGE_CNT.
      MOVE  OLD_INT_USE_OUTLINE-DATE    TO INT_USE_SIM_TOP-DATE.
      MOVE  OLD_INT_USE_OUTLINE-TIME    TO INT_USE_SIM_TOP-TIME.
      MOVE  OLD_INT_USE_OUTLINE-USER    TO INT_USE_SIM_TOP-USER.
      MOVE  OLD_INT_USE_OUTLINE-NUMBER  TO INT_USE_SIM_TOP-NUMBER.
      APPEND INT_USE_SIM_TOP.
      MOVE  1 TO H_INT_CNT.
      MOVE  OLD_INT_USE_OUTLINE-DATE    TO H_DATE.
   ENDIF.
ENDIF.
ENDLOOP.

GV_IND2  = 1.

ENDFORM.


*&---------------------------------------------------------------------*
*&     FORM   in case of 's' type, set SNAP PF-STATUS                  *
*&---------------------------------------------------------------------*

FORM SET_TRUE_PF_STATUS.

IF  ENTRIESTAB-slgftyp <> 's'.
    DISABLED_FUNCTIONS-FUNC = 'SNAP'.
    APPEND DISABLED_FUNCTIONS.
    ELSE.
        LOOP AT DISABLED_FUNCTIONS.
        IF DISABLED_FUNCTIONS-FUNC = 'SNAP'.
           DELETE DISABLED_FUNCTIONS.
        ENDIF.
        ENDLOOP.
ENDIF.
ENDFORM.


*----------------------------------------------------------------------*
*       FORM    to store EXT_GT_....tables to memory id                *
*----------------------------------------------------------------------*

FORM GET_TABLES_EXTERNAL_USAGE using TR_GUID.

DATA:   BEGIN OF INT_MEM_ID
        ,     STORE_UNDER_ID  TYPE GUID_32
        ,     PART(7)
        ,     END OF INT_MEM_ID.

DATA:   BEGIN of EXT_GT_TOP occurs 0.
          include structure KERNELSTAT.
DATA:   END   of  EXT_GT_TOP.


DATA:   BEGIN of EXT_GT_GEN_OUTLINE occurs 0.
          include structure IBD_SAPMSM2101_ALV.
DATA:   END   of  EXT_GT_GEN_OUTLINE.

DATA:   BEGIN of EXT_GT_CONTENTS occurs 0.
          include structure IBD_SAPMSM2103_ALV.
DATA:   END   of  EXT_GT_CONTENTS.



MOVE TR_GUID  to INT_MEM_ID-STORE_UNDER_ID.

*++++++++++++++++++++++++++++++++++++++++++++++++++++++*
*   Prepare header lines for export to memory          *
********************************************************
LOOP AT GT_TOP INTO GS_TOP.
MOVE-CORRESPONDING GS_TOP TO EXT_GT_TOP.
APPEND EXT_GT_TOP.
ENDLOOP.
MOVE 'PART-01' to INT_MEM_ID-PART.
EXPORT EXT_GT_TOP to MEMORY ID INT_MEM_ID.

*++++++++++++++++++++++++++++++++++++++++++++++++++++++*
*   Prepare normal outpt lines for export to memory    *
********************************************************
LOOP AT GT_GEN_OUTLINE INTO GS_GEN_OUTLINE.
MOVE-CORRESPONDING GS_GEN_OUTLINE TO EXT_GT_GEN_OUTLINE.
APPEND EXT_GT_GEN_OUTLINE.
ENDLOOP.
MOVE 'PART-02' to INT_MEM_ID-PART.
EXPORT EXT_GT_GEN_OUTLINE to MEMORY ID INT_MEM_ID.

*++++++++++++++++++++++++++++++++++++++++++++++++++++++*
*   Prepare statistic  lines for export to memory      *
********************************************************
LOOP AT GT_CONTENTS INTO GS_CONTENTS.
MOVE-CORRESPONDING GS_CONTENTS TO EXT_GT_CONTENTS.
APPEND EXT_GT_CONTENTS.
ENDLOOP.
MOVE 'PART-03' to INT_MEM_ID-PART.
EXPORT EXT_GT_CONTENTS to MEMORY ID INT_MEM_ID.

ENDFORM.


*********************************************************
*  SORT OUTPUT TO FILE                                  *
*********************************************************
FORM  WRITE_SORT_TO_PC.

data:   len          type i value 321.
data:   sapv01(16)   type c value 'SOLO_SORT_SYSLOG'.

break-point.         "#EC NOBREAK
 if SORT_TO_PC  = 1 or SORT_TO_PC = 9.
   sort entriestab by POS_CREATT.
endif.

if SORT_TO_PC = 2 or SORT_TO_PC  = 8.
  sort entriestab by sender_id POS_CREATT.
endif.

if SORT_TO_PC  > 5.
   open dataset sapv01 in binary mode for output.
   loop  at entriestab.
      transfer entriestab to sapv01 LENGTH len.
   endloop.
   close dataset sapv01.
endif.

ENDFORM.

*********************************************************
*  ZPLUNK Custom Capture                                *
*********************************************************
FORM ZPLUNK_CAPTURE USING P_HOST P_SYSNAME P_SYSNR.
   DATA: L_GTYPE_OUTLINE TYPE GTYPE_OUTLINE.
   DATA LT_SM21 TYPE ZPLUNK_SM21.

   LOOP AT GT_GEN_OUTLINE INTO L_GTYPE_OUTLINE.
      CLEAR LT_SM21.
      CALL FUNCTION 'CONVERT_DATE_TO_INTERNAL'
         EXPORTING DATE_EXTERNAL = L_GTYPE_OUTLINE-DATE
         IMPORTING DATE_INTERNAL = LT_SM21-SAMPLEDATE.
      CONCATENATE L_GTYPE_OUTLINE-TIME+0(2) L_GTYPE_OUTLINE-TIME+3(2) L_GTYPE_OUTLINE-TIME+6(2) INTO LT_SM21-SAMPLETIME.
      REPLACE ':' WITH '' INTO LT_SM21-SAMPLETIME.
      LT_SM21-HOST = P_HOST.
      LT_SM21-SYSNAME = P_SYSNAME.
      LT_SM21-SYSNR = P_SYSNR.
      LT_SM21-WPTYPE = L_GTYPE_OUTLINE-TSKNA.
      LT_SM21-WPNO = L_GTYPE_OUTLINE-TSKNU.
      LT_SM21-MANDT = L_GTYPE_OUTLINE-MAND.
      LT_SM21-BNAME = L_GTYPE_OUTLINE-USER.
      LT_SM21-TCODE = L_GTYPE_OUTLINE-TRANSCODE.
      LT_SM21-REPNAME = L_GTYPE_OUTLINE-REPNA.
      LT_SM21-TERM = L_GTYPE_OUTLINE-TERMINAL.
      LT_SM21-DEVCLASS = L_GTYPE_OUTLINE-DEVCLASS.
      LT_SM21-AREA = L_GTYPE_OUTLINE-AREA.
      LT_SM21-SUBID = L_GTYPE_OUTLINE-SUBID.
      LT_SM21-ERRMSG = L_GTYPE_OUTLINE-TEXT.
      INSERT INTO ZPLUNK_SM21 VALUES LT_SM21.
   ENDLOOP.
ENDFORM.
