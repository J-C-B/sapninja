#summary ABAP implementation of RSA encryption

= Introduction =

It is beyond the scope of this WIKI to describe the theory behind public key encryption.  A very good summary can be found at http://en.wikipedia.org/wiki/RSA_(algorithm).  

SAPNINJA has provided ABAP implementations of two functions that provide the most basic building blocks you need.

You will need to use your own creativity to use the function provided here to encrypt text.  You will also need to generate your own public key, private key and modulus to be secure.  There are tools available on the web that will help you do this. 


=Details=

You will need to download and implement the following ABAP functions:
   * [http://code.google.com/p/sapninja/source/browse/trunk/tools/functionmodules/zmodexp.txt ZMODEXP]
   * [http://code.google.com/p/sapninja/source/browse/trunk/tools/functionmodules/zdec2bin.txt ZDEC2BIN]
   * Once you have implemented them, encryption and decryption can be done by using function ZMODEXP. 

==At it's simplest==
Assume that we want to encrypt and decrypt the letter "A".  If we translate it to it's ASCII code of 65, the following will illustrate the use of the functions.<br>
Assume the following<br>
   * Public Key = 17
   * Private Key = 2753
   * Modulus = 3233
<br><br>
To encrypt 65 with the public key
{{{
CALL FUNCTION ZMODEXP
   IMPORTING
      BASE    = 65
      KEY     = 17
      MODULUS = 3233
   IMPORTING 
      RESULT = RESULT
* The resulting encrypted number will be 2790.
}}}
To encrypt 2790 with the private key
{{{
CALL FUNCTION ZMODEXP
   IMPORTING
      BASE    = 2790
      KEY     = 2753
      MODULUS = 3233
   IMPORTING 
      RESULT = RESULT
* The resulting decrypted number will be 65, which is what we started with
}}}
= Hypothetical Example =
   * Say you have an application with an annual license.  Your license checking routine checks to see if license year has expired.  For our example, we are going to issue a license for the year 2011.
   * Using the example keys from the Wikipedia example we decide to use the following keys:
{{{
private key = 2753
public key  = 17
modulus     = 3233
}}}
   * You might decide to convert "2011" into zero-padded ASCII codes with 3 digits per character.  The packed string will be 050048049049
   * To stop people from identifying the characters easily by picking repetitions in the encrypted codes, you may decide to encrypt in chunks of 2 characters.  If you make the chunk too big, you risk arithmetic overflow ... happy to accept code improvements.
   * You want to encrypt 050048049049, broken up into the numbers
{{{
05
00
48
04
90
49
}}}
   * Using the MODEXP function with private key 2753 (which only you know as the developer) and modulus 3233, you encrypt it to the following numbers, which you might pad out to 4 digits.
{{{
3086
0000
0624
1387
1668
2906
1771
}}}
   * So you issue the user with a license key = 3086000006241387166829061771
   * On the other side, your program knows the license is packed in chunks of 4 and it can have the completely-visible public key of 17.
   * Using the MODEXP function with public key 17, which anyone can see, and modulus 3233, you break the license key into groups of four digits (3086, 0000,  ....) and decrypt each one to get back to the original, which you can translate back to 2011 via the ASCII chart.